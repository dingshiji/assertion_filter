{
  "file": "0_0.txt",
  "assertion": "assertNull ( existing layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existing layout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_1.txt",
  "assertion": "assertNull ( existingApplication )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingApplication ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_10.txt",
  "assertion": "assertNull ( existingContainer )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingContainer ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_11.txt",
  "assertion": "assertNull ( existingController )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingController ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_12.txt",
  "assertion": "assertNull ( existingModel )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingModel ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_13.txt",
  "assertion": "assertNull ( existingPattern )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingPattern ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_14.txt",
  "assertion": "assertNull ( existingLayer )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLayer ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_15.txt",
  "assertion": "assertNull ( existingPosition )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingPosition ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_16.txt",
  "assertion": "assertNull ( existingRoute )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingRoute ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_17.txt",
  "assertion": "assertNull ( existingConfiguration )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingConfiguration ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_18.txt",
  "assertion": "assertNull ( existingWidget )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingWidget ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_19.txt",
  "assertion": "assertNull ( existingComponent )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingComponent ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_2.txt",
  "assertion": "assertNull ( existing Layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existing Layout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_20.txt",
  "assertion": "assertNull ( existingFactory )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingFactory ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_21.txt",
  "assertion": "assertNull ( existingLayout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLayout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "existingLayout",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "0_22.txt",
  "assertion": "assertNull (isting layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull (isting layout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_23.txt",
  "assertion": "assertNull (existing layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull (existing layout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_24.txt",
  "assertion": "assertNull ( existingGroup )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingGroup ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_25.txt",
  "assertion": "assertNull ( app layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( app layout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_26.txt",
  "assertion": "assertNull ( existingLabel )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLabel ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_27.txt",
  "assertion": "assertNull ( existingFont )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingFont ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_28.txt",
  "assertion": "assertNull ( existingAnimation )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingAnimation ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_29.txt",
  "assertion": "assertNull ( creating layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( creating layout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_3.txt",
  "assertion": "assertNull ( existingLocation )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingLocation ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_4.txt",
  "assertion": "assertNull ( existingTemplate )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingTemplate ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_5.txt",
  "assertion": "assertNull ( existingBuilder )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingBuilder ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_6.txt",
  "assertion": "assertNull ( existingView )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingView ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_7.txt",
  "assertion": "assertNull ( existingSession )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingSession ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_8.txt",
  "assertion": "assertNull ( existingAppearance )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existingAppearance ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_9.txt",
  "assertion": "assertNull ( existinglayout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNull ( existinglayout ) ; }  }\r\n",
  "focal method": "class Y{ public void getPrimaryKey() { return _amImageEntryId ; } }\r\n",
  "truth": "assertNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_0.txt",
  "assertion": "assertNotNull ( molecule )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( molecule ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "molecule",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "10_1.txt",
  "assertion": "assertNotNull ( molecules )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( molecules ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_10.txt",
  "assertion": "assertNotNull ( orb )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( orb ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_11.txt",
  "assertion": "assertNotNull ( collection )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( collection ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_12.txt",
  "assertion": "assertNotNull ( mixture )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mixture ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_13.txt",
  "assertion": "assertNotNull ( lig )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( lig ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_14.txt",
  "assertion": "assertNotNull ( bond )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( bond ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_15.txt",
  "assertion": "assertNotNull ( 0 )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_16.txt",
  "assertion": "assertNotNull ( problem )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( problem ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_17.txt",
  "assertion": "assertNotNull ( bro )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( bro ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_18.txt",
  "assertion": "assertNotNull ( universe )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( universe ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_19.txt",
  "assertion": "assertNotNull ( output )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( output ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_2.txt",
  "assertion": "assertNotNull ( mol )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mol ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_20.txt",
  "assertion": "assertNotNull ( movie )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( movie ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_21.txt",
  "assertion": "assertNotNull ( mole )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mole ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_22.txt",
  "assertion": "assertNotNull ( circle )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( circle ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_23.txt",
  "assertion": "assertNotNull ( brother )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( brother ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_24.txt",
  "assertion": "assertNotNull ( maze )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( maze ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_25.txt",
  "assertion": "assertNotNull ( noise )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( noise ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_26.txt",
  "assertion": "assertNotNull ( residue )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( residue ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_27.txt",
  "assertion": "assertNotNull ( twist )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( twist ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_28.txt",
  "assertion": "assertNotNull ( manager )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( manager ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_29.txt",
  "assertion": "assertNotNull ( } )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( } ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "10_3.txt",
  "assertion": "assertNotNull ( container )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( container ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_4.txt",
  "assertion": "assertNotNull ( smiles )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( smiles ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "smiles",
  "parse context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "10_5.txt",
  "assertion": "assertNotNull ( knob )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( knob ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_6.txt",
  "assertion": "assertNotNull ( mixer )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( mixer ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_7.txt",
  "assertion": "assertNotNull ( coil )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( coil ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_8.txt",
  "assertion": "assertNotNull ( compound )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( compound ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_9.txt",
  "assertion": "assertNotNull ( element )\r\n",
  "test": "class X {public void testAcyclic ( ) { String smiles \u003d \"CCCCCCC\" ; SmilesParser smilesParser \u003d new SmilesParser ( SilentChemObjectBuilder . getInstance ( ) ) ; IAtomContainer molecule \u003d smilesParser . parseSmiles ( smiles ) ; molecule \u003d fbot . kekuliseAromaticRings ( molecule ) ; assertNotNull ( element ) ; }  }\r\n",
  "focal method": "class Y{ public void kekuliseAromaticRings( IAtomContainer  var24678 ) { IAtomContainer mNew \u003d null ; try { mNew \u003d ( ( IAtomContainer ) ( molecule . clone ( ) ) ) ; } catch ( Exception e ) { throw new CDKException ( \"Failed\u003csp\u003eto\u003csp\u003eclone\u003csp\u003esource\u003csp\u003emolecule\" ) ; } IRingSet ringSet ; try { ringSet \u003d removeExtraRings ( mNew ) ; } catch ( CDKException x ) { throw x ; } catch ( Exception x ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" , x ) ; } if ( ringSet \u003d\u003d null ) { throw new CDKException ( \"failure\u003csp\u003ein\u003csp\u003eSSSRFinder.findAllRings\" ) ; } List \u003c Integer [ ] \u003e rBondsArray \u003d null ; util . List \u003c List \u003c Integer \u003e \u003e ringGroups \u003d null ; rBondsArray \u003d getRingSystem ( mNew , ringSet ) ; ringGroups \u003d assignRingGroups ( rBondsArray ) ; for ( int i \u003d 0 ; i \u003c ( ringGroups . size ( ) ) ; i ++ ) { setAllRingBondsSingleOrder ( ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e atomNos \u003d null ; atomNos \u003d getAtomNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer \u003e bondNos \u003d null ; bondNos \u003d getBondNosForRingGroup ( mNew , ringGroups . get ( i ) , ringSet ) ; List \u003c Integer [ ] \u003e atomNoPairs \u003d null ; atomNoPairs \u003d getAtomNoPairsForRingGroup ( mNew , bondNos ) ; Matrix M \u003d new Matrix ( atomNos . size ( ) , bondNos . size ( ) ) ; for ( int x \u003d 0 ; x \u003c ( M . getRows ( ) ) ; x ++ ) { for ( int y \u003d 0 ; y \u003c ( M . getCols ( ) ) ; y ++ ) { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 0 ] ) ) { M . set ( x , y , 1 ) ; } else { if ( Objects . equals ( atomNos . get ( x ) , atomNoPairs . get ( y ) [ 1 ] ) ) { M . set ( x , y , 1 ) ; } else { M . set ( x , y , 0 ) ; } } } } List \u003c Integer \u003e freeValencies \u003d null ; freeValencies \u003d getFreeValenciesForRingGroup ( mNew , atomNos , M , ringSet ) ; List \u003c Integer \u003e bondOrders \u003d new ArrayList \u003c Integer \u003e ( ) ; for ( int j \u003d 0 ; j \u003c ( bondNos . size ( ) ) ; j ++ ) { bondOrders . add ( 0 ) ; } if ( solveMatrix ( M , atomNos , bondNos , freeValencies , atomNoPairs , bondOrders ) ) { for ( int j \u003d 0 ; j \u003c ( bondOrders . size ( ) ) ; j ++ ) { mNew . getBond ( bondNos . get ( j ) ) . SINGLE . setOrder ( ( ( bondOrders . get ( j ) ) \u003d\u003d 1 ? IBond . Order . SINGLE : IBond . Order . DOUBLE ) ) ; } } else { } } return mNew ; } }\r\n",
  "truth": "assertNotNull ( molecule )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "11_0.txt",
  "assertion": "assertEquals ( 2, 2S. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_1.txt",
  "assertion": "assertEquals ( 2, 2 set. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_10.txt",
  "assertion": "assertEquals ( 3, 2S. 4 column count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4 column count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_11.txt",
  "assertion": "assertEquals ( 3, 2 set. 4 column count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4 column count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_12.txt",
  "assertion": "assertEquals ( 3, 2S. 4Max count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4Max count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_13.txt",
  "assertion": "assertEquals ( 3, 2S. 4C count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4C count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_14.txt",
  "assertion": "assertEquals ( 4, 2S. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_15.txt",
  "assertion": "assertEquals ( 3, 2 set. 4Max count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4Max count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_16.txt",
  "assertion": "assertEquals ( 3, 2 set. 4C count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4C count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_17.txt",
  "assertion": "assertEquals ( 4, 2 set. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2 set. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_18.txt",
  "assertion": "assertEquals ( 2, 2S. 4N2 ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4N2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_19.txt",
  "assertion": "assertEquals ( 2, 2 set. 4N2 ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4N2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_2.txt",
  "assertion": "assertEquals ( 2, 2S. 4 column count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4 column count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_20.txt",
  "assertion": "assertEquals ( 4, 2S. 4 column count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4 column count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_21.txt",
  "assertion": "assertEquals ( 2, 2Offset. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2Offset. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_22.txt",
  "assertion": "assertEquals ( 4, 2 set. 4 column count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2 set. 4 column count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_23.txt",
  "assertion": "assertEquals ( 2, 2S. 4 column2 ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4 column2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_24.txt",
  "assertion": "assertEquals ( 2, 2 set. 4 column2 ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4 column2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_25.txt",
  "assertion": "assertEquals ( 4, 2S. 4Max count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4Max count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_26.txt",
  "assertion": "assertEquals ( 4, 2S. 4C count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, 2S. 4C count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_27.txt",
  "assertion": "assertEquals ( 2, 2Offset. 4 column count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2Offset. 4 column count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_28.txt",
  "assertion": "assertEquals ( 5, 2S. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 5, 2S. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_29.txt",
  "assertion": "assertEquals ( 3, 2S. 4N2 ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4N2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_3.txt",
  "assertion": "assertEquals ( 2, 2 set. 4 column count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4 column count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_4.txt",
  "assertion": "assertEquals ( 3, 2S. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2S. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_5.txt",
  "assertion": "assertEquals ( 2, 2S. 4Max count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4Max count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_6.txt",
  "assertion": "assertEquals ( 2, 2S. 4C count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2S. 4C count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_7.txt",
  "assertion": "assertEquals ( 3, 2 set. 4N count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, 2 set. 4N count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_8.txt",
  "assertion": "assertEquals ( 2, 2 set. 4Max count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4Max count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_9.txt",
  "assertion": "assertEquals ( 2, 2 set. 4C count ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, 2 set. 4C count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getColumnCount() { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_0.txt",
  "assertion": "assertEquals ( set 3, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_1.txt",
  "assertion": "assertEquals ( set 3, set ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set ) ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_10.txt",
  "assertion": "assertEquals ( set1, set1 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set1 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "12_11.txt",
  "assertion": "assertEquals ( set 3, set3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_12.txt",
  "assertion": "assertEquals ( set3, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set3, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_13.txt",
  "assertion": "assertEquals ( set 3, set0 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set0 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_14.txt",
  "assertion": "assertEquals ( set0, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set0, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_15.txt",
  "assertion": "assertEquals ( set2, set ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set ) ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_16.txt",
  "assertion": "assertEquals ( set1, set2 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set2 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "set2",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "12_17.txt",
  "assertion": "assertEquals ( set2, set1 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set1 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "set1",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "12_18.txt",
  "assertion": "assertEquals ( set 3, set4 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set4 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_19.txt",
  "assertion": "assertEquals ( set4, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set4, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_2.txt",
  "assertion": "assertEquals ( set 3, set1 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set1 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_20.txt",
  "assertion": "assertEquals ( set2, set2 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set2 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "12_21.txt",
  "assertion": "assertEquals ( set 3, set5 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set5 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_22.txt",
  "assertion": "assertEquals ( set5, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set5, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_23.txt",
  "assertion": "assertEquals ( set\", set ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\", set ) ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_24.txt",
  "assertion": "assertEquals ( set 3, setified )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, setified ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_25.txt",
  "assertion": "assertEquals ( set\", set1 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\", set1 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_26.txt",
  "assertion": "assertEquals ( set1, set\" )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set\" ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_27.txt",
  "assertion": "assertEquals ( set 3, set8 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set8 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_28.txt",
  "assertion": "assertEquals ( set\", set2 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\", set2 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_29.txt",
  "assertion": "assertEquals ( set2, set\" )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set\" ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_3.txt",
  "assertion": "assertEquals ( set1, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_4.txt",
  "assertion": "assertEquals ( set 3, set2 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set2 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_5.txt",
  "assertion": "assertEquals ( set2, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set2, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_6.txt",
  "assertion": "assertEquals ( set\", set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set\", set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_7.txt",
  "assertion": "assertEquals ( set 3, set\" )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set 3, set\" ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_8.txt",
  "assertion": "assertEquals ( set{, set 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set{, set 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_9.txt",
  "assertion": "assertEquals ( set1, set ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( set1, set ) ) ; }  }\r\n",
  "focal method": "class Y{ public void addAll( Collection  var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_0.txt",
  "assertion": "assertFalse ( answer. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_1.txt",
  "assertion": "assertFalse ( answer. result result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. result result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_10.txt",
  "assertion": "assertFalse ( answer. test result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. test result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_11.txt",
  "assertion": "assertFalse ( answer. to result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. to result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_12.txt",
  "assertion": "assertFalse ( answers. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answers. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_13.txt",
  "assertion": "assertFalse ( answer. are result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. are result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_14.txt",
  "assertion": "assertFalse ( answer. check result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. check result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_15.txt",
  "assertion": "assertFalse ( answer. got result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. got result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_16.txt",
  "assertion": "assertFalse ( answers. result result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answers. result result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_17.txt",
  "assertion": "assertFalse ( answer. r result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. r result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_18.txt",
  "assertion": "assertFalse ( answer. given result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. given result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_19.txt",
  "assertion": "assertFalse ( answer. int result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. int result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_2.txt",
  "assertion": "assertFalse ( answer. return result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. return result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_20.txt",
  "assertion": "assertFalse ( response. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( response. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_21.txt",
  "assertion": "assertFalse ( reply. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( reply. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_22.txt",
  "assertion": "assertFalse ( answered. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answered. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_23.txt",
  "assertion": "assertFalse ( answer. responseResponse ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. responseResponse ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_24.txt",
  "assertion": "assertFalse ( answer. returns result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. returns result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_25.txt",
  "assertion": "assertFalse (answer. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse (answer. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_26.txt",
  "assertion": "assertFalse ( answering. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answering. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_27.txt",
  "assertion": "assertFalse ( answer. responseresult ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. responseresult ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_28.txt",
  "assertion": "assertFalse ( result. response result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( result. response result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_29.txt",
  "assertion": "assertFalse ( response. result result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( response. result result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_3.txt",
  "assertion": "assertFalse ( answer. user result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. user result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_4.txt",
  "assertion": "assertFalse ( answer. is result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. is result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_5.txt",
  "assertion": "assertFalse ( answer. use result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. use result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_6.txt",
  "assertion": "assertFalse ( answer. get result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. get result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_7.txt",
  "assertion": "assertFalse ( answer. set result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. set result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_8.txt",
  "assertion": "assertFalse ( answer. can result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. can result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_9.txt",
  "assertion": "assertFalse ( answer. has result ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertFalse ( answer. has result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getResult() { return this . result ; } }\r\n",
  "truth": "assertFalse ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "14_1.txt",
  "assertion": "assertEquals ( expect, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expect, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_10.txt",
  "assertion": "assertEquals ( expected, expecting )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, expecting ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_11.txt",
  "assertion": "assertEquals ( 10, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 10, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_12.txt",
  "assertion": "assertEquals (expected, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "14_13.txt",
  "assertion": "assertEquals ( unexpected, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( unexpected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_14.txt",
  "assertion": "assertEquals ( expected, unexpected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, unexpected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_15.txt",
  "assertion": "assertEquals ( 0, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 0, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_16.txt",
  "assertion": "assertEquals ( ast, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( ast, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_17.txt",
  "assertion": "assertEquals ( expected, ast )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, ast ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_18.txt",
  "assertion": "assertEquals ( 3, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 3, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_19.txt",
  "assertion": "assertEquals ( expected, 3 )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_2.txt",
  "assertion": "assertEquals ( expected, expect )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, expect ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_20.txt",
  "assertion": "assertEquals ( 2, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 2, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_21.txt",
  "assertion": "assertEquals ( expected, 2 )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_22.txt",
  "assertion": "assertEquals ( 1, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 1, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_23.txt",
  "assertion": "assertEquals ( 8, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 8, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_24.txt",
  "assertion": "assertEquals ( string, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( string, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_25.txt",
  "assertion": "assertEquals ( expected, string )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, string ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_26.txt",
  "assertion": "assertEquals ( str, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( str, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_27.txt",
  "assertion": "assertEquals ( line, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( line, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_28.txt",
  "assertion": "assertEquals ( expected, line )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, line ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_29.txt",
  "assertion": "assertEquals ( body, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( body, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_3.txt",
  "assertion": "assertEquals (pected, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (pected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_4.txt",
  "assertion": "assertEquals ( code, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( code, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "14_5.txt",
  "assertion": "assertEquals ( expected, code )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, code ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "code",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "14_6.txt",
  "assertion": "assertEquals ( null, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( null, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "14_7.txt",
  "assertion": "assertEquals ( tree, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( tree, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "incompatible type"
}
,
{
  "file": "14_8.txt",
  "assertion": "assertEquals ( expected, tree )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, tree ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tree",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "incompatible type"
}
,
{
  "file": "14_9.txt",
  "assertion": "assertEquals ( expecting, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expecting, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse() { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "15_0.txt",
  "assertion": "assertEquals ( 2, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_1.txt",
  "assertion": "assertEquals ( 1, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_10.txt",
  "assertion": "assertEquals ( 5, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 5, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_11.txt",
  "assertion": "assertEquals ( 7, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 7, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_12.txt",
  "assertion": "assertEquals ( 3, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 3, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_13.txt",
  "assertion": "assertEquals ( 4, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 4, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_14.txt",
  "assertion": "assertEquals ( 6, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 6, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_15.txt",
  "assertion": "assertEquals ( 5, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 5, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_16.txt",
  "assertion": "assertEquals ( 2, 2. count ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 2. count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_17.txt",
  "assertion": "assertEquals ( 8, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 8, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_18.txt",
  "assertion": "assertEquals ( 9, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 9, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_19.txt",
  "assertion": "assertEquals ( 2, 2. length ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 2. length ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_2.txt",
  "assertion": "assertEquals ( 0, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_20.txt",
  "assertion": "assertEquals ( 1, 2. count ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 2. count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_21.txt",
  "assertion": "assertEquals ( 0, 2. count ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 2. count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_22.txt",
  "assertion": "assertEquals ( 2, 0. count ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 0. count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_23.txt",
  "assertion": "assertEquals ( 8, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 8, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_24.txt",
  "assertion": "assertEquals ( 9, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 9, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_25.txt",
  "assertion": "assertEquals ( 10, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 10, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_26.txt",
  "assertion": "assertEquals ( 1, 2. length ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 2. length ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_27.txt",
  "assertion": "assertEquals ( 0, 2. length ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 2. length ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_28.txt",
  "assertion": "assertEquals ( 2, 0. length ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 0. length ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_29.txt",
  "assertion": "assertEquals ( 1, 0. count ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 0. count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_3.txt",
  "assertion": "assertEquals ( 2, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 2, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_4.txt",
  "assertion": "assertEquals ( 1, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 1, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_5.txt",
  "assertion": "assertEquals ( 0, 0. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 0, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_6.txt",
  "assertion": "assertEquals ( 7, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 7, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_7.txt",
  "assertion": "assertEquals ( 3, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 3, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_8.txt",
  "assertion": "assertEquals ( 4, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 4, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_9.txt",
  "assertion": "assertEquals ( 6, 2. size ( ) )\r\n",
  "test": "class X {public void testGetJavaClassesByRegExp ( ) { String regexp \u003d \".*Lock.*\" ; Collection result \u003d heap . getJavaClassesByRegExp ( regexp ) ; assertEquals ( 6, 2. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { synchronized ( dataLock ) { return curSize ; } } }\r\n",
  "truth": "assertEquals ( 6, result. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "16_0.txt",
  "assertion": "assertEquals ( tx, 0 [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_1.txt",
  "assertion": "assertEquals ( tx, expected [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_10.txt",
  "assertion": "assertEquals ( tx, output [ 1 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_11.txt",
  "assertion": "assertEquals ( tx, result [ 1 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_12.txt",
  "assertion": "assertEquals ( tx, expected [ 10 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 10 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_13.txt",
  "assertion": "assertEquals ( tx, expected [ 100 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 100 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_14.txt",
  "assertion": "assertEquals ( tx, 0 [ 15 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 15 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_15.txt",
  "assertion": "assertEquals ( tx, ret [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, ret [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_16.txt",
  "assertion": "assertEquals ( tx, 0 [ 4 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 4 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_17.txt",
  "assertion": "assertEquals ( tx, test [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, test [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_18.txt",
  "assertion": "assertEquals ( tx, expected [ 15 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 15 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_19.txt",
  "assertion": "assertEquals ( tx, expected [ 4 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 4 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_2.txt",
  "assertion": "assertEquals ( tx, output [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_20.txt",
  "assertion": "assertEquals ( tx, output [ 10 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 10 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_21.txt",
  "assertion": "assertEquals ( tx, output [ 100 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, output [ 100 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_22.txt",
  "assertion": "assertEquals ( tx, 0 [ 16 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 16 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_23.txt",
  "assertion": "assertEquals ( tx, result [ 10 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 10 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_24.txt",
  "assertion": "assertEquals ( tx, result [ 100 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 100 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_25.txt",
  "assertion": "assertEquals ( tx, 2 [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 2 [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_26.txt",
  "assertion": "assertEquals ( tx, 0 [ 2 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 2 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_27.txt",
  "assertion": "assertEquals ( tx, expected [ 16 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 16 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_28.txt",
  "assertion": "assertEquals ( tx, target [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, target [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_29.txt",
  "assertion": "assertEquals ( tx, return [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, return [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "16_3.txt",
  "assertion": "assertEquals ( tx, result [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, result [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "16_4.txt",
  "assertion": "assertEquals ( tx, 0 [ 1 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_5.txt",
  "assertion": "assertEquals ( tx, expected [ 1 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, expected [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_6.txt",
  "assertion": "assertEquals ( tx, response [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, response [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_7.txt",
  "assertion": "assertEquals ( tx, out [ 0 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, out [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_8.txt",
  "assertion": "assertEquals ( tx, 0 [ 10 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 10 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "16_9.txt",
  "assertion": "assertEquals ( tx, 0 [ 100 ] )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( tx, 0 [ 100 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void pingAndWait( InboundMessageQueuer  var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "tx",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "17_0.txt",
  "assertion": "assertNull ( form )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( form ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "form",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "17_1.txt",
  "assertion": "assertNull (form )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull (form ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "form",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "17_10.txt",
  "assertion": "assertNull ( label )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( label ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_11.txt",
  "assertion": "assertNull ( text )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( text ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_12.txt",
  "assertion": "assertNull ( question )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( question ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_13.txt",
  "assertion": "assertNull ( parent )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( parent ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_14.txt",
  "assertion": "assertNull ( hand )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( hand ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_15.txt",
  "assertion": "assertNull ( word )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( word ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_16.txt",
  "assertion": "assertNull ( type )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( type ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_17.txt",
  "assertion": "assertNull ( answer )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( answer ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_18.txt",
  "assertion": "assertNull ( model )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( model ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_19.txt",
  "assertion": "assertNull ( term )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( term ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_2.txt",
  "assertion": "assertNull ( Form )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( Form ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_20.txt",
  "assertion": "assertNull ( reform )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( reform ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_21.txt",
  "assertion": "assertNull ( sign )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( sign ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_22.txt",
  "assertion": "assertNull ( list )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( list ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_23.txt",
  "assertion": "assertNull ( ad )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( ad ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_24.txt",
  "assertion": "assertNull ( user )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( user ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_25.txt",
  "assertion": "assertNull ( page )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( page ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_26.txt",
  "assertion": "assertNull ( stream )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( stream ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_27.txt",
  "assertion": "assertNull ( control )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( control ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_28.txt",
  "assertion": "assertNull ( board )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( board ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_29.txt",
  "assertion": "assertNull ( FORM )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( FORM ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_3.txt",
  "assertion": "assertNull ( name )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( name ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_4.txt",
  "assertion": "assertNull ( forms )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( forms ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_5.txt",
  "assertion": "assertNull ( field )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( field ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_6.txt",
  "assertion": "assertNull ( test )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( test ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_7.txt",
  "assertion": "assertNull ( body )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( body ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_8.txt",
  "assertion": "assertNull ( post )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( post ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_9.txt",
  "assertion": "assertNull ( content )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertNull ( content ) ; }  }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper( Drug  var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_0.txt",
  "assertion": "assertFalse ( panel. page v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. page v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_1.txt",
  "assertion": "assertFalse ( panel. button v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. button v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_10.txt",
  "assertion": "assertFalse ( panel. pageP visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. pageP visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_11.txt",
  "assertion": "assertFalse ( panel. pageTV visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. pageTV visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_12.txt",
  "assertion": "assertFalse ( panel. is v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. is v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_13.txt",
  "assertion": "assertFalse ( panel. can v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. can v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_14.txt",
  "assertion": "assertFalse ( panel. show v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. show v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_15.txt",
  "assertion": "assertFalse ( panel. pageView visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. pageView visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_16.txt",
  "assertion": "assertFalse ( panel. button v invisible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. button v invisible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_17.txt",
  "assertion": "assertFalse ( panel. pagev visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. pagev visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_18.txt",
  "assertion": "assertFalse ( panel. buttonP visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. buttonP visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_19.txt",
  "assertion": "assertFalse ( panel. check v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. check v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_2.txt",
  "assertion": "assertFalse ( panel. user v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. user v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_20.txt",
  "assertion": "assertFalse ( panel. buttonTV visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. buttonTV visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_21.txt",
  "assertion": "assertFalse ( panel. page V visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. page V visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_22.txt",
  "assertion": "assertFalse ( panel. buttonView visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. buttonView visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_23.txt",
  "assertion": "assertFalse ( panel. has v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. has v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_24.txt",
  "assertion": "assertFalse ( panel. page vabled ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. page vabled ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_25.txt",
  "assertion": "assertFalse ( panel. buttonv visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. buttonv visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_26.txt",
  "assertion": "assertFalse ( panel. user v accessible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. user v accessible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_27.txt",
  "assertion": "assertFalse ( panel. pageVersion visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. pageVersion visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_28.txt",
  "assertion": "assertFalse ( panel. view v accessible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. view v accessible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_29.txt",
  "assertion": "assertFalse ( panel. pageG visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. pageG visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_3.txt",
  "assertion": "assertFalse ( panel. view v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. view v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_4.txt",
  "assertion": "assertFalse ( panel. page v accessible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. page v accessible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_5.txt",
  "assertion": "assertFalse ( panel. page vable ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. page vable ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_6.txt",
  "assertion": "assertFalse ( panel. button v accessible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. button v accessible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_7.txt",
  "assertion": "assertFalse ( panel. page v invisible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. page v invisible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_8.txt",
  "assertion": "assertFalse ( panel. icon v visible ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. icon v visible ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "18_9.txt",
  "assertion": "assertFalse ( panel. button vable ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertFalse ( panel. button vable ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void isVisible() { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_0.txt",
  "assertion": "assertEquals ( 1, entry. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entry. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_1.txt",
  "assertion": "assertEquals ( 3, entry. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 3, entry. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_10.txt",
  "assertion": "assertEquals ( 1, entry. total total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entry. total total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_11.txt",
  "assertion": "assertEquals ( 5, entries. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 5, entries. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_12.txt",
  "assertion": "assertEquals ( 1, entry. size total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entry. size total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_13.txt",
  "assertion": "assertEquals ( 1, count. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, count. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_14.txt",
  "assertion": "assertEquals ( 4, entry. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 4, entry. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_15.txt",
  "assertion": "assertEquals ( 3, entry. set total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 3, entry. set total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_16.txt",
  "assertion": "assertEquals ( 2, entry. set total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 2, entry. set total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_17.txt",
  "assertion": "assertEquals ( 1, entry. number total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entry. number total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_18.txt",
  "assertion": "assertEquals ( 3, result. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 3, result. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_19.txt",
  "assertion": "assertEquals ( 3, entry. total total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 3, entry. total total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_2.txt",
  "assertion": "assertEquals ( 2, entry. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 2, entry. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_20.txt",
  "assertion": "assertEquals ( 2, result. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 2, result. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_21.txt",
  "assertion": "assertEquals ( 5, entry. set total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 5, entry. set total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_22.txt",
  "assertion": "assertEquals ( 1, entry. return total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entry. return total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_23.txt",
  "assertion": "assertEquals ( 2, entry. total total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 2, entry. total total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_24.txt",
  "assertion": "assertEquals ( 3, entry. size total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 3, entry. size total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_25.txt",
  "assertion": "assertEquals ( 3, count. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 3, count. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_26.txt",
  "assertion": "assertEquals ( 2, entry. size total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 2, entry. size total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_27.txt",
  "assertion": "assertEquals ( 2, count. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 2, count. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_28.txt",
  "assertion": "assertEquals ( 5, result. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 5, result. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_29.txt",
  "assertion": "assertEquals ( 1, entries. set total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entries. set total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_3.txt",
  "assertion": "assertEquals ( 5, entry. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 5, entry. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_4.txt",
  "assertion": "assertEquals ( 1, entries. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entries. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_5.txt",
  "assertion": "assertEquals ( 1, entry. set total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, entry. set total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_6.txt",
  "assertion": "assertEquals ( 3, entries. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 3, entries. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_7.txt",
  "assertion": "assertEquals ( 0, entry. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 0, entry. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_8.txt",
  "assertion": "assertEquals ( 2, entries. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 2, entries. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_9.txt",
  "assertion": "assertEquals ( 1, result. count total results ( ) )\r\n",
  "test": "class X {public void testSetResultWithPersonEntry ( ) { AbstractEntry entry \u003d new PersonEntry ( new Person ( ) , 1 , 1 , \"name\" , 5 ) ; controller . setResultOptions ( entry , 3 , 2 , \"name\" ) ; assertEquals ( 1, result. count total results ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getTotalResults() { return totalResults ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_0.txt",
  "assertion": "assertEquals ( users, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_1.txt",
  "assertion": "assertEquals ( 0, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_10.txt",
  "assertion": "assertEquals ( user, 0. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( user, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_11.txt",
  "assertion": "assertEquals ( 1, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_12.txt",
  "assertion": "assertEquals ( 0, Users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, Users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_13.txt",
  "assertion": "assertEquals ( Users, 0. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( Users, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_14.txt",
  "assertion": "assertEquals (Users, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (Users, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_15.txt",
  "assertion": "assertEquals ( users,Users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users,Users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_16.txt",
  "assertion": "assertEquals ( null, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( null, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_17.txt",
  "assertion": "assertEquals ( users, null. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, null. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_18.txt",
  "assertion": "assertEquals ( 0, users. null ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. null ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_19.txt",
  "assertion": "assertEquals ( users, 0. null ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, 0. null ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_2.txt",
  "assertion": "assertEquals ( users, 0. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_20.txt",
  "assertion": "assertEquals ( 1, 0. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_21.txt",
  "assertion": "assertEquals ( users, users. empty ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, users. empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "users",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_22.txt",
  "assertion": "assertEquals ( 0,Users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0,Users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_23.txt",
  "assertion": "assertEquals (Users, 0. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (Users, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_24.txt",
  "assertion": "assertEquals ( null, 0. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( null, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_25.txt",
  "assertion": "assertEquals ( 0, null. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, null. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_26.txt",
  "assertion": "assertEquals ( 0, 0. null ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, 0. null ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_27.txt",
  "assertion": "assertEquals ( 0, users. empty ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_28.txt",
  "assertion": "assertEquals ( users, 0. empty ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, 0. empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_29.txt",
  "assertion": "assertEquals ( empty, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( empty, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_3.txt",
  "assertion": "assertEquals ( 0, 0. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_4.txt",
  "assertion": "assertEquals ( user, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( user, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_5.txt",
  "assertion": "assertEquals ( users, user. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, user. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_6.txt",
  "assertion": "assertEquals ( Users, users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( Users, users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_7.txt",
  "assertion": "assertEquals ( users, Users. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, Users. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_8.txt",
  "assertion": "assertEquals ( users, users. null ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( users, users. null ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_9.txt",
  "assertion": "assertEquals ( 0, user. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, user. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification( Topic  var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "21_0.txt",
  "assertion": "assertTrue ( value. value ( Double. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_1.txt",
  "assertion": "assertTrue ( value. value ( \". 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \". 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_10.txt",
  "assertion": "assertTrue ( value. value ( Math. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Math. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_11.txt",
  "assertion": "assertTrue ( value. value ( math. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( math. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_12.txt",
  "assertion": "assertTrue ( value. value ( 0. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 0. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_13.txt",
  "assertion": "assertTrue ( value. value ( (. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( (. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_14.txt",
  "assertion": "assertTrue ( value. value ( 10. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 10. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_15.txt",
  "assertion": "assertTrue ( value. value ( is. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( is. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_16.txt",
  "assertion": "assertTrue ( value. value ( 100. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 100. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_17.txt",
  "assertion": "assertTrue ( value. value ( (. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( (. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_18.txt",
  "assertion": "assertTrue ( value. value ( 1. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 1. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_19.txt",
  "assertion": "assertTrue ( value. value ( 1000. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 1000. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_2.txt",
  "assertion": "assertTrue ( value. value ( \"\". 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \"\". 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_20.txt",
  "assertion": "assertTrue ( value. value ( 10. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 10. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_21.txt",
  "assertion": "assertTrue ( value. value ( 7. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 7. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_22.txt",
  "assertion": "assertTrue ( value. value ( 5. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 5. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_23.txt",
  "assertion": "assertTrue ( value. value ( 100. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 100. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_24.txt",
  "assertion": "assertTrue ( value. value ( Double. 0 F ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0 F ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_25.txt",
  "assertion": "assertTrue ( value. value ( \". 0 F ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \". 0 F ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_26.txt",
  "assertion": "assertTrue ( value. value ( \"\". 0 F ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \"\". 0 F ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_27.txt",
  "assertion": "assertTrue ( value. value ( Math. 0 F ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Math. 0 F ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_28.txt",
  "assertion": "assertTrue ( value. value ( math. 0 F ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( math. 0 F ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_29.txt",
  "assertion": "assertTrue ( value. value ( Double. 0\u0027 ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0\u0027 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_3.txt",
  "assertion": "assertTrue ( value. value ( Math. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Math. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_4.txt",
  "assertion": "assertTrue ( value. value ( math. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( math. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_5.txt",
  "assertion": "assertTrue ( value. value ( 0. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( 0. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_6.txt",
  "assertion": "assertTrue ( value. value ( is. 0 ) ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( is. 0 ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_7.txt",
  "assertion": "assertTrue ( value. value ( Double. 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( Double. 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_8.txt",
  "assertion": "assertTrue ( value. value ( \". 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \". 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "21_9.txt",
  "assertion": "assertTrue ( value. value ( \"\". 0\" ) )\r\n",
  "test": "class X {public void testEvaluateFloat ( ) { MethodExpression methodExpression \u003d new MethodExpression ( new Abs ( null ) , \"evaluate\" , new IExpression [ ] { new ConstExpression ( ( - 1.0F ) ) } ) ; Float value \u003d ( ( Float ) ( methodExpression . evaluate ( new TupleEvent ( ) ) ) ) ; assertTrue ( value. value ( \"\". 0\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( ( this ) \u003d\u003d obj ) { return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } Pair other \u003d ( ( Pair ) ( obj ) ) ; return ( ( first ) \u003d\u003d null ? ( other . first ) \u003d\u003d null : first . first . equals ( ) ) \u0026\u0026 ( ( second ) \u003d\u003d null ? ( other . second ) \u003d\u003d null : second . second . equals ( ) ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_0.txt",
  "assertion": "assertNotNull ( result )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( result ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "22_1.txt",
  "assertion": "assertNotNull ( context )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( context ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_10.txt",
  "assertion": "assertNotNull ( exception )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( exception ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_11.txt",
  "assertion": "assertNotNull ( return )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( return ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_12.txt",
  "assertion": "assertNotNull ( effect )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( effect ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_13.txt",
  "assertion": "assertNotNull ( intersection )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( intersection ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_14.txt",
  "assertion": "assertNotNull ( eclipse )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( eclipse ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_15.txt",
  "assertion": "assertNotNull ( target )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( target ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_16.txt",
  "assertion": "assertNotNull ( results )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( results ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_17.txt",
  "assertion": "assertNotNull ( expected )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_18.txt",
  "assertion": "assertNotNull ( correlation )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( correlation ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_19.txt",
  "assertion": "assertNotNull ( null )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_2.txt",
  "assertion": "assertNotNull (result )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull (result ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "22_20.txt",
  "assertion": "assertNotNull ( filter )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( filter ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_21.txt",
  "assertion": "assertNotNull ( expression )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( expression ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_22.txt",
  "assertion": "assertNotNull ( output )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( output ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_23.txt",
  "assertion": "assertNotNull ( project )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( project ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_24.txt",
  "assertion": "assertNotNull ( match )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( match ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_25.txt",
  "assertion": "assertNotNull ( support )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( support ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_26.txt",
  "assertion": "assertNotNull ( root )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( root ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_27.txt",
  "assertion": "assertNotNull ( value )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( value ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_28.txt",
  "assertion": "assertNotNull ( consequence )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( consequence ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_29.txt",
  "assertion": "assertNotNull ( product )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( product ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_3.txt",
  "assertion": "assertNotNull (Result )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull (Result ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_4.txt",
  "assertion": "assertNotNull ( future )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( future ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_5.txt",
  "assertion": "assertNotNull ( cause )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( cause ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_6.txt",
  "assertion": "assertNotNull ( instance )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( instance ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_7.txt",
  "assertion": "assertNotNull ( Result )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( Result ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_8.txt",
  "assertion": "assertNotNull ( answer )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( answer ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_9.txt",
  "assertion": "assertNotNull ( brace )\r\n",
  "test": "class X {public void effectiveAugmentFirstTest ( ) { final SchemaContext result \u003d RFC7950Reactors . defaultReactor ( ) . RFC7950Reactors . newBuild ( ) . RFC7950Reactors . addSources ( ) . RFC7950Reactors . buildEffective ( ) ; assertNotNull ( brace ) ; }  }\r\n",
  "focal method": "class Y{ public void buildEffective() { return root . buildEffective ( ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "23_0.txt",
  "assertion": "assertEquals ( time, date. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, date. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_1.txt",
  "assertion": "assertEquals ( time, 0. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, 0. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_10.txt",
  "assertion": "assertEquals ( modified, 0. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, 0. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_11.txt",
  "assertion": "assertEquals ( time, null. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, null. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_12.txt",
  "assertion": "assertEquals ( 0, 0. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, 0. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_13.txt",
  "assertion": "assertEquals ( 1, date. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 1, date. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_14.txt",
  "assertion": "assertEquals ( date, date. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, date. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_15.txt",
  "assertion": "assertEquals ( modified, date. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, date. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_16.txt",
  "assertion": "assertEquals ( date, date. modified modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, date. modified modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_17.txt",
  "assertion": "assertEquals ( modified, date. modified modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, date. modified modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_18.txt",
  "assertion": "assertEquals ( 1, 0. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 1, 0. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_19.txt",
  "assertion": "assertEquals ( 0, date. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, date. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_2.txt",
  "assertion": "assertEquals ( time, date. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, date. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_20.txt",
  "assertion": "assertEquals ( date, 0. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, 0. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_21.txt",
  "assertion": "assertEquals ( modified, 0. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, 0. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_22.txt",
  "assertion": "assertEquals ( 0, date. modified modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, date. modified modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_23.txt",
  "assertion": "assertEquals ( date, 0. modified modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, 0. modified modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_24.txt",
  "assertion": "assertEquals ( true, date. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( true, date. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_25.txt",
  "assertion": "assertEquals ( modified, 0. modified modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, 0. modified modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_26.txt",
  "assertion": "assertEquals ( time, annotation. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, annotation. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_27.txt",
  "assertion": "assertEquals ( null, date. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( null, date. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_28.txt",
  "assertion": "assertEquals ( date, null. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, null. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_29.txt",
  "assertion": "assertEquals ( time, null. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, null. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_3.txt",
  "assertion": "assertEquals ( date, date. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, date. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_4.txt",
  "assertion": "assertEquals ( time, date. modified modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, date. modified modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_5.txt",
  "assertion": "assertEquals ( modified, date. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( modified, date. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_6.txt",
  "assertion": "assertEquals ( time, 0. date modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, 0. date modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_7.txt",
  "assertion": "assertEquals ( 0, date. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( 0, date. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_8.txt",
  "assertion": "assertEquals ( date, 0. time modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( date, 0. time modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_9.txt",
  "assertion": "assertEquals ( time, 0. modified modified modified ( ) )\r\n",
  "test": "class X {public void testSetModified3 ( ) { String time \u003d LocalDateTime . now ( ) . LocalDateTime . toString ( ) ; if ( time . contains ( \".\" ) ) { time \u003d ( time . substring ( 0 , time . indexOf ( \u0027.\u0027 ) ) ) + \"Z\" ; } else { time +\u003d \"Z\" ; } out . println ( time ) ; Annotation annotation \u003d anno4j . createObject ( Annotation . class ) ; annotation . setModified ( time ) ; Annotation result \u003d anno4j . findByID ( Annotation . class , annotation . getResourceAsString ( ) ) ; assertEquals ( time, 0. modified modified modified ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getModified() { return this . modified ; } }\r\n",
  "truth": "assertEquals ( time, result. getModified ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_0.txt",
  "assertion": "assertNull ( operations data (ors. createOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_1.txt",
  "assertion": "assertNull ( operations data (ors. concOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_10.txt",
  "assertion": "assertNull ( operations data (ors. compOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. compOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_11.txt",
  "assertion": "assertNull ( operations data (ors. toOperation ( types ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. toOperation ( types ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_12.txt",
  "assertion": "assertNull ( operations data (ors. createOperation ( transports ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( transports ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_13.txt",
  "assertion": "assertNull ( operations data (ors. compareOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. compareOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_14.txt",
  "assertion": "assertNull ( operations data (ors. toOperation ( connections ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. toOperation ( connections ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_15.txt",
  "assertion": "assertNull ( operations data (ors. create request ( types ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. create request ( types ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_16.txt",
  "assertion": "assertNull ( operations data (ors. createOperation ( races ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( races ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_17.txt",
  "assertion": "assertNull ( operations data (ors. newOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. newOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_18.txt",
  "assertion": "assertNull ( operations data (ors. to request ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. to request ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_19.txt",
  "assertion": "assertNull ( operations data (ors. CompOperation ( types ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. CompOperation ( types ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_2.txt",
  "assertion": "assertNull ( operations data (ors. createOperation ( types ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( types ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_20.txt",
  "assertion": "assertNull ( operations data.ors. createOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data.ors. createOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_21.txt",
  "assertion": "assertNull ( operations data (ors. create request ( connections ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. create request ( connections ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_22.txt",
  "assertion": "assertNull ( operations data (ors. concOperation ( transports ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( transports ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_23.txt",
  "assertion": "assertNull ( operations data (ors. CompOperation ( connections ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. CompOperation ( connections ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_24.txt",
  "assertion": "assertNull ( operations data (ors. conc request ( types ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. conc request ( types ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_25.txt",
  "assertion": "assertNull ( operations data (ors. Comp request ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. Comp request ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_26.txt",
  "assertion": "assertNull ( operations data (ors. concOperation ( races ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( races ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_27.txt",
  "assertion": "assertNull ( operations data (ors. compOperation ( types ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. compOperation ( types ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_28.txt",
  "assertion": "assertNull ( operations data.ors. concOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data.ors. concOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_29.txt",
  "assertion": "assertNull ( operations data (ors. conc request ( connections ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. conc request ( connections ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_3.txt",
  "assertion": "assertNull ( operations data (ors. toOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. toOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_4.txt",
  "assertion": "assertNull ( operations data (ors. createOperation ( connections ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. createOperation ( connections ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_5.txt",
  "assertion": "assertNull ( operations data (ors. create request ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. create request ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_6.txt",
  "assertion": "assertNull ( operations data (ors. concOperation ( types ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( types ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_7.txt",
  "assertion": "assertNull ( operations data (ors. CompOperation ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. CompOperation ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_8.txt",
  "assertion": "assertNull ( operations data (ors. concOperation ( connections ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. concOperation ( connections ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_9.txt",
  "assertion": "assertNull ( operations data (ors. conc request ( messages ) )\r\n",
  "test": "class X {public void testUpRequestCreationWithUnknownType ( ) { KaaClientState state \u003d Mockito . mock ( KaaClientState . class ) ; DefaultOperationDataProcessor operationsDataProcessor \u003d new DefaultOperationDataProcessor ( state ) ; Map \u003c TransportType , ChannelDirection \u003e types \u003d new HashMap ( ) ; types . BOOTSTRAP . put ( ) ; assertNull ( operations data (ors. conc request ( messages ) ) ; }  }\r\n",
  "focal method": "class Y{ public void compileRequest( Map  var24678 ) { if ( ( transport ) !\u003d null ) { SyncRequest request \u003d transport . createResolveRequest ( ) ; LOG . trace ( \"Created\u003csp\u003eResolve\u003csp\u003erequest\u003csp\u003e{}\" , request ) ; return requestConverter . toByteArray ( request ) ; } return null ; } }\r\n",
  "truth": "assertNull ( operationsDataProcessor. compileRequest ( types ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_0.txt",
  "assertion": "assertEquals ( 0, 0s. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0s. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_1.txt",
  "assertion": "assertEquals ( 0, 0ools. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ools. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_10.txt",
  "assertion": "assertEquals ( 0, 0\u0027s. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0\u0027s. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_11.txt",
  "assertion": "assertEquals ( 0, 0Map. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0Map. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_12.txt",
  "assertion": "assertEquals ( 0, 0irs. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0irs. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_13.txt",
  "assertion": "assertEquals ( 0, 0ows. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ows. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_14.txt",
  "assertion": "assertEquals ( 0, 0S. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0S. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_15.txt",
  "assertion": "assertEquals ( 0, 0s. 1 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0s. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_16.txt",
  "assertion": "assertEquals ( 1, 0s. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 1, 0s. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_17.txt",
  "assertion": "assertEquals ( 0, 1s. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 1s. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_18.txt",
  "assertion": "assertEquals ( 0, 0ms. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ms. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_19.txt",
  "assertion": "assertEquals ( 0, 0ocks. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ocks. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_2.txt",
  "assertion": "assertEquals ( 0, 0ors. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ors. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_20.txt",
  "assertion": "assertEquals ( 0, 0ols. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ols. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_21.txt",
  "assertion": "assertEquals ( 0, 0ools. 1 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ools. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_22.txt",
  "assertion": "assertEquals ( 1, 0ools. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 1, 0ools. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_23.txt",
  "assertion": "assertEquals ( 0, 1ools. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 1ools. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_24.txt",
  "assertion": "assertEquals ( 0, 0In. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0In. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_25.txt",
  "assertion": "assertEquals ( 0, 0ds. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ds. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_26.txt",
  "assertion": "assertEquals ( 2, 0s. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 2, 0s. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_27.txt",
  "assertion": "assertEquals ( 0, 0ors. 1 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0ors. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_28.txt",
  "assertion": "assertEquals ( 1, 0ors. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 1, 0ors. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_29.txt",
  "assertion": "assertEquals ( 0, 1ors. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 1ors. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_3.txt",
  "assertion": "assertEquals ( 0, 0o. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0o. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_4.txt",
  "assertion": "assertEquals ( 0, 0l. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0l. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_5.txt",
  "assertion": "assertEquals ( 0, 0os. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0os. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_6.txt",
  "assertion": "assertEquals ( 0, 0m. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0m. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_7.txt",
  "assertion": "assertEquals ( 0, 0d. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0d. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_8.txt",
  "assertion": "assertEquals ( 0, 0i. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0i. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_9.txt",
  "assertion": "assertEquals ( 0, 0g. 0 ( ) )\r\n",
  "test": "class X {public void testGetAllExecutablesForInterfaces ( ) { Launcher spoon \u003d new Launcher ( ) ; spoon . setArgs ( new String [ ] { \"--output-type\" , \"nooutput\" } ) ; Factory factory \u003d spoon . createFactory ( ) ; spoon . SpoonResourceHelper . createCompiler ( factory , SpoonResourceHelper . resources ( \"./src/test/java/spoon/test/reference/Foo.java\" ) ) . SpoonResourceHelper . build ( ) ; CtInterface \u003c Foo \u003e foo \u003d factory . Package ( ) . get ( \"spoon.test.reference\" ) . getType ( \"Foo\" ) ; Collection \u003c CtExecutableReference \u003c ? \u003e \u003e execs \u003d foo . getReference ( ) . getAllExecutables ( ) ; assertEquals ( 0, 0g. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_0.txt",
  "assertion": "assertTrue ( process process finished ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process process finished ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_1.txt",
  "assertion": "assertTrue ( process process died ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process process died ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_10.txt",
  "assertion": "assertTrue ( processprocess finished ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( processprocess finished ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_11.txt",
  "assertion": "assertTrue (process process finished ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue (process process finished ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_12.txt",
  "assertion": "assertTrue ( Process process finished ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( Process process finished ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_13.txt",
  "assertion": "assertTrue ( process processailed ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processailed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_14.txt",
  "assertion": "assertTrue ( process processED ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processED ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_15.txt",
  "assertion": "assertTrue ( process processEnd ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processEnd ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_16.txt",
  "assertion": "assertTrue ( process processopped ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processopped ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_17.txt",
  "assertion": "assertTrue ( process processired ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processired ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_18.txt",
  "assertion": "assertTrue ( process processied ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processied ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_19.txt",
  "assertion": "assertTrue ( process processDone ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processDone ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_2.txt",
  "assertion": "assertTrue ( process process ended ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process process ended ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_20.txt",
  "assertion": "assertTrue ( process processged ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processged ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_21.txt",
  "assertion": "assertTrue ( processes process finished ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( processes process finished ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_22.txt",
  "assertion": "assertTrue ( process processshed ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processshed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_23.txt",
  "assertion": "assertTrue ( process processined ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processined ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_24.txt",
  "assertion": "assertTrue ( process processowed ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processowed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_25.txt",
  "assertion": "assertTrue ( process processted ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processted ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_26.txt",
  "assertion": "assertTrue ( process processaned ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processaned ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_27.txt",
  "assertion": "assertTrue ( processprocess died ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( processprocess died ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_28.txt",
  "assertion": "assertTrue (process process died ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue (process process died ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_29.txt",
  "assertion": "assertTrue ( processing process finished ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( processing process finished ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_3.txt",
  "assertion": "assertTrue ( process processized ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processized ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_4.txt",
  "assertion": "assertTrue ( process processd ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processd ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_5.txt",
  "assertion": "assertTrue ( process process ed ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process process ed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_6.txt",
  "assertion": "assertTrue ( process processs ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processs ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_7.txt",
  "assertion": "assertTrue ( process processed ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_8.txt",
  "assertion": "assertTrue ( process processosed ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processosed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_9.txt",
  "assertion": "assertTrue ( process processended ( ) )\r\n",
  "test": "class X {public void badFlow ( ) { final String aNummer \u003d \"1607306140\" ; final String doelPartijCode \u003d \"0599\" ; final String bulkSynchronisatievraag \u003d ( ( doelPartijCode + \",\" ) + aNummer ) + \",testtekst\\n\" ; final Uc812Bericht uc812Bericht \u003d new Uc812Bericht ( ) ; uc812Bericht . setBulkSynchronisatievraag ( bulkSynchronisatievraag ) ; startProcess ( uc812Bericht ) ; signalHumanTask ( \"end\" ) ; assertTrue ( process processended ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void processEnded() { final JbpmContext jbpmContext \u003d JbpmConfiguration . getInstance ( ) . JbpmConfiguration . createJbpmContext ( ) ; try { final ProcessInstance processInstance \u003d jbpmContext . loadProcessInstance ( processInstanceId ) ; return processInstance . hasEnded ( ) ; } finally { jbpmContext . close ( ) ; } } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_0.txt",
  "assertion": "assertNull ( queue. removeue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_1.txt",
  "assertion": "assertNull ( queue. removeQueue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_10.txt",
  "assertion": "assertNull ( queue. removeue ( de Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( de Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_11.txt",
  "assertion": "assertNull ( queue. deue ( remove Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( remove Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_12.txt",
  "assertion": "assertNull ( queue. removeQueue ( connection Context ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( connection Context ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_13.txt",
  "assertion": "assertNull ( queue. relue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. relue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_14.txt",
  "assertion": "assertNull ( queue. deleteue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deleteue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_15.txt",
  "assertion": "assertNull ( queue. deQueue ( remove Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( remove Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_16.txt",
  "assertion": "assertNull ( queue. removeQueue ( de Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( de Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_17.txt",
  "assertion": "assertNull ( queue. deue ( null Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( null Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_18.txt",
  "assertion": "assertNull ( queue. relQueue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. relQueue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_19.txt",
  "assertion": "assertNull ( queue. deleteQueue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deleteQueue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_2.txt",
  "assertion": "assertNull ( queue. deue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_20.txt",
  "assertion": "assertNull ( queue. removeque ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeque ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_21.txt",
  "assertion": "assertNull ( queue. processue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. processue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_22.txt",
  "assertion": "assertNull ( queue. deQueue ( null Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( null Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_23.txt",
  "assertion": "assertNull ( queue. deue ( connection Context ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( connection Context ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_24.txt",
  "assertion": "assertNull ( queue. downue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. downue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_25.txt",
  "assertion": "assertNull ( queue. processQueue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. processQueue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_26.txt",
  "assertion": "assertNull ( queue. de ( ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. de ( ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_27.txt",
  "assertion": "assertNull ( queue. deue ( de Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deue ( de Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_28.txt",
  "assertion": "assertNull ( pool. removeue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( pool. removeue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_29.txt",
  "assertion": "assertNull ( queue. deQueue ( connection Context ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( connection Context ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_3.txt",
  "assertion": "assertNull ( queue. deQueue ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. deQueue ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_4.txt",
  "assertion": "assertNull ( queue. removeue ( remove Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( remove Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_5.txt",
  "assertion": "assertNull ( queue. removeQueue ( remove Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( remove Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_6.txt",
  "assertion": "assertNull ( queue. removeue ( null Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( null Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_7.txt",
  "assertion": "assertNull ( queue. removeQueue ( null Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeQueue ( null Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_8.txt",
  "assertion": "assertNull ( queue. removeue ( connection Context ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. removeue ( connection Context ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_9.txt",
  "assertion": "assertNull ( queue. remove ( ( connection Object ( ) ) )\r\n",
  "test": "class X {public void testDequeueReturnsNullWhenNotEnqueued ( ) { queue . enqueue ( new Object ( ) ) ; assertNull ( queue. remove ( ( connection Object ( ) ) ) ; }  }\r\n",
  "focal method": "class Y{ public void dequeue( Object  var24678 ) { Object found \u003d null ; synchronized ( mutex ) { found \u003d find ( obj ) ; if ( found !\u003d null ) { queueData . remove ( found ) ; } } return found ; } }\r\n",
  "truth": "assertNull ( queue. dequeue ( new Object ( ) ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_0.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_1.txt",
  "assertion": "assertEquals ( 0, 0ation. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_10.txt",
  "assertion": "assertEquals ( 0, 0Failure. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Failure. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_11.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 eventsFound ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsFound ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_12.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 eventsEvents ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsEvents ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_13.txt",
  "assertion": "assertEquals ( 0, 0Event. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Event. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_14.txt",
  "assertion": "assertEquals ( 0, 0ation. 0 eventsCount ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 eventsCount ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_15.txt",
  "assertion": "assertEquals ( 0, 0n. 0 eventsCount ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0n. 0 eventsCount ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_16.txt",
  "assertion": "assertEquals ( 0, 0 metrics. 0 eventsCount ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 metrics. 0 eventsCount ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_17.txt",
  "assertion": "assertEquals ( 1, 0 validation. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 1, 0 validation. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_18.txt",
  "assertion": "assertEquals ( 0, 1 validation. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 1 validation. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_19.txt",
  "assertion": "assertEquals ( 0, 0ation. 0 eventsed ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 eventsed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_2.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 eventsCount ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsCount ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_20.txt",
  "assertion": "assertEquals ( 0, 0f. 0 eventsCount ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0f. 0 eventsCount ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_21.txt",
  "assertion": "assertEquals ( 0, 0Error. 0 eventsCount ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Error. 0 eventsCount ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_22.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 eventsError ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsError ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_23.txt",
  "assertion": "assertEquals ( 0, 0n. 0 eventsed ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0n. 0 eventsed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_24.txt",
  "assertion": "assertEquals ( 0, 0 metrics. 0 eventsed ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 metrics. 0 eventsed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_25.txt",
  "assertion": "assertEquals ( 0, 0ation. 0 Events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0ation. 0 Events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_26.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 EventsCount ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 EventsCount ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_27.txt",
  "assertion": "assertEquals ( 0, 0f. 0 eventsed ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0f. 0 eventsed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_28.txt",
  "assertion": "assertEquals ( 0, 0Error. 0 eventsed ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Error. 0 eventsed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_29.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0Events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0Events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_3.txt",
  "assertion": "assertEquals ( 0, 0n. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0n. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_4.txt",
  "assertion": "assertEquals ( 0, 0 metrics. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 metrics. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_5.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 eventsed ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 eventsed ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_6.txt",
  "assertion": "assertEquals ( 0, 0f. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0f. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_7.txt",
  "assertion": "assertEquals ( 0, 0Error. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0Error. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_8.txt",
  "assertion": "assertEquals ( 0, 0 validation. 0 Events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0 validation. 0 Events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_9.txt",
  "assertion": "assertEquals ( 0, 0x. 0 events size ( ) )\r\n",
  "test": "class X {public void testNullOAuthFlowObject ( ) { OAuthFlowValidator validator \u003d OAuthFlowValidator . getInstance ( ) ; TestValidationHelper vh \u003d new TestValidationHelper ( ) ; OAuthFlowImpl oauthflow \u003d null ; validator . validate ( vh , context , oauthflow ) ; assertEquals ( 0, 0x. 0 events size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getEventsSize() { return result . getEvents ( ) . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_0.txt",
  "assertion": "assertEquals ( parsed )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( parsed ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_1.txt",
  "assertion": "assertEquals ( 0 )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_10.txt",
  "assertion": "assertEquals ( null )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_11.txt",
  "assertion": "assertEquals ( parse )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( parse ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_12.txt",
  "assertion": "assertEquals ( 6 )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 6 ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_13.txt",
  "assertion": "assertEquals ( detected )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( detected ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_14.txt",
  "assertion": "assertEquals ( mounted )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( mounted ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_15.txt",
  "assertion": "assertEquals ( declared )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( declared ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_16.txt",
  "assertion": "assertEquals ( formatted )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( formatted ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_17.txt",
  "assertion": "assertEquals ( passed )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( passed ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_18.txt",
  "assertion": "assertEquals ( texted )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( texted ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_19.txt",
  "assertion": "assertEquals ( resolved )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( resolved ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_2.txt",
  "assertion": "assertEquals ( 1 )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_20.txt",
  "assertion": "assertEquals ( chopped )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( chopped ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_21.txt",
  "assertion": "assertEquals ( split )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( split ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_22.txt",
  "assertion": "assertEquals ( spoken )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( spoken ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_23.txt",
  "assertion": "assertEquals ( interpreted )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( interpreted ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_24.txt",
  "assertion": "assertEquals ( used )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( used ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_25.txt",
  "assertion": "assertEquals ( looked )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( looked ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_26.txt",
  "assertion": "assertEquals ( rooted )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( rooted ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_27.txt",
  "assertion": "assertEquals ( listened )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( listened ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_28.txt",
  "assertion": "assertEquals (ed )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals (ed ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_29.txt",
  "assertion": "assertEquals ( read )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( read ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_3.txt",
  "assertion": "assertEquals ( 5 )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_4.txt",
  "assertion": "assertEquals ( expected )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( expected ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_5.txt",
  "assertion": "assertEquals ( 3 )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_6.txt",
  "assertion": "assertEquals ( recognized )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( recognized ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_7.txt",
  "assertion": "assertEquals ( parser )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( parser ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_8.txt",
  "assertion": "assertEquals ( sent )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( sent ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_9.txt",
  "assertion": "assertEquals ( 2 )\r\n",
  "test": "class X {public void errorMessageInHeader_TakesPrecedenceOverMessageInBody ( ) { responseBuilder . X_AMZN_ERROR_MESSAGE . putHeader ( ) ; SdkJsonNode jsonNode \u003d parseJson ( \"message\" , \"other\u003csp\u003emessage\u003csp\u003ein\u003csp\u003ebody\" ) ; String parsed \u003d parser . parseErrorMessage ( responseBuilder . build ( ) , jsonNode ) ; assertEquals ( 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { return new S3Utilities ( this ) ; } }\r\n",
  "truth": "assertEquals ( parsed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_0.txt",
  "assertion": "assertNull ( doc. image images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. image images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_1.txt",
  "assertion": "assertNull ( doc. is images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. is images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_10.txt",
  "assertion": "assertNull ( doc. source images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. source images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_11.txt",
  "assertion": "assertNull ( doc. new images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. new images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "2_12.txt",
  "assertion": "assertNull ( doc. [ images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. [ images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_13.txt",
  "assertion": "assertNull ( doc. open images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. open images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_14.txt",
  "assertion": "assertNull ( doc. : images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. : images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_15.txt",
  "assertion": "assertNull ( doc. public images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. public images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_16.txt",
  "assertion": "assertNull ( doc. imageMedia ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. imageMedia ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_17.txt",
  "assertion": "assertNull ( doc. download images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. download images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_18.txt",
  "assertion": "assertNull ( doc. available images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. available images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_19.txt",
  "assertion": "assertNull ( doc. -\u003e images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. -\u003e images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_2.txt",
  "assertion": "assertNull ( doc. get images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. get images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_20.txt",
  "assertion": "assertNull ( doc. create images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. create images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_21.txt",
  "assertion": "assertNull ( doc. isMedia ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. isMedia ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_22.txt",
  "assertion": "assertNull ( doc. export images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. export images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_23.txt",
  "assertion": "assertNull ( doc. imageImage ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. imageImage ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_24.txt",
  "assertion": "assertNull ( doc. getMedia ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. getMedia ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_25.txt",
  "assertion": "assertNull ( doc. allMedia ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. allMedia ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_26.txt",
  "assertion": "assertNull ( doc. gMedia ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. gMedia ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_27.txt",
  "assertion": "assertNull ( doc. addMedia ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. addMedia ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_28.txt",
  "assertion": "assertNull ( doc. toMedia ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. toMedia ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_29.txt",
  "assertion": "assertNull ( doc. find images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. find images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_3.txt",
  "assertion": "assertNull ( doc. all images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. all images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_4.txt",
  "assertion": "assertNull ( doc. g images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. g images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_5.txt",
  "assertion": "assertNull ( doc. add images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. add images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_6.txt",
  "assertion": "assertNull ( doc. to images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. to images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_7.txt",
  "assertion": "assertNull ( doc. int images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. int images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_8.txt",
  "assertion": "assertNull ( doc. has images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. has images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_9.txt",
  "assertion": "assertNull ( doc. i images ( ) )\r\n",
  "test": "class X {public void testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { AnnotatedDocument doc \u003d apiUrl . annotateDocument ( ) ; assertNull ( doc. i images ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getImages() { return this . images ; } }\r\n",
  "truth": "assertNull ( doc. getImages ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "30_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_1.txt",
  "assertion": "assertEquals ( expect, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expect, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_10.txt",
  "assertion": "assertEquals ( expected, 0 )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_11.txt",
  "assertion": "assertEquals ( content, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( content, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_12.txt",
  "assertion": "assertEquals ( expected, content )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, content ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_13.txt",
  "assertion": "assertEquals ( null, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( null, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_14.txt",
  "assertion": "assertEquals ( expected, null )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, null ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_15.txt",
  "assertion": "assertEquals (expected, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals (expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_16.txt",
  "assertion": "assertEquals ( unexpected, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( unexpected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_17.txt",
  "assertion": "assertEquals ( assumed, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( assumed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_18.txt",
  "assertion": "assertEquals ( email, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( email, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_19.txt",
  "assertion": "assertEquals ( expectations, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expectations, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_2.txt",
  "assertion": "assertEquals ( expected, expect )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, expect ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_20.txt",
  "assertion": "assertEquals ( found, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( found, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_21.txt",
  "assertion": "assertEquals ( expected, found )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, found ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_22.txt",
  "assertion": "assertEquals ( 200, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( 200, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_23.txt",
  "assertion": "assertEquals ( expects, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expects, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_24.txt",
  "assertion": "assertEquals ( sent, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( sent, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_25.txt",
  "assertion": "assertEquals ( observed, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( observed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_26.txt",
  "assertion": "assertEquals ( 10, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( 10, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_27.txt",
  "assertion": "assertEquals ( expected, 10 )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_28.txt",
  "assertion": "assertEquals ( supposed, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( supposed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_29.txt",
  "assertion": "assertEquals ( detected, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( detected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_3.txt",
  "assertion": "assertEquals ( expected, actual )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, actual ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "actual",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "30_4.txt",
  "assertion": "assertEquals ( actual, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( actual, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "30_5.txt",
  "assertion": "assertEquals ( expecting, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expecting, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_6.txt",
  "assertion": "assertEquals ( expected, expecting )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expected, expecting ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_7.txt",
  "assertion": "assertEquals ( expectation, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( expectation, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_8.txt",
  "assertion": "assertEquals (pected, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals (pected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "30_9.txt",
  "assertion": "assertEquals ( 0, expected )\r\n",
  "test": "class X {public void testRender ( ) { String templateVariable \u003d \"Hello\u003csp\u003eRocker!\" ; String expected \u003d String . format ( \"\u003ch1\u003e%s\u003c/h1\u003e\\n\" , templateVariable ) ; String actual \u003d new RockerTransformer ( ) . hello . render ( hello . template ( templateVariable ) ) ; assertEquals ( 0, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void render( ModelAndView  var24678 ) { return Locale . render ( modelAndView , Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_0.txt",
  "assertion": "assertEquals ( ret, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_1.txt",
  "assertion": "assertEquals ( 1, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 1, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "31_10.txt",
  "assertion": "assertEquals ( ret, rc )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, rc ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_11.txt",
  "assertion": "assertEquals ( true, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( true, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_12.txt",
  "assertion": "assertEquals ( ret, true )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, true ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_13.txt",
  "assertion": "assertEquals ( 1, 1 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 1, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_14.txt",
  "assertion": "assertEquals ( exit, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( exit, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_15.txt",
  "assertion": "assertEquals ( ret, exit )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, exit ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_16.txt",
  "assertion": "assertEquals ( 10, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 10, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_17.txt",
  "assertion": "assertEquals ( ret, 10 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_18.txt",
  "assertion": "assertEquals ( Ret, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( Ret, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_19.txt",
  "assertion": "assertEquals ( ret, Ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, Ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_2.txt",
  "assertion": "assertEquals ( ret, 1 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "31_20.txt",
  "assertion": "assertEquals (ret, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals (ret, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_21.txt",
  "assertion": "assertEquals ( ret,ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret,ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_22.txt",
  "assertion": "assertEquals ( return, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( return, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "31_23.txt",
  "assertion": "assertEquals ( ret, return )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, return ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "31_24.txt",
  "assertion": "assertEquals ( 1, 0 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 1, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_25.txt",
  "assertion": "assertEquals ( 0, 1 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 0, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_26.txt",
  "assertion": "assertEquals ( RET, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( RET, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_27.txt",
  "assertion": "assertEquals ( ret, RET )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, RET ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_28.txt",
  "assertion": "assertEquals ( success, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( success, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_29.txt",
  "assertion": "assertEquals ( ret, success )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, success ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_3.txt",
  "assertion": "assertEquals ( 0, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 0, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_4.txt",
  "assertion": "assertEquals ( ret, 0 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_5.txt",
  "assertion": "assertEquals ( 2, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 2, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_6.txt",
  "assertion": "assertEquals ( ret, 2 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_7.txt",
  "assertion": "assertEquals ( 3, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( 3, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_8.txt",
  "assertion": "assertEquals ( ret, 3 )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( ret, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "31_9.txt",
  "assertion": "assertEquals ( rc, ret )\r\n",
  "test": "class X {public void testPathIsFileWhenPathIsDirectory ( ) { mFileSystem . createDirectory ( new AlluxioURI ( \"/testDir\" ) ) ; int ret \u003d mFsShell . run ( \"test\" , \"-f\" , \"/testDir\" ) ; assertEquals ( rc, ret ) ; }  }\r\n",
  "focal method": "class Y{ public void run( JobConfig  var24678 , int  var24678 , AlluxioConfiguration  var24678 ) { CountingRetry retryPolicy \u003d new CountingRetry ( attempts ) ; while ( retryPolicy . attempt ( ) ) { long jobId ; try ( JobMasterClient client \u003d Factory . create ( JobMasterClientContext . newBuilder ( ClientContext . create ( alluxioConf ) ) . JobMasterClientContext . build ( ) ) ) { jobId \u003d client . run ( config ) ; } catch ( Exception e ) { LOG . warn ( \"Exception\u003csp\u003eencountered\u003csp\u003ewhen\u003csp\u003estarting\u003csp\u003ea\u003csp\u003ejob.\" , e ) ; continue ; } JobInfo jobInfo \u003d JobGrpcClientUtils . waitFor ( jobId , alluxioConf ) ; if ( jobInfo \u003d\u003d null ) { break ; } if ( ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . COMPLETED ) ) || ( ( jobInfo . getStatus ( ) ) \u003d\u003d ( alluxio . job . wire . Status . CANCELED ) ) ) { return ; } LOG . warn ( \"Job\u003csp\u003e{}\u003csp\u003efailed\u003csp\u003eto\u003csp\u003ecomplete:\u003csp\u003e{}\" , jobId , jobInfo . getErrorMessage ( ) ) ; } throw new RuntimeException ( \"Failed\u003csp\u003eto\u003csp\u003esuccessfully\u003csp\u003ecomplete\u003csp\u003ethe\u003csp\u003ejob.\" ) ; } }\r\n",
  "truth": "assertEquals ( 1, ret )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "ret",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "32_0.txt",
  "assertion": "assertEquals ( v. dense ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. dense ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_1.txt",
  "assertion": "assertEquals ( v. + ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. + ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "32_10.txt",
  "assertion": "assertEquals ( v. dense ( v ), m )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. dense ( v ), m ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "m",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_11.txt",
  "assertion": "assertEquals ( v. dense ( m ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. dense ( m ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_12.txt",
  "assertion": "assertEquals ( v. + ( v ), m )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. + ( v ), m ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "32_13.txt",
  "assertion": "assertEquals ( v. + ( m ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. + ( m ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "32_14.txt",
  "assertion": "assertEquals ( m. + ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( m. + ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "32_15.txt",
  "assertion": "assertEquals ( v. row ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. row ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_16.txt",
  "assertion": "assertEquals ( v. add ( v ), m )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. add ( v ), m ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "m",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_17.txt",
  "assertion": "assertEquals ( m. add ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( m. add ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_18.txt",
  "assertion": "assertEquals ( v. add ( m ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. add ( m ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_19.txt",
  "assertion": "assertEquals ( v. columns ( v ), m )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. columns ( v ), m ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "m",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_2.txt",
  "assertion": "assertEquals ( v. add ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. add ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_20.txt",
  "assertion": "assertEquals ( m. columns ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( m. columns ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_21.txt",
  "assertion": "assertEquals ( v. columns ( m ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. columns ( m ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_22.txt",
  "assertion": "assertEquals ( v. multiply ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. multiply ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_23.txt",
  "assertion": "assertEquals ( v. plus ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. plus ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "plus",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_24.txt",
  "assertion": "assertEquals ( v. exp ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. exp ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_25.txt",
  "assertion": "assertEquals ( v. get ( v ), m )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. get ( v ), m ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "m",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_26.txt",
  "assertion": "assertEquals ( m. get ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( m. get ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_27.txt",
  "assertion": "assertEquals ( v. get ( m ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. get ( m ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_28.txt",
  "assertion": "assertEquals ( v. create ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. create ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_29.txt",
  "assertion": "assertEquals ( u. dense ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( u. dense ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_3.txt",
  "assertion": "assertEquals ( v. columns ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. columns ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_4.txt",
  "assertion": "assertEquals ( v. get ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. get ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_5.txt",
  "assertion": "assertEquals ( v. sum ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. sum ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_6.txt",
  "assertion": "assertEquals ( v. rows ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. rows ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_7.txt",
  "assertion": "assertEquals ( v. mul ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. mul ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_8.txt",
  "assertion": "assertEquals ( v. column ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( v. column ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "32_9.txt",
  "assertion": "assertEquals ( m. dense ( v ), v )\r\n",
  "test": "class X {public void testSprSparseDense2 ( ) { double alpha \u003d 3.0 ; SparseVector v \u003d new SparseVector ( 2 ) ; v . set ( 0 , 1 ) ; DenseVector u \u003d new DenseVector ( new double [ ] { 3.0 , 13.0 , 20.0 , 0.0 } ) ; DenseMatrix m \u003d ( ( DenseMatrix ) ( new DenseMatrix ( new double [ ] [ ] { new double [ ] { 1.0 , 0.0 } , new double [ ] { 0.0 , 0.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) . COLUMN_STORAGE_MODE . times ( alpha ) ) ) ; DenseMatrix a \u003d new DenseMatrix ( new double [ ] [ ] { new double [ ] { 3.0 , 0.0 } , new double [ ] { 13.0 , 20.0 } } , StorageConstants . COLUMN_STORAGE_MODE ) ; Blas . spr ( alpha , v , u ) ; DenseMatrix mu \u003d BlasTest . fromVector ( u , a . rowSize ( ) , ( i , j ) -\u003e i \u003e\u003d j ) ; assertEquals ( m. dense ( v ), v ) ; }  }\r\n",
  "focal method": "class Y{ public void plus( NormalDistributionStatistics  var24678 ) { return new NormalDistributionStatistics ( Math . min ( ) , Math . max ( ) , ( ( this . sumOfSquares ) + ( stats . sumOfSquares ) ) , ( ( this . sumOfValues ) + ( stats . sumOfValues ) ) , ( ( this . n ) + ( stats . n ) ) ) ; } }\r\n",
  "truth": "assertEquals ( m. plus ( a ), mu )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "v",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "33_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_1.txt",
  "assertion": "assertEquals ( expect, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expect, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_10.txt",
  "assertion": "assertEquals (expected, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals (expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_11.txt",
  "assertion": "assertEquals ( expecting, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expecting, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_12.txt",
  "assertion": "assertEquals ( expected, expecting )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, expecting ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_13.txt",
  "assertion": "assertEquals ( 0, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( 0, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_14.txt",
  "assertion": "assertEquals ( expected, 0 )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_15.txt",
  "assertion": "assertEquals ( 10, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( 10, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_16.txt",
  "assertion": "assertEquals ( expected, 10 )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_17.txt",
  "assertion": "assertEquals ( unexpected, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( unexpected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_18.txt",
  "assertion": "assertEquals ( expected, unexpected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, unexpected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_19.txt",
  "assertion": "assertEquals ( assumed, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( assumed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_2.txt",
  "assertion": "assertEquals ( expected, expect )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, expect ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_20.txt",
  "assertion": "assertEquals ( expected, assumed )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, assumed ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_21.txt",
  "assertion": "assertEquals ( 8, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( 8, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_22.txt",
  "assertion": "assertEquals ( expectations, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expectations, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_23.txt",
  "assertion": "assertEquals ( exp, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( exp, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_24.txt",
  "assertion": "assertEquals ( expected, exp )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, exp ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_25.txt",
  "assertion": "assertEquals ( 123, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( 123, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_26.txt",
  "assertion": "assertEquals ( predicted, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( predicted, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_27.txt",
  "assertion": "assertEquals ( observed, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( observed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_28.txt",
  "assertion": "assertEquals ( expected, observed )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, observed ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_29.txt",
  "assertion": "assertEquals ( anticipated, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( anticipated, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_3.txt",
  "assertion": "assertEquals ( expected, actual )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, actual ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "actual",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "33_4.txt",
  "assertion": "assertEquals ( actual, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( actual, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "33_5.txt",
  "assertion": "assertEquals (pected, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals (pected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_6.txt",
  "assertion": "assertEquals ( null, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( null, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_7.txt",
  "assertion": "assertEquals ( expected, null )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, null ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_8.txt",
  "assertion": "assertEquals ( expectation, expected )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expectation, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "33_9.txt",
  "assertion": "assertEquals ( expected, expectation )\r\n",
  "test": "class X {public void testPaseNegativeInfinity ( ) { String source \u003d \"(-Infinity)\u003csp\u003e-\u003csp\u003e(Infinity)i\" ; Complex expected \u003d new Complex ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; Complex actual \u003d complexFormat . parse ( source ) ; assertEquals ( expected, expectation ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( AbstractCompiler  var24678 ) { try { logger_ . fine ( ( \"Parsing:\u003csp\u003e\" + ( sourceFile . getName ( ) ) ) ) ; ParseResult result \u003d ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , compiler . getDefaultErrorReporter ( ) ) ; root \u003d result . ast ; compiler . oldAst . setOldParseTree ( sourceFile . getName ( ) ) ; } catch ( IOException e ) { compiler . JSError . report ( JSError . make ( sourceFile . getName ( ) ) ) ; } if ( ( ( root ) \u003d\u003d null ) || ( compiler . hasHaltingErrors ( ) ) ) { root \u003d IR . script ( ) ; } else { compiler . prepareAst ( root ) ; } root . setStaticSourceFile ( sourceFile ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "34_0.txt",
  "assertion": "assertNotNull ( instance. all m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. all m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_1.txt",
  "assertion": "assertNotNull ( instance. start m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. start m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_10.txt",
  "assertion": "assertNotNull ( instance. get M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. get M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_11.txt",
  "assertion": "assertNotNull ( instance. to m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. to m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_12.txt",
  "assertion": "assertNotNull ( instance. g m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. g m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_13.txt",
  "assertion": "assertNotNull ( instance. __ m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. __ m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_14.txt",
  "assertion": "assertNotNull ( instance. m M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. m M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_15.txt",
  "assertion": "assertNotNull ( instance. my m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. my m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_16.txt",
  "assertion": "assertNotNull ( instance. to M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. to M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_17.txt",
  "assertion": "assertNotNull ( instance. g M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. g M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_18.txt",
  "assertion": "assertNotNull ( instance. check m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. check m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_19.txt",
  "assertion": "assertNotNull ( instance. all mM mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. all mM mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_2.txt",
  "assertion": "assertNotNull ( instance. is m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. is m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_20.txt",
  "assertion": "assertNotNull ( instance. start mM mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. start mM mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_21.txt",
  "assertion": "assertNotNull ( instance. __ M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. __ M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_22.txt",
  "assertion": "assertNotNull ( instance. is mM mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. is mM mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_23.txt",
  "assertion": "assertNotNull ( instance. my M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. my M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_24.txt",
  "assertion": "assertNotNull ( instance. e mM mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. e mM mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_25.txt",
  "assertion": "assertNotNull ( instance. cache m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. cache m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_26.txt",
  "assertion": "assertNotNull ( instance. pop m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. pop m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_27.txt",
  "assertion": "assertNotNull ( instance. current m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. current m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_28.txt",
  "assertion": "assertNotNull ( instance. find m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. find m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_29.txt",
  "assertion": "assertNotNull ( instance. check M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. check M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_3.txt",
  "assertion": "assertNotNull ( instance. e m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. e m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_4.txt",
  "assertion": "assertNotNull ( instance. all M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. all M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_5.txt",
  "assertion": "assertNotNull ( instance. get m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. get m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_6.txt",
  "assertion": "assertNotNull ( instance. start M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. start M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_7.txt",
  "assertion": "assertNotNull ( instance. is M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. is M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_8.txt",
  "assertion": "assertNotNull ( instance. e M mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. e M mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_9.txt",
  "assertion": "assertNotNull ( instance. m m mapping ( ) )\r\n",
  "test": "class X {public void testCalculateOverlapsAndReduceExactMatch ( ) { IChemObjectBuilder builder \u003d DefaultChemObjectBuilder . getInstance ( ) ; SmilesParser sp \u003d new SmilesParser ( builder ) ; IAtomContainer Molecule1 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; IAtomContainer Molecule2 \u003d sp . parseSmiles ( \"O1C\u003dCC\u003dC1\" ) ; CDKRMapHandler instance \u003d new CDKRMapHandler ( ) ; instance . calculateOverlapsAndReduceExactMatch ( Molecule1 , Molecule2 , true , false , false ) ; assertNotNull ( instance. m m mapping ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getMappings() { return mappings ; } }\r\n",
  "truth": "assertNotNull ( instance. getMappings ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_0.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_1.txt",
  "assertion": "assertEquals ( expected scroll, 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_10.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll Bar ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll Bar ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_11.txt",
  "assertion": "assertEquals ( expected scroll Bar 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll Bar 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_12.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll *0 )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll *0 ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_13.txt",
  "assertion": "assertEquals ( expected scroll_ 0, expected scroll * height )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll * height ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_14.txt",
  "assertion": "assertEquals ( expectedEl * 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedEl * 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_15.txt",
  "assertion": "assertEquals ( expected scroll bar 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll bar 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_16.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll bar ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll bar ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_17.txt",
  "assertion": "assertEquals ( expectedC * 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedC * 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_18.txt",
  "assertion": "assertEquals ( expected scroll * 0, expectedC * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expectedC * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_19.txt",
  "assertion": "assertEquals ( expected scroll, 0, expected scroll Bar ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll Bar ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_2.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll, ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_20.txt",
  "assertion": "assertEquals ( expected scroll Bar 0, expected scroll, ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll Bar 0, expected scroll, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_21.txt",
  "assertion": "assertEquals ( expected scroll, 0, expected scroll *0 )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll *0 ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_22.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll,0 )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll,0 ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_23.txt",
  "assertion": "assertEquals ( expected scroll_ 0, expected scroll, height )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll, height ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_24.txt",
  "assertion": "assertEquals ( expectedEl * 0, expected scroll, ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedEl * 0, expected scroll, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_25.txt",
  "assertion": "assertEquals ( expectedEl, 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expectedEl, 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_26.txt",
  "assertion": "assertEquals ( expected scroll, 0, expected scroll bar ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll bar ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_27.txt",
  "assertion": "assertEquals ( expected scroll bar 0, expected scroll, ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll bar 0, expected scroll, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_28.txt",
  "assertion": "assertEquals ( expected scroll * ), expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * ), expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_29.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll Bar height )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll Bar height ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_3.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll * height )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll * height ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_4.txt",
  "assertion": "assertEquals ( expected scroll, 0, expected scroll, ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_5.txt",
  "assertion": "assertEquals ( expected scroll_ 0, expected scroll * ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll * ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_6.txt",
  "assertion": "assertEquals ( expected scroll, 0, expected scroll * height )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll * height ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_7.txt",
  "assertion": "assertEquals ( expected scroll * 0, expected scroll, height )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll * 0, expected scroll, height ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_8.txt",
  "assertion": "assertEquals ( expected scroll_ 0, expected scroll, ) )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll_ 0, expected scroll, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_9.txt",
  "assertion": "assertEquals ( expected scroll, 0, expected scroll, height )\r\n",
  "test": "class X {public void testScrollbarHeight ( ) { final AbsolutePanel scrollPanel \u003d mock ( AbsolutePanel . class ) ; final Element element \u003d mock ( Element . class ) ; final Integer offsetHeight \u003d 1014 ; final Integer clientHeight \u003d 1000 ; doReturn ( offsetHeight ) . when ( element ) . getOffsetHeight ( ) ; doReturn ( clientHeight ) . when ( element ) . getClientHeight ( ) ; doReturn ( element ) . when ( scrollPanel ) . getElement ( ) ; doReturn ( scrollPanel ) . when ( gridLienzoScrollHandler ) . getScrollPanel ( ) ; final Integer expectedScrollbarHeight \u003d offsetHeight - clientHeight ; final Integer actualScrollbarHeight \u003d gridLienzoScrollHandler . scrollbarHeight ( ) ; assertEquals ( expected scroll, 0, expected scroll, height ) ; }  }\r\n",
  "focal method": "class Y{ public void scrollbarHeight() { return ( getScrollPanel ( ) . getElement ( ) . getOffsetHeight ( ) ) - ( getScrollPanel ( ) . getElement ( ) . getClientHeight ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_0.txt",
  "assertion": "assertEquals ( 10, 0. set genber ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genber ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_1.txt",
  "assertion": "assertEquals ( 10, 0. set genle ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genle ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_10.txt",
  "assertion": "assertEquals ( 10, 0. tag genle ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genle ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_11.txt",
  "assertion": "assertEquals ( 10, 0. set genret ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genret ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_12.txt",
  "assertion": "assertEquals ( 10, 0. set genrep ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set genrep ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_13.txt",
  "assertion": "assertEquals ( 10, 0. tag gen re ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag gen re ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_14.txt",
  "assertion": "assertEquals ( 10, 0. set general ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set general ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_15.txt",
  "assertion": "assertEquals ( 10, 0. get genber ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. get genber ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_16.txt",
  "assertion": "assertEquals ( 10, 0. get genle ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. get genle ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_17.txt",
  "assertion": "assertEquals ( 10, 0. v genret ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genret ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_18.txt",
  "assertion": "assertEquals ( 10, 0. v genrep ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genrep ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_19.txt",
  "assertion": "assertEquals ( 10, 0. get gen re ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. get gen re ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_2.txt",
  "assertion": "assertEquals ( 10, 0. set gen re ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. set gen re ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_20.txt",
  "assertion": "assertEquals ( 10, 0. v general ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v general ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_21.txt",
  "assertion": "assertEquals ( 10, 0. int genber ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. int genber ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_22.txt",
  "assertion": "assertEquals ( 10, 0. gen genret ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genret ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_23.txt",
  "assertion": "assertEquals ( 10, 0. int genle ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. int genle ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_24.txt",
  "assertion": "assertEquals ( 10, 0. gen genrep ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genrep ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_25.txt",
  "assertion": "assertEquals ( 10, 0. gen general ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen general ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_26.txt",
  "assertion": "assertEquals ( 10, 0. int gen re ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. int gen re ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_27.txt",
  "assertion": "assertEquals ( 10, 0. tag genret ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genret ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_28.txt",
  "assertion": "assertEquals ( 10, 0. tag genrep ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genrep ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_29.txt",
  "assertion": "assertEquals ( 10, 0. t genber ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. t genber ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_3.txt",
  "assertion": "assertEquals ( 10, 0. v genber ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genber ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_4.txt",
  "assertion": "assertEquals ( 10, 0. v genle ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v genle ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_5.txt",
  "assertion": "assertEquals ( 10, 0. v gen re ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. v gen re ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_6.txt",
  "assertion": "assertEquals ( 10, 0. gen genber ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genber ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_7.txt",
  "assertion": "assertEquals ( 10, 0. gen genle ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen genle ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_8.txt",
  "assertion": "assertEquals ( 10, 0. gen gen re ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. gen gen re ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_9.txt",
  "assertion": "assertEquals ( 10, 0. tag genber ( ) )\r\n",
  "test": "class X {public void getGenreReturnsV1TagsGenreIfV2TagDoesNotExist ( ) { ID3v1 id3v1Tag \u003d new ID3v1TagForTesting ( ) ; id3v1Tag . setGenre ( 10 ) ; ID3Wrapper wrapper \u003d new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( 10, 0. tag genber ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getGenre() { if ( ( ( id3v2Tag ) !\u003d null ) \u0026\u0026 ( ( id3v2Tag . getGenre ( ) ) !\u003d ( - 1 ) ) ) { return id3v2Tag . getGenre ( ) ; } else if ( ( id3v1Tag ) !\u003d null ) { return id3v1Tag . getGenre ( ) ; } else { return - 1 ; } } }\r\n",
  "truth": "assertEquals ( 10, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_0.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_1.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d second instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d second instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_10.txt",
  "assertion": "assertTrue ( ( firstance \u003d\u003d second instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstance \u003d\u003d second instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_11.txt",
  "assertion": "assertTrue ( ( secondance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( secondance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_12.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d secondance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d secondance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_13.txt",
  "assertion": "assertTrue ( ( second instance \u003d\u003d firstance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \u003d\u003d firstance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_14.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d firstOne ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d firstOne ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_15.txt",
  "assertion": "assertTrue ( ( firstinstance \u003d\u003d second instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstinstance \u003d\u003d second instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_16.txt",
  "assertion": "assertTrue ( ( secondinstance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( secondinstance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_17.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d secondinstance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d secondinstance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_18.txt",
  "assertion": "assertTrue ( ( second instance \u003d\u003d firstinstance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \u003d\u003d firstinstance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_19.txt",
  "assertion": "assertTrue ( ( initial instance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( initial instance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_2.txt",
  "assertion": "assertTrue ( ( second instance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_20.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d initial instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d initial instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_21.txt",
  "assertion": "assertTrue ( ( last instance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( last instance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_22.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d last instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d last instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_23.txt",
  "assertion": "assertTrue ( ( firstInstance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstInstance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_24.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d firstInstance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d firstInstance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_25.txt",
  "assertion": "assertTrue ( ( First instance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( First instance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_26.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d First instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d First instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_27.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d firstSame ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d firstSame ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_28.txt",
  "assertion": "assertTrue ( ( third instance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( third instance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_29.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d third instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d third instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_3.txt",
  "assertion": "assertTrue ( ( second instance \u003d\u003d second instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( second instance \u003d\u003d second instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_4.txt",
  "assertion": "assertTrue ( ( firstance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_5.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d firstance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d firstance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_6.txt",
  "assertion": "assertTrue ( ( firstinstance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( firstinstance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_7.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003d firstinstance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003d firstinstance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_8.txt",
  "assertion": "assertTrue ( (first instance \u003d\u003d first instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( (first instance \u003d\u003d first instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_9.txt",
  "assertion": "assertTrue ( ( first instance \u003d\u003dfirst instance ) )\r\n",
  "test": "class X {public void s3SingletonTest ( ) { AmazonS3 firstInstance \u003d AmazonS3Provider . getS3Client ( ) ; AmazonS3 secondInstance \u003d AmazonS3Provider . getS3Client ( ) ; assertTrue ( ( first instance \u003d\u003dfirst instance ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getS3Client() { String smr_stage \u003d System . getenv ( ) . System . get ( \"SMR_STAGE\" ) ; if ( smr_stage . equals ( \"DEV\" ) ) return fr . d2si . ooso . utils . AmazonS3Provider . FakeAmazonS3Holder . S3_CLIENT ; else return fr . d2si . ooso . utils . AmazonS3Provider . AmazonS3Holder . S3_CLIENT ; } }\r\n",
  "truth": "assertTrue ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_0.txt",
  "assertion": "assertEquals ( job, job ). targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_1.txt",
  "assertion": "assertEquals ( job, job ). outputJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). outputJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_10.txt",
  "assertion": "assertEquals ( job, job ). serialJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). serialJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_11.txt",
  "assertion": "assertEquals ( job, jobJob. runJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, jobJob. runJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "job",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_12.txt",
  "assertion": "assertEquals ( job, j ). targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, j ). targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_13.txt",
  "assertion": "assertEquals ( j, job ). targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( j, job ). targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_14.txt",
  "assertion": "assertEquals ( job, job ). run string ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). run string ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_15.txt",
  "assertion": "assertEquals ( job, j ). outputJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, j ). outputJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_16.txt",
  "assertion": "assertEquals ( j, job ). outputJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( j, job ). outputJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_17.txt",
  "assertion": "assertEquals ( job, job ). target String ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). target String ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_18.txt",
  "assertion": "assertEquals ( job, job ). output String ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). output String ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_19.txt",
  "assertion": "assertEquals ( 1, job ). targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( 1, job ). targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_2.txt",
  "assertion": "assertEquals ( job, job ). runJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). runJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_20.txt",
  "assertion": "assertEquals ( job, job ). toJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). toJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_21.txt",
  "assertion": "assertEquals ( 1, job ). outputJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( 1, job ). outputJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_22.txt",
  "assertion": "assertEquals ( job, job ). debugJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). debugJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_23.txt",
  "assertion": "assertEquals ( ), job ). targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( ), job ). targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_24.txt",
  "assertion": "assertEquals ( job, ) ). targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, ) ). targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_25.txt",
  "assertion": "assertEquals ( job, job ). createJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). createJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_26.txt",
  "assertion": "assertEquals ( ), job ). outputJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( ), job ). outputJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_27.txt",
  "assertion": "assertEquals ( job, ) ). outputJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, ) ). outputJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_28.txt",
  "assertion": "assertEquals ( 0, job ). targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( 0, job ). targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_29.txt",
  "assertion": "assertEquals ( job, job ). newJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). newJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_3.txt",
  "assertion": "assertEquals ( job, job ). strJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). strJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_4.txt",
  "assertion": "assertEquals ( job, jobJob. targetJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, jobJob. targetJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "job",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_5.txt",
  "assertion": "assertEquals ( job, jobJob. outputJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, jobJob. outputJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "job",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_6.txt",
  "assertion": "assertEquals ( job, job ). target string ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). target string ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_7.txt",
  "assertion": "assertEquals ( job, job ). nextJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). nextJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_8.txt",
  "assertion": "assertEquals ( job, job ). output string ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). output string ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_9.txt",
  "assertion": "assertEquals ( job, job ). startJob ( ) )\r\n",
  "test": "class X {public void testCommitter ( ) { JobConf job \u003d new JobConf ( ) ; setConfForFileOutputCommitter ( job ) ; JobContext jContext \u003d new JobContextImpl ( job , taskID . getJobID ( ) ) ; TaskAttemptContext tContext \u003d new TaskAttemptContextImpl ( job , org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . taskID ) ; FileOutputCommitter committer \u003d new FileOutputCommitter ( ) ; FileOutputFormat . setWorkOutputPath ( job , committer . getTaskAttemptPath ( tContext ) ) ; committer . setupJob ( jContext ) ; committer . setupTask ( tContext ) ; String file \u003d \"test.txt\" ; Reporter reporter \u003d Reporter . NULL ; FileSystem localFs \u003d FileSystem . getLocal ( job ) ; TextOutputFormat theOutputFormat \u003d new TextOutputFormat ( ) ; RecordWriter theRecordWriter \u003d theOutputFormat . getRecordWriter ( localFs , job , file , reporter ) ; writeOutput ( theRecordWriter , reporter ) ; committer . commitTask ( tContext ) ; committer . commitJob ( jContext ) ; File expectedFile \u003d new File ( new Path ( org . apache . hadoop . mapred . TestMRCJCFileOutputCommitter . outDir , file ) . outDir . toString ( ) ) ; StringBuffer expectedOutput \u003d new StringBuffer ( ) ; expectedOutput . append ( key1 ) . append ( \u0027\\t\u0027 ) . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val1 ) . append ( \"\\n\" ) ; expectedOutput . append ( val2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \"\\n\" ) ; expectedOutput . append ( key1 ) . append ( \"\\n\" ) ; expectedOutput . append ( key2 ) . append ( \u0027\\t\u0027 ) . append ( val2 ) . append ( \"\\n\" ) ; String output \u003d UtilsForTests . slurp ( expectedFile ) ; assertEquals ( job, job ). startJob ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( ( ( ( ( ( ( ( ( \"OzoneFileSystem{URI\u003d\" + ( uri ) ) + \",\u003csp\u003e\" ) + \"workingDir\u003d\" ) + ( workingDir ) ) + \",\u003csp\u003e\" ) + \"userName\u003d\" ) + ( userName ) ) + \",\u003csp\u003e\" ) + \"statistics\u003d\" ) + ( statistics ) ) + \"}\" ; } }\r\n",
  "truth": "assertEquals ( output, expectedOutput. toString ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_0.txt",
  "assertion": "assertNull ( result )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( result ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "39_1.txt",
  "assertion": "assertNull ( test )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( test ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_10.txt",
  "assertion": "assertNull (Result )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull (Result ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_11.txt",
  "assertion": "assertNull ( call )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( call ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_12.txt",
  "assertion": "assertNull ( return )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( return ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_13.txt",
  "assertion": "assertNull ( handle )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( handle ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_14.txt",
  "assertion": "assertNull ( end )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( end ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_15.txt",
  "assertion": "assertNull ( results )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( results ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_16.txt",
  "assertion": "assertNull ( 2 )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_17.txt",
  "assertion": "assertNull ( continue )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( continue ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_18.txt",
  "assertion": "assertNull ( server )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( server ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_19.txt",
  "assertion": "assertNull ( successor )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( successor ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_2.txt",
  "assertion": "assertNull ( match )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( match ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_20.txt",
  "assertion": "assertNull ( callback )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( callback ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_21.txt",
  "assertion": "assertNull ( function )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( function ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_22.txt",
  "assertion": "assertNull ( cause )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( cause ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_23.txt",
  "assertion": "assertNull ( output )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( output ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_24.txt",
  "assertion": "assertNull ( Result )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( Result ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_25.txt",
  "assertion": "assertNull ( type )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( type ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_26.txt",
  "assertion": "assertNull ( target )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( target ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_27.txt",
  "assertion": "assertNull ( ret )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( ret ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_28.txt",
  "assertion": "assertNull ( client )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( client ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_29.txt",
  "assertion": "assertNull ( rule )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( rule ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_3.txt",
  "assertion": "assertNull ( future )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( future ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_4.txt",
  "assertion": "assertNull (result )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull (result ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "39_5.txt",
  "assertion": "assertNull ( answer )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( answer ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_6.txt",
  "assertion": "assertNull ( null )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_7.txt",
  "assertion": "assertNull ( combine )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( combine ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_8.txt",
  "assertion": "assertNull ( instance )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( instance ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "39_9.txt",
  "assertion": "assertNull ( value )\r\n",
  "test": "class X {public void testDeregisterHandler ( ) { handlerStore . registerHandler ( \"testId\" , testHandler ) ; handlerStore . deregisterHandler ( \"testId\" ) ; FileUploadHandler result \u003d handlerStore . getHandler ( \"testId\" ) ; assertNull ( value ) ; }  }\r\n",
  "focal method": "class Y{ public void getHandler( String  var24678 ) { return handlers . get ( token ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_0.txt",
  "assertion": "assertEquals ( 2, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_1.txt",
  "assertion": "assertEquals ( 1, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_10.txt",
  "assertion": "assertEquals ( 1, counter )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, counter ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "counter",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "3_11.txt",
  "assertion": "assertEquals ( counter, 1 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( counter, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "counter",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "3_12.txt",
  "assertion": "assertEquals ( 3, 1 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 3, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_13.txt",
  "assertion": "assertEquals ( 1, 3 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_14.txt",
  "assertion": "assertEquals ( 10, 1 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 10, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_15.txt",
  "assertion": "assertEquals ( 1, 10 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_16.txt",
  "assertion": "assertEquals ( 4, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 4, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_17.txt",
  "assertion": "assertEquals ( 2, 4 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 4 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_18.txt",
  "assertion": "assertEquals ( 5, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 5, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_19.txt",
  "assertion": "assertEquals ( 20, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 20, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_2.txt",
  "assertion": "assertEquals ( 2, 1 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_20.txt",
  "assertion": "assertEquals ( 2, 20 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 20 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_21.txt",
  "assertion": "assertEquals ( 4, 1 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 4, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_22.txt",
  "assertion": "assertEquals ( 1, 4 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 4 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_23.txt",
  "assertion": "assertEquals ( 1000, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1000, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_24.txt",
  "assertion": "assertEquals ( 2, 1000 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 1000 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_25.txt",
  "assertion": "assertEquals ( counter, counter )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( counter, counter ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_26.txt",
  "assertion": "assertEquals ( 100, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 100, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_27.txt",
  "assertion": "assertEquals ( 2, 100 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 100 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_28.txt",
  "assertion": "assertEquals ( 16, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 16, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_29.txt",
  "assertion": "assertEquals ( 2, 16 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 16 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_3.txt",
  "assertion": "assertEquals ( 1, 1 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 1, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_4.txt",
  "assertion": "assertEquals ( 2, counter )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, counter ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "counter",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "3_5.txt",
  "assertion": "assertEquals ( counter, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( counter, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "counter",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "3_6.txt",
  "assertion": "assertEquals ( 3, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 3, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_7.txt",
  "assertion": "assertEquals ( 2, 3 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_8.txt",
  "assertion": "assertEquals ( 10, 2 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 10, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "3_9.txt",
  "assertion": "assertEquals ( 2, 10 )\r\n",
  "test": "class X {public void shouldSupportConfigurationOfRegistryBuilder ( ) { final GraphBinaryMessageSerializerV1 serializer \u003d new GraphBinaryMessageSerializerV1 ( ) ; final Map \u003c String , Object \u003e config \u003d new HashMap ( ) ; int counter \u003d createCounter . get ( ) ; config . TOKEN_BUILDER . put ( \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter \u003d ( createCounter . get ( ) ) - counter ; assertEquals ( 2, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void get() { return this . t ; } }\r\n",
  "truth": "assertEquals ( 1, counter )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "40_0.txt",
  "assertion": "assertEquals ( 7, 1. 7 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_1.txt",
  "assertion": "assertEquals ( 7, 1. 7 int8 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int8 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_10.txt",
  "assertion": "assertEquals ( 7, 1. 7 int1 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_11.txt",
  "assertion": "assertEquals ( 7, 1. 7 Int80 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int80 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_12.txt",
  "assertion": "assertEquals ( 7, 1. 7int8 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int8 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_13.txt",
  "assertion": "assertEquals ( 8, 1. 7 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 8, 1. 7 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_14.txt",
  "assertion": "assertEquals ( 7, 1. 8 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 8 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_15.txt",
  "assertion": "assertEquals ( 7, 1. 7 Int10 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int10 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_16.txt",
  "assertion": "assertEquals ( 7, 1. 7 intf ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 intf ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_17.txt",
  "assertion": "assertEquals ( 7, 1. 7 Int ++ ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int ++ ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_18.txt",
  "assertion": "assertEquals ( 7, 1. 7int80 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int80 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_19.txt",
  "assertion": "assertEquals ( 7, value. 7 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, value. 7 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_2.txt",
  "assertion": "assertEquals ( 7, 1. 7 int80 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int80 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_20.txt",
  "assertion": "assertEquals ( 7, field. 7 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, field. 7 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_21.txt",
  "assertion": "assertEquals ( 9, 1. 7 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 9, 1. 7 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_22.txt",
  "assertion": "assertEquals ( 7, 1. 7 intfield ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 intfield ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_23.txt",
  "assertion": "assertEquals ( 7, number. 7 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, number. 7 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_24.txt",
  "assertion": "assertEquals ( 8, 1. 7 int8 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 8, 1. 7 int8 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_25.txt",
  "assertion": "assertEquals ( 7, 1. 8 int8 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 8 int8 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_26.txt",
  "assertion": "assertEquals ( 7, 1. 7int10 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int10 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_27.txt",
  "assertion": "assertEquals ( 7, 1. 7int ++ ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int ++ ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_28.txt",
  "assertion": "assertEquals ( 7, java. 7 int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, java. 7 int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_29.txt",
  "assertion": "assertEquals ( 7, 1. 7In field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7In field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_3.txt",
  "assertion": "assertEquals ( 7, 1. 7 int10 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int10 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_4.txt",
  "assertion": "assertEquals ( 7, 1. 7 int ++ ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int ++ ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_5.txt",
  "assertion": "assertEquals ( 7, 1. 7 Int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_6.txt",
  "assertion": "assertEquals ( 7, 1. 7 int15 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int15 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_7.txt",
  "assertion": "assertEquals ( 7, 1. 7 int Field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 int Field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_8.txt",
  "assertion": "assertEquals ( 7, 1. 7int field ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7int field ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_9.txt",
  "assertion": "assertEquals ( 7, 1. 7 Int8 ( ) )\r\n",
  "test": "class X {public void testSetIn ( ) { TstJavaBean bean \u003d new TstJavaBean ( ) ; BaseProperty \u003c Integer \u003e INT_FIELD \u003d new BaseProperty ( \"intField\" , null , Integer . class ) ; INT_FIELD . setIn ( bean , 7 ) ; assertEquals ( 7, 1. 7 Int8 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIntField() { return intField ; } }\r\n",
  "truth": "assertEquals ( 7, bean. getIntField ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_0.txt",
  "assertion": "assertEquals ( expected, 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_1.txt",
  "assertion": "assertEquals ( expected, 1, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 1, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_10.txt",
  "assertion": "assertEquals ( expectedTarget 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTarget 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_11.txt",
  "assertion": "assertEquals ( expected, 0, expected Count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expected Count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_12.txt",
  "assertion": "assertEquals ( expected transaction 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected transaction 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_13.txt",
  "assertion": "assertEquals ( expectedEntity 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedEntity 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_14.txt",
  "assertion": "assertEquals ( expected, 0, expectedCode )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedCode ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_15.txt",
  "assertion": "assertEquals ( expectedTo 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTo 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_16.txt",
  "assertion": "assertEquals ( expectedDefault count, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedDefault count, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_17.txt",
  "assertion": "assertEquals ( expected, 1, expectedCount )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 1, expectedCount ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_18.txt",
  "assertion": "assertEquals ( expected, 0, expectedcount )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedcount ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_19.txt",
  "assertion": "assertEquals ( expectedTask 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTask 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_2.txt",
  "assertion": "assertEquals ( expected, count, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, count, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_20.txt",
  "assertion": "assertEquals ( expectedT 1, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedT 1, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_21.txt",
  "assertion": "assertEquals ( expected,Max, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected,Max, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_22.txt",
  "assertion": "assertEquals ( expected, count, expectedCount )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, count, expectedCount ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_23.txt",
  "assertion": "assertEquals ( expected,Count, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected,Count, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_24.txt",
  "assertion": "assertEquals ( expected, 0, expectedCont )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedCont ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_25.txt",
  "assertion": "assertEquals ( expectedNot 1, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedNot 1, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_26.txt",
  "assertion": "assertEquals ( expectedTen 1, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTen 1, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_27.txt",
  "assertion": "assertEquals ( expectedRequest 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedRequest 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_28.txt",
  "assertion": "assertEquals ( expected, 0, expectedTotal )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedTotal ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_29.txt",
  "assertion": "assertEquals ( expected,2, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected,2, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_3.txt",
  "assertion": "assertEquals ( expectedDefault 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedDefault 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_4.txt",
  "assertion": "assertEquals ( expected, 0, expectedCount )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, 0, expectedCount ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_5.txt",
  "assertion": "assertEquals ( expected, ), expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expected, ), expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_6.txt",
  "assertion": "assertEquals ( expectedT 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedT 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_7.txt",
  "assertion": "assertEquals ( expectedNot 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedNot 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_8.txt",
  "assertion": "assertEquals ( expectedTen 0, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedTen 0, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_9.txt",
  "assertion": "assertEquals ( expectedDefault 1, expected count )\r\n",
  "test": "class X {public void testSingleTransaction_SAMPLED_NEW ( ) { final long expectedTransactionCount \u003d 1L ; idGenerator . nextTransactionId ( ) ; final long actualCount \u003d transactionCounter . getSampledNewCount ( ) ; assertEquals ( expectedDefault 1, expected count ) ; }  }\r\n",
  "focal method": "class Y{ public void getSampledNewCount() { return ( idGenerator . currentTransactionId ( ) ) - ( AtomicIdGenerator . INITIAL_TRANSACTION_ID ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_0.txt",
  "assertion": "assertTrue ( true )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( true ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_1.txt",
  "assertion": "assertTrue ( false )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( false ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_10.txt",
  "assertion": "assertTrue ( untrue )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( untrue ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_11.txt",
  "assertion": "assertTrue (false )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue (false ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_12.txt",
  "assertion": "assertTrue ( 0 )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_13.txt",
  "assertion": "assertTrue ( FALSE )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( FALSE ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_14.txt",
  "assertion": "assertTrue ( testing )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( testing ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_15.txt",
  "assertion": "assertTrue ( boolean )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( boolean ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_16.txt",
  "assertion": "assertTrue ( ) )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_17.txt",
  "assertion": "assertTrue ( test )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( test ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_18.txt",
  "assertion": "assertTrue ( opposite )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( opposite ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_19.txt",
  "assertion": "assertTrue ( changed )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( changed ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_2.txt",
  "assertion": "assertTrue ( TRUE )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( TRUE ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_20.txt",
  "assertion": "assertTrue ( return )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( return ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_21.txt",
  "assertion": "assertTrue ( null )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_22.txt",
  "assertion": "assertTrue ( unlock )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( unlock ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_23.txt",
  "assertion": "assertTrue ( released )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( released ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_24.txt",
  "assertion": "assertTrue ( restored )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( restored ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_25.txt",
  "assertion": "assertTrue ( correct )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( correct ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_26.txt",
  "assertion": "assertTrue ( locked )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( locked ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_27.txt",
  "assertion": "assertTrue (! )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue (! ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_28.txt",
  "assertion": "assertTrue ( continue )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( continue ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_29.txt",
  "assertion": "assertTrue ( check )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( check ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_3.txt",
  "assertion": "assertTrue (False )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue (False ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_4.txt",
  "assertion": "assertTrue ( True )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( True ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_5.txt",
  "assertion": "assertTrue (True )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue (True ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_6.txt",
  "assertion": "assertTrue ( False )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( False ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_7.txt",
  "assertion": "assertTrue (true )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue (true ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_8.txt",
  "assertion": "assertTrue ( \"\" )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "42_9.txt",
  "assertion": "assertTrue ( 1 )\r\n",
  "test": "class X {public void testWithDifferentResource ( ) { LockManager \u003c String \u003e manager \u003d new LockManager ( new OzoneConfiguration ( ) ) ; manager . lock ( \"/resourceOne\" ) ; manager . lock ( \"/resourceTwo\" ) ; manager . unlock ( \"/resourceOne\" ) ; manager . unlock ( \"/resourceTwo\" ) ; assertTrue ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void unlock( T  var24678 ) { ActiveLock lock \u003d activeLocks . get ( resource ) ; if ( lock \u003d\u003d null ) { LOG . warn ( \"Trying\u003csp\u003eto\u003csp\u003erelease\u003csp\u003ethe\u003csp\u003elock\u003csp\u003eon\u003csp\u003e{},\u003csp\u003ewhich\u003csp\u003ewas\u003csp\u003enever\u003csp\u003eacquired.\" , resource ) ; return ; } lock . unlock ( ) ; activeLocks . computeIfPresent ( resource , ( k , v ) -\u003e { v . decrementActiveCount ( ) ; if ( ( v . getActiveLockCount ( ) ) !\u003d 0 ) { return v ; } lockPool . returnObject ( v ) ; return null ; } ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_0.txt",
  "assertion": "assertFalse ( did ruleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_1.txt",
  "assertion": "assertFalse ( did rule apply )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did rule apply ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_10.txt",
  "assertion": "assertFalse ( did ruleSet )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleSet ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_11.txt",
  "assertion": "assertFalse ( didRulesDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didRulesDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_12.txt",
  "assertion": "assertFalse ( had ruleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( had ruleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_13.txt",
  "assertion": "assertFalse ( didPolicy apply )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didPolicy apply ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_14.txt",
  "assertion": "assertFalse ( didn ruleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didn ruleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_15.txt",
  "assertion": "assertFalse ( did rule Apply )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did rule Apply ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_16.txt",
  "assertion": "assertFalse ( d ruleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( d ruleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_17.txt",
  "assertion": "assertFalse ( didruleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didruleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_18.txt",
  "assertion": "assertFalse ( did Rule apply )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did Rule apply ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_19.txt",
  "assertion": "assertFalse (\u0027d ruleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse (\u0027d ruleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_2.txt",
  "assertion": "assertFalse ( didValueDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didValueDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_20.txt",
  "assertion": "assertFalse ( didByteDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didByteDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_21.txt",
  "assertion": "assertFalse ( didRootDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didRootDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_22.txt",
  "assertion": "assertFalse ( did ruleLimit )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleLimit ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_23.txt",
  "assertion": "assertFalse ( did ruleFilter )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleFilter ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_24.txt",
  "assertion": "assertFalse ( did ruleWrite )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleWrite ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_25.txt",
  "assertion": "assertFalse ( didRuleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didRuleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_26.txt",
  "assertion": "assertFalse ( didMethodDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didMethodDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_27.txt",
  "assertion": "assertFalse ( did ruleAccept )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleAccept ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_28.txt",
  "assertion": "assertFalse ( DID ruleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( DID ruleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_29.txt",
  "assertion": "assertFalse ( didModel apply )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didModel apply ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_3.txt",
  "assertion": "assertFalse ( didPolicyDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didPolicyDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_4.txt",
  "assertion": "assertFalse ( did ruleFile )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleFile ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_5.txt",
  "assertion": "assertFalse ( did RuleDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did RuleDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_6.txt",
  "assertion": "assertFalse ( did ruleMap )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleMap ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_7.txt",
  "assertion": "assertFalse ( didModelDo )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didModelDo ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "43_8.txt",
  "assertion": "assertFalse ( didValue apply )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( didValue apply ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_9.txt",
  "assertion": "assertFalse ( did ruleMessage )\r\n",
  "test": "class X {public void shouldReturnFalseIfDeathReasonIsNotDeath ( ) { boolean didRuleApply \u003d rule . apply ( new SafeMap ( create ( \"closeReason\" , \"permanent_relocation\" ) . map ( ) ) ) ; assertFalse ( did ruleMessage ) ; }  }\r\n",
  "focal method": "class Y{ public void map() { return map ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "44_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "44_1.txt",
  "assertion": "assertEquals ( expect, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expect, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_10.txt",
  "assertion": "assertEquals ( expected, 0 )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_11.txt",
  "assertion": "assertEquals ( 8, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 8, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_12.txt",
  "assertion": "assertEquals ( expected, 8 )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 8 ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_13.txt",
  "assertion": "assertEquals (expected, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals (expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "44_14.txt",
  "assertion": "assertEquals ( expected,expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected,expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "44_15.txt",
  "assertion": "assertEquals ( 3, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 3, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_16.txt",
  "assertion": "assertEquals ( 1, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 1, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_17.txt",
  "assertion": "assertEquals ( expected, 1 )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_18.txt",
  "assertion": "assertEquals ( 20, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 20, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_19.txt",
  "assertion": "assertEquals ( expected, 20 )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 20 ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_2.txt",
  "assertion": "assertEquals ( expected, expect )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, expect ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_20.txt",
  "assertion": "assertEquals ( found, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( found, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_21.txt",
  "assertion": "assertEquals ( expected, found )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, found ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_22.txt",
  "assertion": "assertEquals ( 2, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 2, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_23.txt",
  "assertion": "assertEquals ( \"\", expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( \"\", expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_24.txt",
  "assertion": "assertEquals ( expecting, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expecting, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_25.txt",
  "assertion": "assertEquals ( null, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( null, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_26.txt",
  "assertion": "assertEquals ( assumed, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( assumed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_27.txt",
  "assertion": "assertEquals ( expected, assumed )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, assumed ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_28.txt",
  "assertion": "assertEquals ( supposed, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( supposed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_29.txt",
  "assertion": "assertEquals ( allowed, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( allowed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_3.txt",
  "assertion": "assertEquals (pected, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals (pected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_4.txt",
  "assertion": "assertEquals ( expected,pected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected,pected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_5.txt",
  "assertion": "assertEquals ( 10, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 10, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_6.txt",
  "assertion": "assertEquals ( expected, 10 )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_7.txt",
  "assertion": "assertEquals ( 123, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 123, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_8.txt",
  "assertion": "assertEquals ( expected, 123 )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( expected, 123 ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "44_9.txt",
  "assertion": "assertEquals ( 0, expected )\r\n",
  "test": "class X {public void testBuildOverpassQuery ( ) { OverpassBridge ob \u003d new OverpassBridge ( de . nx42 . maps4cim . map . texture . osm . OverpassBridgeTest . c ) ; String expected \u003d \"(way[\\\"landuse\\\"~\\\"forest|wood\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"waterway\\\"\u003d\\\"riverbank\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"bridge\\\"](48.39650842,11.73723469,48.40549158,11.75076531);way[\\\"highway\\\"~\\\"_link\\\"](48.39650842,11.73723469,48.40549158,11.75076531););(._;\u003e;);out\u003csp\u003emeta;\" ; String actual \u003d ob . buildOverpassQuery ( ) ; assertEquals ( 0, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void buildOverpassQuery() { if ( exceedsQueryLimit ( ) ) { return buildQueryFullyRecursive ( ) ; } else { return buildQueryEntityConcat ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "45_0.txt",
  "assertion": "assertNotNull ( h buffalo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( h buffalo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_1.txt",
  "assertion": "assertNotNull ( hhi )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hhi ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_10.txt",
  "assertion": "assertNotNull ( hla )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hla ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_11.txt",
  "assertion": "assertNotNull ( hula )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hula ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_12.txt",
  "assertion": "assertNotNull ( haho )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( haho ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_13.txt",
  "assertion": "assertNotNull ( halia )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( halia ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_14.txt",
  "assertion": "assertNotNull ( hale )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hale ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_15.txt",
  "assertion": "assertNotNull ( hlo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hlo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_16.txt",
  "assertion": "assertNotNull ( hello )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hello ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_17.txt",
  "assertion": "assertNotNull ( hala )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hala ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_18.txt",
  "assertion": "assertNotNull ( hero )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hero ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_19.txt",
  "assertion": "assertNotNull ( homa )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( homa ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_2.txt",
  "assertion": "assertNotNull ( hho )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hho ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_20.txt",
  "assertion": "assertNotNull ( hroma )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hroma ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_21.txt",
  "assertion": "assertNotNull ( hloe )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hloe ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_22.txt",
  "assertion": "assertNotNull ( holler )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( holler ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_23.txt",
  "assertion": "assertNotNull ( halos )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( halos ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_24.txt",
  "assertion": "assertNotNull (h buffalo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull (h buffalo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_25.txt",
  "assertion": "assertNotNull ( hoe )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hoe ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_26.txt",
  "assertion": "assertNotNull ( hallo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hallo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_27.txt",
  "assertion": "assertNotNull ( hao )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hao ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_28.txt",
  "assertion": "assertNotNull ( H buffalo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( H buffalo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_29.txt",
  "assertion": "assertNotNull ( ha buffalo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( ha buffalo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_3.txt",
  "assertion": "assertNotNull ( hila )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hila ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_4.txt",
  "assertion": "assertNotNull ( haley )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( haley ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_5.txt",
  "assertion": "assertNotNull ( hana )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hana ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_6.txt",
  "assertion": "assertNotNull ( halo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( halo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "halo",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "45_7.txt",
  "assertion": "assertNotNull ( hacho )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hacho ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_8.txt",
  "assertion": "assertNotNull ( holo )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( holo ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_9.txt",
  "assertion": "assertNotNull ( hino )\r\n",
  "test": "class X {public void halo ( ) { HaloBuilder b \u003d new HaloBuilder ( null ) ; Halo halo \u003d b . build ( ) ; assertNotNull ( hino ) ; }  }\r\n",
  "focal method": "class Y{ public void build() { if ( unset ) { return null ; } return ff . id ( new HashSet \u003c Identifier \u003e ( ids ) ) ; } }\r\n",
  "truth": "assertNotNull ( halo )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "46_0.txt",
  "assertion": "assertEquals ( \"\", ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_1.txt",
  "assertion": "assertEquals ( ), ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_10.txt",
  "assertion": "assertEquals ( ), ). name ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_11.txt",
  "assertion": "assertEquals ( ), ). title ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). title ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_12.txt",
  "assertion": "assertEquals ( \"\",\"). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\",\"). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_13.txt",
  "assertion": "assertEquals ( null, ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( null, ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_14.txt",
  "assertion": "assertEquals ( \"\", ). value ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_15.txt",
  "assertion": "assertEquals ( \"\", text. \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", text. \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_16.txt",
  "assertion": "assertEquals (\"), ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals (\"), ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_17.txt",
  "assertion": "assertEquals ( ),\"). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ),\"). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_18.txt",
  "assertion": "assertEquals ( \"\", ). read ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). read ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_19.txt",
  "assertion": "assertEquals ( \"\", ). string ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). string ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_2.txt",
  "assertion": "assertEquals ( \"\", ). text ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). text ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_20.txt",
  "assertion": "assertEquals ( \u0027\u0027, ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \u0027\u0027, ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_21.txt",
  "assertion": "assertEquals ( \"\", ). word ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). word ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_22.txt",
  "assertion": "assertEquals ( ), ). value ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_23.txt",
  "assertion": "assertEquals ( \", ). text ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \", ). text ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_24.txt",
  "assertion": "assertEquals ( text, ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( text, ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_25.txt",
  "assertion": "assertEquals ( ), text. \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), text. \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_26.txt",
  "assertion": "assertEquals ( 1, ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( 1, ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_27.txt",
  "assertion": "assertEquals (\", ). text ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals (\", ). text ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_28.txt",
  "assertion": "assertEquals ( \"\", ). get ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). get ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_29.txt",
  "assertion": "assertEquals ( ), ). read ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). read ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_3.txt",
  "assertion": "assertEquals ( ), ). text ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). text ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_4.txt",
  "assertion": "assertEquals ( \"\", ). message ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). message ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_5.txt",
  "assertion": "assertEquals ( ), ). message ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( ), ). message ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_6.txt",
  "assertion": "assertEquals ( \"\", ). name ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_7.txt",
  "assertion": "assertEquals ( \", ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \", ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_8.txt",
  "assertion": "assertEquals (\", ). \" ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals (\", ). \" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_9.txt",
  "assertion": "assertEquals ( \"\", ). title ( ) )\r\n",
  "test": "class X {public void testIndexQueryWithScore ( ) { PropertyKey textKey \u003d mgmt . makePropertyKey ( \"text\" ) . dataType ( String . class ) . make ( ) ; mgmt . buildIndex ( \"store1\" , Vertex . class ) . addKey ( textKey ) . INDEX . buildMixedIndex ( ) ; mgmt . commit ( ) ; TitanVertex v1 \u003d tx . addVertex ( ) ; TitanVertex v2 \u003d tx . addVertex ( ) ; TitanVertex v3 \u003d tx . addVertex ( ) ; v1 . property ( \"text\" , \"Hello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\u003csp\u003eHello\" ) ; v2 . property ( \"text\" , \"Hello\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdfsd\u003csp\u003esdffs\u003csp\u003efsdsdf\u003csp\u003efdf\u003csp\u003efsdfsd\u003csp\u003eaera\u003csp\u003efsad\u003csp\u003eabab\u003csp\u003eabab\u003csp\u003efsdfsd\u003csp\u003esfdf\" ) ; v3 . property ( \"text\" , \"Hello\" ) ; tx . commit ( ) ; Thread . sleep ( 5000 ) ; Set \u003c Double \u003e scores \u003d new HashSet \u003c Double \u003e ( ) ; for ( Result \u003c TitanVertex \u003e r : graph . indexQuery ( \"store1\" , \"v.text:(Hello)\" ) . vertices ( ) ) { scores . add ( r . getScore ( ) ) ; } assertEquals ( \"\", ). title ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return vertices . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_0.txt",
  "assertion": "assertEquals ( 0, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 0, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_1.txt",
  "assertion": "assertEquals ( 1, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 1, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_10.txt",
  "assertion": "assertEquals ( 9, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 9, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_11.txt",
  "assertion": "assertEquals ( 8, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 8, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_12.txt",
  "assertion": "assertEquals (0, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals (0, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_13.txt",
  "assertion": "assertEquals ( 20, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 20, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_14.txt",
  "assertion": "assertEquals ( 100, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 100, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_15.txt",
  "assertion": "assertEquals ( 12, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 12, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_16.txt",
  "assertion": "assertEquals ( 50, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 50, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_17.txt",
  "assertion": "assertEquals ( 15, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 15, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_18.txt",
  "assertion": "assertEquals ( 16, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 16, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_19.txt",
  "assertion": "assertEquals ( zero, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( zero, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_2.txt",
  "assertion": "assertEquals ( 0, 0. 1 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 0, 0. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_20.txt",
  "assertion": "assertEquals ( 0, 0. zero ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 0, 0. zero ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_21.txt",
  "assertion": "assertEquals ( null, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( null, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_22.txt",
  "assertion": "assertEquals ( 1000, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 1000, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_23.txt",
  "assertion": "assertEquals ( 11, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 11, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_24.txt",
  "assertion": "assertEquals ( None, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( None, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_25.txt",
  "assertion": "assertEquals ( false, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( false, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_26.txt",
  "assertion": "assertEquals ( N, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( N, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_27.txt",
  "assertion": "assertEquals ( n, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( n, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_28.txt",
  "assertion": "assertEquals ( 1, 0. 1 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 1, 0. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_29.txt",
  "assertion": "assertEquals ( 0, 0. size ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 0, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_3.txt",
  "assertion": "assertEquals ( 3, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 3, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_4.txt",
  "assertion": "assertEquals ( 2, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 2, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_5.txt",
  "assertion": "assertEquals ( 4, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 4, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_6.txt",
  "assertion": "assertEquals ( 5, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 5, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_7.txt",
  "assertion": "assertEquals ( 10, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 10, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_8.txt",
  "assertion": "assertEquals ( 7, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 7, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_9.txt",
  "assertion": "assertEquals ( 6, 0. 0 ( ) )\r\n",
  "test": "class X {public void testGetTasksAssignedAsBusinessAdministratorWithUserLangNoTask ( ) { List \u003c TaskSummary \u003e tasks \u003d taskService . getTasksAssignedAsBusinessAdministrator ( \"Bobba\u003csp\u003eFet\" , \"en-UK\" ) ; assertEquals ( 6, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return data . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_0.txt",
  "assertion": "assertEquals ( queue. name ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_1.txt",
  "assertion": "assertEquals ( queue. index ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_10.txt",
  "assertion": "assertEquals ( queue. index ( ), 100 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 100 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_11.txt",
  "assertion": "assertEquals ( queue. size ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. size ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_12.txt",
  "assertion": "assertEquals ( queue. name ( ), i )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), i ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "i",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_13.txt",
  "assertion": "assertEquals ( queue. count ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. count ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_14.txt",
  "assertion": "assertEquals ( queue. name ( ), 50 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 50 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_15.txt",
  "assertion": "assertEquals ( queue. len ( ), name )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. len ( ), name ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_16.txt",
  "assertion": "assertEquals ( queue. index ( ), i )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), i ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "i",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_17.txt",
  "assertion": "assertEquals ( queue. tick ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. tick ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_18.txt",
  "assertion": "assertEquals ( queue. poll ( ), 1000 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. poll ( ), 1000 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_19.txt",
  "assertion": "assertEquals ( queue. suffix ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. suffix ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_2.txt",
  "assertion": "assertEquals ( queue. name ( ), name )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), name ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_20.txt",
  "assertion": "assertEquals ( queue. index ( ), 50 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 50 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_21.txt",
  "assertion": "assertEquals ( queue. name ( ), size )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), size ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_22.txt",
  "assertion": "assertEquals ( queue. size ( ), name )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. size ( ), name ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_23.txt",
  "assertion": "assertEquals ( queue. name ( ), 1 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_24.txt",
  "assertion": "assertEquals ( queue. next ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. next ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_25.txt",
  "assertion": "assertEquals ( queue. len ( ), 1000 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. len ( ), 1000 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_26.txt",
  "assertion": "assertEquals ( queue. count ( ), name )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. count ( ), name ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_27.txt",
  "assertion": "assertEquals ( queue. index ( ), size )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), size ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_28.txt",
  "assertion": "assertEquals ( queue. name ( ), 10 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_29.txt",
  "assertion": "assertEquals ( queue. tick ( ), name )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. tick ( ), name ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_3.txt",
  "assertion": "assertEquals ( queue. index ( ), name )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), name ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_4.txt",
  "assertion": "assertEquals ( queue. name ( ), 1000 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 1000 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_5.txt",
  "assertion": "assertEquals ( queue. index ( ), 1000 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. index ( ), 1000 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_6.txt",
  "assertion": "assertEquals ( queue. poll ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. poll ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_7.txt",
  "assertion": "assertEquals ( queue. len ( ), 0 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. len ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_8.txt",
  "assertion": "assertEquals ( queue. name ( ), 100 )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. name ( ), 100 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_9.txt",
  "assertion": "assertEquals ( queue. poll ( ), name )\r\n",
  "test": "class X {public void differentIdentifierSize ( ) { FairQueue \u003c Q \u003e queue \u003d new FairQueue ( ) ; int size \u003d 100 ; for ( int i \u003d 0 ; i \u003c size ; i ++ ) queue . add ( new Q ( i ) ) ; assertEquals ( queue. poll ( ), name ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return list . size ( ) ; } }\r\n",
  "truth": "assertEquals ( queue. size ( ), size )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_0.txt",
  "assertion": "assertTrue ( edit added [ mode ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ mode ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_1.txt",
  "assertion": "assertTrue ( edit added [ 0 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_10.txt",
  "assertion": "assertTrue ( editAdd [ 10 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 10 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_11.txt",
  "assertion": "assertTrue ( edit added [ 50 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 50 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_12.txt",
  "assertion": "assertTrue ( edit added [ 9 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 9 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_13.txt",
  "assertion": "assertTrue ( editAdd [ start ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ start ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_14.txt",
  "assertion": "assertTrue ( edit added [ : ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ : ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_15.txt",
  "assertion": "assertTrue ( editAdd [ 1 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_16.txt",
  "assertion": "assertTrue ( edit added [ 2 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 2 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_17.txt",
  "assertion": "assertTrue ( editAdd [ - ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ - ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_18.txt",
  "assertion": "assertTrue ( edit added [ 8 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 8 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_19.txt",
  "assertion": "assertTrue ( editAdd [ 50 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 50 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_2.txt",
  "assertion": "assertTrue ( editAdd [ mode ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ mode ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_20.txt",
  "assertion": "assertTrue ( edit added [ 16 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 16 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_21.txt",
  "assertion": "assertTrue ( edit added [ i ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ i ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_22.txt",
  "assertion": "assertTrue ( editAdd [ 9 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 9 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_23.txt",
  "assertion": "assertTrue ( edit added [ 7 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 7 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_24.txt",
  "assertion": "assertTrue ( editAdd [ : ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ : ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_25.txt",
  "assertion": "assertTrue ( edit added [ 5 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 5 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_26.txt",
  "assertion": "assertTrue ( editAdd [ 2 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 2 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_27.txt",
  "assertion": "assertTrue ( edit added [ zero ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ zero ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_28.txt",
  "assertion": "assertTrue ( editPosted [ mode ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editPosted [ mode ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_29.txt",
  "assertion": "assertTrue ( edit added [ 6 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 6 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_3.txt",
  "assertion": "assertTrue ( editAdd [ 0 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_4.txt",
  "assertion": "assertTrue ( edit added [ j ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ j ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_5.txt",
  "assertion": "assertTrue ( edit added [ 10 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 10 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_6.txt",
  "assertion": "assertTrue ( edit added [ start ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ start ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_7.txt",
  "assertion": "assertTrue ( edit added [ 1 ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_8.txt",
  "assertion": "assertTrue ( edit added [ - ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( edit added [ - ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_9.txt",
  "assertion": "assertTrue ( editAdd [ j ] )\r\n",
  "test": "class X {public void testAddCaretUndoableEdit ( ) { final JEditorPane pane \u003d new JEditorPane ( \"text/plain\" , \"Haf\" ) ; final boolean [ ] editAdded \u003d new boolean [ ] { false } ; final Document doc \u003d pane . getDocument ( ) ; doc . putProperty ( CustomUndoDocument . class , new CustomUndoDocument ( ) { @ org . netbeans . api . editor . Override public void addUndoableEdit ( UndoableEdit edit ) { editAdded [ 0 ] \u003d true ; } } ) ; final EditorCaret editorCaret \u003d new EditorCaret ( ) ; SwingUtilities . invokeAndWait ( new Runnable ( ) { @ org . netbeans . api . editor . Override public void run ( ) { pane . setCaret ( editorCaret ) ; EditorUtilities . addCaretUndoableEdit ( doc , editorCaret ) ; } } ) ; assertTrue ( editAdd [ j ] ) ; }  }\r\n",
  "focal method": "class Y{ public void addCaretUndoableEdit( Document  var24678 , Caret  var24678 ) { CustomUndoDocument customUndoDocument \u003d LineDocumentUtils . as ( doc , CustomUndoDocument . class ) ; if ( customUndoDocument !\u003d null ) { UndoableEdit caretUndoEdit \u003d CaretUndo . createCaretUndoEdit ( caret , doc ) ; if ( caretUndoEdit !\u003d null ) { customUndoDocument . addUndoableEdit ( caretUndoEdit ) ; } } } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "4_0.txt",
  "assertion": "assertEquals ( 1000, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_1.txt",
  "assertion": "assertEquals ( 0, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_10.txt",
  "assertion": "assertEquals ( 1000, 0. 0Q time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Q time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_11.txt",
  "assertion": "assertEquals ( 1000, 1. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 1. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_12.txt",
  "assertion": "assertEquals ( 10, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 10, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_13.txt",
  "assertion": "assertEquals ( 50, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 50, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_14.txt",
  "assertion": "assertEquals ( 1000, 0. 0Timeout Time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Timeout Time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_15.txt",
  "assertion": "assertEquals ( 0, 0. 0Q time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Q time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_16.txt",
  "assertion": "assertEquals ( 1000, 0. 0Time Time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Time Time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_17.txt",
  "assertion": "assertEquals ( 1, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_18.txt",
  "assertion": "assertEquals ( 0, 1. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 1. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_19.txt",
  "assertion": "assertEquals ( 100, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 100, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_2.txt",
  "assertion": "assertEquals ( 1000, 0. 0Timeout time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Timeout time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_20.txt",
  "assertion": "assertEquals ( 0, 0. 0Timeout Time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Timeout Time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_21.txt",
  "assertion": "assertEquals ( 5, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 5, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_22.txt",
  "assertion": "assertEquals ( 0, 0. 0Time Time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Time Time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_23.txt",
  "assertion": "assertEquals ( 15, 0. 0 wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 15, 0. 0 wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_24.txt",
  "assertion": "assertEquals ( 1000, 1. 0Timeout time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 1. 0Timeout time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_25.txt",
  "assertion": "assertEquals ( 10, 0. 0Timeout time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 10, 0. 0Timeout time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_26.txt",
  "assertion": "assertEquals ( 50, 0. 0Timeout time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 50, 0. 0Timeout time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_27.txt",
  "assertion": "assertEquals ( 1000, 1. 0Time time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 1. 0Time time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_28.txt",
  "assertion": "assertEquals ( 10, 0. 0Time time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 10, 0. 0Time time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_29.txt",
  "assertion": "assertEquals ( 50, 0. 0Time time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 50, 0. 0Time time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_3.txt",
  "assertion": "assertEquals ( 1000, 0. 0Time time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0Time time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_4.txt",
  "assertion": "assertEquals ( 0, 0. 0Timeout time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Timeout time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_5.txt",
  "assertion": "assertEquals ( 0, 0. 0Time time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0Time time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_6.txt",
  "assertion": "assertEquals ( 1000, 0. 0 wait Time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0 wait Time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_7.txt",
  "assertion": "assertEquals ( 1000, 0. 0 Wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1000, 0. 0 Wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_8.txt",
  "assertion": "assertEquals ( 0, 0. 0 wait Time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0 wait Time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_9.txt",
  "assertion": "assertEquals ( 0, 0. 0 Wait time ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0. 0 Wait time ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getWaitTime() { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_0.txt",
  "assertion": "assertEquals ( profile. user id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. user id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_1.txt",
  "assertion": "assertEquals ( profile. client id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. client id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_10.txt",
  "assertion": "assertEquals ( profile. userUser ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userUser ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_11.txt",
  "assertion": "assertEquals ( profile. token ID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. token ID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_12.txt",
  "assertion": "assertEquals ( profile. get id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. get id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_13.txt",
  "assertion": "assertEquals ( profile. session ID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. session ID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_14.txt",
  "assertion": "assertEquals ( profile. authent id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. authent id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_15.txt",
  "assertion": "assertEquals ( profile. authentication ID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. authentication ID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_16.txt",
  "assertion": "assertEquals ( profile. auth ID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. auth ID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_17.txt",
  "assertion": "assertEquals ( profile. userMe ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userMe ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_18.txt",
  "assertion": "assertEquals ( profile. userId ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userId ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_19.txt",
  "assertion": "assertEquals ( profile. login ID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. login ID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_2.txt",
  "assertion": "assertEquals ( profile. token id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. token id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_20.txt",
  "assertion": "assertEquals ( profile. userLogin ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userLogin ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_21.txt",
  "assertion": "assertEquals ( profile. access id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. access id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_22.txt",
  "assertion": "assertEquals ( profile. u id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. u id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_23.txt",
  "assertion": "assertEquals ( profile. userToken ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userToken ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_24.txt",
  "assertion": "assertEquals ( profile. to id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. to id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_25.txt",
  "assertion": "assertEquals ( profile. clientid ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. clientid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_26.txt",
  "assertion": "assertEquals ( profile. userID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_27.txt",
  "assertion": "assertEquals ( profile. is id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. is id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_28.txt",
  "assertion": "assertEquals ( profile. user Id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. user Id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_29.txt",
  "assertion": "assertEquals ( profile. clientUser ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. clientUser ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_3.txt",
  "assertion": "assertEquals ( profile. user ID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. user ID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_4.txt",
  "assertion": "assertEquals ( profile. session id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. session id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_5.txt",
  "assertion": "assertEquals ( profile. authentication id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. authentication id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_6.txt",
  "assertion": "assertEquals ( profile. auth id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. auth id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_7.txt",
  "assertion": "assertEquals ( profile. login id ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. login id ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_8.txt",
  "assertion": "assertEquals ( profile. userid ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. userid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_9.txt",
  "assertion": "assertEquals ( profile. client ID ( ) )\r\n",
  "test": "class X {public void testAuthentication ( ) { final DirectBearerAuthClient client \u003d new DirectBearerAuthClient ( new SimpleTestTokenAuthenticator ( ) ) ; final MockWebContext context \u003d MockWebContext . create ( ) ; context . AUTHORIZATION_HEADER . addRequestHeader ( ( ( org . pac4j . core . context . HttpConstants . BEARER_HEADER_PREFIX ) + ( TOKEN ) ) ) ; final TokenCredentials credentials \u003d client . getCredentials ( context ) . get ( ) ; final CommonProfile profile \u003d ( ( CommonProfile ) ( client . getUserProfile ( credentials , context ) . get ( ) ) ) ; assertEquals ( profile. client ID ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getId() { return id ; } }\r\n",
  "truth": "assertEquals ( profile. getId ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "51_0.txt",
  "assertion": "assertEquals ( expecting, expecting. template ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. template ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_1.txt",
  "assertion": "assertEquals ( expecting, expecting. weather ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. weather ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_10.txt",
  "assertion": "assertEquals ( expecting, expecting. shelter ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. shelter ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_11.txt",
  "assertion": "assertEquals ( expecting, expecting. report ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. report ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_12.txt",
  "assertion": "assertEquals ( expecting, expecting. write ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. write ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_13.txt",
  "assertion": "assertEquals ( expecting, expecting. render ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. render ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "render",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_14.txt",
  "assertion": "assertEquals ( expecting, expecting. prepare ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. prepare ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_15.txt",
  "assertion": "assertEquals ( expecting, expecting. rend ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. rend ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_16.txt",
  "assertion": "assertEquals ( expecting, expecting. dress ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. dress ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_17.txt",
  "assertion": "assertEquals ( expecting, expecting. tag ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. tag ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_18.txt",
  "assertion": "assertEquals ( expecting, expecting. apply ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. apply ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_19.txt",
  "assertion": "assertEquals ( expecting, expecting. paint ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. paint ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_2.txt",
  "assertion": "assertEquals ( expecting, expecting. html ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. html ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_20.txt",
  "assertion": "assertEquals ( expecting, expecting. rear ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. rear ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_21.txt",
  "assertion": "assertEquals ( expecting, expecting. print ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. print ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_22.txt",
  "assertion": "assertEquals ( expecting, expecting. rendered ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. rendered ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_23.txt",
  "assertion": "assertEquals ( expecting, expecting. display ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. display ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_24.txt",
  "assertion": "assertEquals ( expecting, expecting. styl ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. styl ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_25.txt",
  "assertion": "assertEquals ( expecting, expecting. renders ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. renders ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_26.txt",
  "assertion": "assertEquals ( expecting, expecting. gore ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. gore ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_27.txt",
  "assertion": "assertEquals ( expect, expecting. template ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expect, expecting. template ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_28.txt",
  "assertion": "assertEquals ( expecting, expect. template ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expect. template ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_29.txt",
  "assertion": "assertEquals ( expecting, expecting.render ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting.render ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "render",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_3.txt",
  "assertion": "assertEquals ( expecting, expecting. get ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. get ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_4.txt",
  "assertion": "assertEquals ( expecting, expecting. gender ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. gender ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_5.txt",
  "assertion": "assertEquals ( expecting, expecting. replace ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. replace ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_6.txt",
  "assertion": "assertEquals ( expecting, expecting. rendering ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. rendering ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_7.txt",
  "assertion": "assertEquals ( expecting, expecting. treatment ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. treatment ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_8.txt",
  "assertion": "assertEquals ( expecting, expecting. repr ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. repr ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "51_9.txt",
  "assertion": "assertEquals ( expecting, expecting. group ( ) )\r\n",
  "test": "class X {public void testLastWithLengthOneListAttributeOp ( ) { ST e \u003d new ST ( \"\u003clast(names)\u003e\" ) ; e . add ( \"names\" , new ArrayList \u003c String \u003e ( ) { { add ( \"Ter\" ) ; } } ) ; String expecting \u003d \"Ter\" ; assertEquals ( expecting, expecting. group ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void render() { return Locale . render ( Locale . getDefault ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expecting, e. render ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expecting",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "52_0.txt",
  "assertion": "assertFalse ( valid assidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( valid assidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_1.txt",
  "assertion": "assertFalse ( validPidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validPidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_10.txt",
  "assertion": "assertFalse ( validTest assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validTest assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_11.txt",
  "assertion": "assertFalse ( validPos assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validPos assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_12.txt",
  "assertion": "assertFalse ( valid asser )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( valid asser ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_13.txt",
  "assertion": "assertFalse ( validUnidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validUnidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_14.txt",
  "assertion": "assertFalse ( validAll assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validAll assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_15.txt",
  "assertion": "assertFalse ( validIs assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validIs assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_16.txt",
  "assertion": "assertFalse ( valid Ass assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( valid Ass assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_17.txt",
  "assertion": "assertFalse ( validAlidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validAlidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_18.txt",
  "assertion": "assertFalse ( validass assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validass assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_19.txt",
  "assertion": "assertFalse ( validUsidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validUsidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_2.txt",
  "assertion": "assertFalse ( validTestidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validTestidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_20.txt",
  "assertion": "assertFalse ( validPer )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validPer ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_21.txt",
  "assertion": "assertFalse ( validTester )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validTester ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_22.txt",
  "assertion": "assertFalse ( validAssidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validAssidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_23.txt",
  "assertion": "assertFalse ( validClassidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validClassidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_24.txt",
  "assertion": "assertFalse ( validGuidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validGuidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_25.txt",
  "assertion": "assertFalse ( validAsidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validAsidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_26.txt",
  "assertion": "assertFalse ( valid assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( valid assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_27.txt",
  "assertion": "assertFalse ( validPoser )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validPoser ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_28.txt",
  "assertion": "assertFalse ( validDefidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validDefidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_29.txt",
  "assertion": "assertFalse ( valid assign )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( valid assign ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_3.txt",
  "assertion": "assertFalse ( valid ass assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( valid ass assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_4.txt",
  "assertion": "assertFalse ( validPosidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validPosidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_5.txt",
  "assertion": "assertFalse ( validAllidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validAllidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_6.txt",
  "assertion": "assertFalse ( validIsidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validIsidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_7.txt",
  "assertion": "assertFalse ( valid Assidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( valid Assidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_8.txt",
  "assertion": "assertFalse ( validassidate )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validassidate ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_9.txt",
  "assertion": "assertFalse ( validP assert )\r\n",
  "test": "class X {public void testCreateCRLException ( ) { String crlfile \u003d ( strFilePath ) + \"/ssl/server.p12\" ; boolean validAssert \u003d true ; try { new MockUp \u003c CertificateFactory \u003e ( ) { @ mockit . Mock public final CertificateFactory getInstance ( String type ) throws CertificateException { throw new CertificateException ( ) ; } } ; KeyStoreUtil . createCRL ( crlfile ) ; } catch ( Exception e ) { validAssert \u003d false ; } assertFalse ( validP assert ) ; }  }\r\n",
  "focal method": "class Y{ public void createCRL( String  var24678 ) { InputStream is \u003d null ; try { CertificateFactory cf \u003d CertificateFactory . getInstance ( \"X.509\" ) ; is \u003d new FileInputStream ( crlfile ) ; Collection c \u003d cf . generateCRLs ( is ) ; CRL [ ] crls \u003d ( ( CRL [ ] ) ( c . toArray ( new CRL [ c . size ( ) ] ) ) ) ; return crls ; } catch ( CertificateException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecert\u003csp\u003efile.\" ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( \"crl\u003csp\u003efile\u003csp\u003enot\u003csp\u003efound.\" ) ; } catch ( CRLException e ) { throw new IllegalArgumentException ( \"bad\u003csp\u003ecrl\u003csp\u003efile.\" ) ; } finally { if ( is !\u003d null ) { try { is . close ( ) ; } catch ( IOException e ) { KeyStoreUtil . ignore ( ) ; } } } } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_0.txt",
  "assertion": "assertNull ( ec. e value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. e value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_1.txt",
  "assertion": "assertNull ( ec. pop value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. pop value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_10.txt",
  "assertion": "assertNull ( ec. to value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. to value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_11.txt",
  "assertion": "assertNull ( ec. s value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. s value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_12.txt",
  "assertion": "assertNull ( ec. int value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. int value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_13.txt",
  "assertion": "assertNull ( ec. current value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. current value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_14.txt",
  "assertion": "assertNull ( ec. _ value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. _ value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_15.txt",
  "assertion": "assertNull ( ec. read value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. read value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_16.txt",
  "assertion": "assertNull ( ec. eDefault ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eDefault ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "53_17.txt",
  "assertion": "assertNull ( ec. got value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. got value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_18.txt",
  "assertion": "assertNull ( ec. $ value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. $ value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_19.txt",
  "assertion": "assertNull ( ec. l value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. l value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_2.txt",
  "assertion": "assertNull ( ec. is value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. is value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_20.txt",
  "assertion": "assertNull ( ec. eKey ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eKey ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "53_21.txt",
  "assertion": "assertNull ( ec. eException ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eException ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "53_22.txt",
  "assertion": "assertNull ( ec. return value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. return value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_23.txt",
  "assertion": "assertNull ( ec. eNull ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eNull ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "53_24.txt",
  "assertion": "assertNull ( ec. un value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. un value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_25.txt",
  "assertion": "assertNull ( ec. float value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. float value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_26.txt",
  "assertion": "assertNull ( ec. m value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. m value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_27.txt",
  "assertion": "assertNull ( ec. eType ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. eType ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "53_28.txt",
  "assertion": "assertNull ( ec. popDefault ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. popDefault ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "53_29.txt",
  "assertion": "assertNull ( ec. evalue ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. evalue ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "53_3.txt",
  "assertion": "assertNull ( ec. g value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. g value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_4.txt",
  "assertion": "assertNull ( ec. get value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. get value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_5.txt",
  "assertion": "assertNull ( ec. n value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. n value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_6.txt",
  "assertion": "assertNull ( ec. p value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. p value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_7.txt",
  "assertion": "assertNull ( ec. as value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. as value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_8.txt",
  "assertion": "assertNull ( ec. the value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. the value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "53_9.txt",
  "assertion": "assertNull ( ec. set value ( ) )\r\n",
  "test": "class X {public void testAbstractClassDefaultNull ( ) { EmptyAbstractClassDefaultNull ec \u003d cof . build ( EmptyAbstractClassDefaultNull . class ) ; assertNull ( ec. set value ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getValue() { return value ; } }\r\n",
  "truth": "assertNull ( ec. getValue ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_0.txt",
  "assertion": "assertEquals ( 1, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_1.txt",
  "assertion": "assertEquals ( 2, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 2, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_10.txt",
  "assertion": "assertEquals ( 1, 1 1 1 1000 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 1000 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_11.txt",
  "assertion": "assertEquals ( 3, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 3, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_12.txt",
  "assertion": "assertEquals ( 1, 3 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 3 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_13.txt",
  "assertion": "assertEquals ( 1, 1 1 1 3 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_14.txt",
  "assertion": "assertEquals ( 4, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 4, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_15.txt",
  "assertion": "assertEquals ( 1, 4 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 4 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_16.txt",
  "assertion": "assertEquals ( 1, 1 1 1 4 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 4 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_17.txt",
  "assertion": "assertEquals ( 1, 1 1 4 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 4 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_18.txt",
  "assertion": "assertEquals ( 5, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 5, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_19.txt",
  "assertion": "assertEquals ( 1, 5 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 5 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_2.txt",
  "assertion": "assertEquals ( 1, 2 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 2 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_20.txt",
  "assertion": "assertEquals ( 1, 1 1 1 5 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_21.txt",
  "assertion": "assertEquals ( 10000, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 10000, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_22.txt",
  "assertion": "assertEquals ( 1, 10000 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 10000 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_23.txt",
  "assertion": "assertEquals ( 200, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 200, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_24.txt",
  "assertion": "assertEquals ( 1, 200 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 200 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_25.txt",
  "assertion": "assertEquals ( log, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( log, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_26.txt",
  "assertion": "assertEquals ( 1, log 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, log 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_27.txt",
  "assertion": "assertEquals ( 1, 1 log 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 log 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_28.txt",
  "assertion": "assertEquals ( 9, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 9, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_29.txt",
  "assertion": "assertEquals ( 1, 9 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 9 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_3.txt",
  "assertion": "assertEquals ( 1, 1 1 2 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 2 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_4.txt",
  "assertion": "assertEquals ( 1, 1 1 1 2 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_5.txt",
  "assertion": "assertEquals ( 10, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 10, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_6.txt",
  "assertion": "assertEquals ( 1, 10 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 10 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_7.txt",
  "assertion": "assertEquals ( 1, 1 1 1 10 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1 1 1 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_8.txt",
  "assertion": "assertEquals ( 1000, 1 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1000, 1 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "54_9.txt",
  "assertion": "assertEquals ( 1, 1000 1 1 1 )\r\n",
  "test": "class X {public void testWriteStringRecordsOneEventPerBatch ( ) { DataGeneratorFormatConfig dataGeneratorFormatConfig \u003d new DataGeneratorFormatConfig ( ) ; dataGeneratorFormatConfig . textFieldPath \u003d \"/\" ; dataGeneratorFormatConfig . charset \u003d \"UTF-8\" ; dataGeneratorFormatConfig . textEmptyLineIfNull \u003d true ; FlumeTarget flumeTarget \u003d FlumeTestUtil . createFlumeTarget ( FlumeTestUtil . createDefaultFlumeConfig ( port , true ) , dataGeneratorFormatConfig ) ; TargetRunner targetRunner \u003d new Builder ( FlumeDTarget . class , flumeTarget ) . build ( ) ; targetRunner . runInit ( ) ; List \u003c Record \u003e logRecords \u003d FlumeTestUtil . createStringRecords ( ) ; targetRunner . runWrite ( logRecords ) ; targetRunner . runDestroy ( ) ; int totalFlumeEvents \u003d 0 ; Transaction transaction \u003d ch . getTransaction ( ) ; transaction . begin ( ) ; while ( ( ch . take ( ) ) !\u003d null ) { totalFlumeEvents ++ ; } transaction . commit ( ) ; transaction . close ( ) ; assertEquals ( 1, 1000 1 1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void close() { generator . close ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, totalFlumeEvents )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_0.txt",
  "assertion": "assertEquals ( ), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_1.txt",
  "assertion": "assertEquals (), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_10.txt",
  "assertion": "assertEquals ( 2, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 2, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_11.txt",
  "assertion": "assertEquals (+), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (+), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_12.txt",
  "assertion": "assertEquals ( null, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( null, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_13.txt",
  "assertion": "assertEquals (*), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (*), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_14.txt",
  "assertion": "assertEquals ()\", ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()\", ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_15.txt",
  "assertion": "assertEquals ( 1, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 1, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_16.txt",
  "assertion": "assertEquals (,), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (,), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_17.txt",
  "assertion": "assertEquals ()?, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()?, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_18.txt",
  "assertion": "assertEquals (\"), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (\"), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_19.txt",
  "assertion": "assertEquals ()\\, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()\\, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_2.txt",
  "assertion": "assertEquals ()), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ()), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_20.txt",
  "assertion": "assertEquals (?), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (?), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_21.txt",
  "assertion": "assertEquals ( 3, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 3, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_22.txt",
  "assertion": "assertEquals ( }, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( }, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_23.txt",
  "assertion": "assertEquals (),, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (),, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_24.txt",
  "assertion": "assertEquals ( false, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( false, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_25.txt",
  "assertion": "assertEquals (,, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (,, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_26.txt",
  "assertion": "assertEquals ( 10, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 10, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_27.txt",
  "assertion": "assertEquals ( ], ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ], ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_28.txt",
  "assertion": "assertEquals ( ), list )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), list ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_29.txt",
  "assertion": "assertEquals ( list, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( list, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_3.txt",
  "assertion": "assertEquals ( 0, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( 0, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_4.txt",
  "assertion": "assertEquals ( ), 0 )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_5.txt",
  "assertion": "assertEquals ( ), expected )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( ), expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_6.txt",
  "assertion": "assertEquals ( expected, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( expected, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_7.txt",
  "assertion": "assertEquals ( true, ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( true, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_8.txt",
  "assertion": "assertEquals (?), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals (?), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_9.txt",
  "assertion": "assertEquals ( )), ) )\r\n",
  "test": "class X {public void shouldListConstraintsForLabel ( ) { ConstraintRule rule1 \u003d uniquenessConstraintRule ( 0 , 1 , 1 , 0 ) ; ConstraintRule rule2 \u003d uniquenessConstraintRule ( 1 , 2 , 1 , 0 ) ; ConstraintRule rule3 \u003d nodePropertyExistenceConstraintRule ( 2 , 1 , 2 ) ; SchemaCache cache \u003d SchemaCacheTest . newSchemaCache ( ) ; cache . addSchemaRule ( rule1 ) ; cache . addSchemaRule ( rule2 ) ; cache . addSchemaRule ( rule3 ) ; Set \u003c ConstraintDescriptor \u003e listed \u003d asSet ( cache . constraintsForLabel ( 1 ) ) ; Set \u003c ConstraintDescriptor \u003e expected \u003d asSet ( rule1 . getConstraintDescriptor ( ) , rule3 . getConstraintDescriptor ( ) ) ; assertEquals ( )), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getConstraintDescriptor() { return descriptor ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_0.txt",
  "assertion": "assertNull ( g fun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_1.txt",
  "assertion": "assertNull ( gGun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gGun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_10.txt",
  "assertion": "assertNull ( gFac. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gFac. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_11.txt",
  "assertion": "assertNull ( gfun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gfun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_12.txt",
  "assertion": "assertNull ( gRun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gRun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_13.txt",
  "assertion": "assertNull ( g fun. gName ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gName ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_14.txt",
  "assertion": "assertNull ( gVal. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gVal. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_15.txt",
  "assertion": "assertNull ( gNum. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gNum. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_16.txt",
  "assertion": "assertNull ( g fun. gname ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gname ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_17.txt",
  "assertion": "assertNull ( gJs. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gJs. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_18.txt",
  "assertion": "assertNull ( gVar. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gVar. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_19.txt",
  "assertion": "assertNull ( g fun. gString ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gString ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_2.txt",
  "assertion": "assertNull ( gReg. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gReg. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_20.txt",
  "assertion": "assertNull ( gFunction. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gFunction. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_21.txt",
  "assertion": "assertNull ( gExec. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gExec. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_22.txt",
  "assertion": "assertNull (g fun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull (g fun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_23.txt",
  "assertion": "assertNull ( g fun. gUrl ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gUrl ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_24.txt",
  "assertion": "assertNull ( g fun. gDefault ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gDefault ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_25.txt",
  "assertion": "assertNull ( g fun. gFilter ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gFilter ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_26.txt",
  "assertion": "assertNull ( gp fun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gp fun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_27.txt",
  "assertion": "assertNull ( gMod. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gMod. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_28.txt",
  "assertion": "assertNull ( G fun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( G fun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_29.txt",
  "assertion": "assertNull ( gDone. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gDone. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_3.txt",
  "assertion": "assertNull ( gUt. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gUt. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_4.txt",
  "assertion": "assertNull ( g Fun. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g Fun. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_5.txt",
  "assertion": "assertNull ( g fun. gN ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gN ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_6.txt",
  "assertion": "assertNull ( gF. g name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( gF. g name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_7.txt",
  "assertion": "assertNull ( g fun. gId ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gId ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_8.txt",
  "assertion": "assertNull ( g fun. g Name ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. g Name ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_9.txt",
  "assertion": "assertNull ( g fun. gParent ( ) )\r\n",
  "test": "class X {public void testCreateEmptyNameGlobalFunction ( ) { GlobalFunctionEntity gFun \u003d new GlobalFunctionEntity ( ) ; gFun . setName ( \"\" ) ; assertNull ( g fun. gParent ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getName() { return name ; } }\r\n",
  "truth": "assertNull ( gFun. getName ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "58_0.txt",
  "assertion": "assertEquals ( true, filter filter 2. add ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. add ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_1.txt",
  "assertion": "assertEquals ( true, filter filter 2. matches ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. matches ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_10.txt",
  "assertion": "assertEquals ( hash, 255 filter 2. add ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, 255 filter 2. add ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_11.txt",
  "assertion": "assertEquals ( hash, filter filter 2. add ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, filter filter 2. add ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_12.txt",
  "assertion": "assertEquals ( true, 255 filter 2. contains ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, 255 filter 2. contains ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_13.txt",
  "assertion": "assertEquals ( true, 255 filter 2. matches ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, 255 filter 2. matches ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_14.txt",
  "assertion": "assertEquals ( hash, 255 filter 2. matches ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, 255 filter 2. matches ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_15.txt",
  "assertion": "assertEquals ( true, filter filter 2. contains ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. contains ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_16.txt",
  "assertion": "assertEquals ( hash, filter filter 2. contains ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, filter filter 2. contains ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_17.txt",
  "assertion": "assertEquals ( hash, filter filter 2. matches ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, filter filter 2. matches ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_18.txt",
  "assertion": "assertEquals ( hash, 255 filter 2. add ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, 255 filter 2. add ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_19.txt",
  "assertion": "assertEquals ( true, 255 filter 2. contains ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, 255 filter 2. contains ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_2.txt",
  "assertion": "assertEquals ( true, 255 filter 2. add ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, 255 filter 2. add ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_20.txt",
  "assertion": "assertEquals ( hash, 255 filter 2. contains ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, 255 filter 2. contains ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_21.txt",
  "assertion": "assertEquals ( hash, 255 filter 2. matches ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, 255 filter 2. matches ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_22.txt",
  "assertion": "assertEquals ( hash, filter filter 2. contains ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, filter filter 2. contains ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_23.txt",
  "assertion": "assertEquals ( hash, 255 filter 2. contains ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, 255 filter 2. contains ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_24.txt",
  "assertion": "assertEquals ( 1, filter filter 2. add ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( 1, filter filter 2. add ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_25.txt",
  "assertion": "assertEquals ( true, filter filter 2. add ( 1 ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. add ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_26.txt",
  "assertion": "assertEquals ( true, filter filter 2. exists ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. exists ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_27.txt",
  "assertion": "assertEquals ( false, filter filter 2. add ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( false, filter filter 2. add ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_28.txt",
  "assertion": "assertEquals ( true, filter filter 2. matches ( 1 ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. matches ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_29.txt",
  "assertion": "assertEquals ( 1, filter filter 2. matches ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( 1, filter filter 2. matches ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_3.txt",
  "assertion": "assertEquals ( true, filter filter 2. add ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. add ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_4.txt",
  "assertion": "assertEquals ( hash, filter filter 2. add ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, filter filter 2. add ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_5.txt",
  "assertion": "assertEquals ( true, 255 filter 2. matches ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, 255 filter 2. matches ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_6.txt",
  "assertion": "assertEquals ( true, filter filter 2. contains ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. contains ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_7.txt",
  "assertion": "assertEquals ( true, filter filter 2. matches ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, filter filter 2. matches ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_8.txt",
  "assertion": "assertEquals ( hash, filter filter 2. matches ( true ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( hash, filter filter 2. matches ( true ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_9.txt",
  "assertion": "assertEquals ( true, 255 filter 2. add ( hash ) )\r\n",
  "test": "class X {public void testOneBloomfilter1 ( ) { SimpleBloomFilter \u003c Number160 \u003e bloomFilter \u003d new SimpleBloomFilter \u003c Number160 \u003e ( 1024 , 1000 ) ; Number160 hash \u003d new Number160 ( \"0x41844ffc9aeea30aefd1e0aff687dacdf1c6f36e\" ) ; bloomFilter . add ( hash ) ; ByteBuf buf \u003d Unpooled . buffer ( ) ; bloomFilter . encode ( buf ) ; SimpleBloomFilter \u003c Number160 \u003e bloomFilter2 \u003d new SimpleBloomFilter \u003c Number160 \u003e ( buf ) ; assertEquals ( true, 255 filter 2. add ( hash ) ) ; }  }\r\n",
  "focal method": "class Y{ public void contains( Number640  var24678 ) { return dataMap . containsKey ( key ) ; } }\r\n",
  "truth": "assertEquals ( true, bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "5_0.txt",
  "assertion": "assertEquals ( date, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "5_1.txt",
  "assertion": "assertEquals ( avg, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( avg, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "5_10.txt",
  "assertion": "assertEquals ( today, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( today, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_11.txt",
  "assertion": "assertEquals ( date, today )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, today ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_12.txt",
  "assertion": "assertEquals ( age, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( age, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_13.txt",
  "assertion": "assertEquals ( date, age )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, age ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_14.txt",
  "assertion": "assertEquals ( average, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( average, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_15.txt",
  "assertion": "assertEquals ( date, average )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, average ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_16.txt",
  "assertion": "assertEquals ( max, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( max, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_17.txt",
  "assertion": "assertEquals ( date, max )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, max ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_18.txt",
  "assertion": "assertEquals ( 7, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 7, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_19.txt",
  "assertion": "assertEquals ( date, 7 )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, 7 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_2.txt",
  "assertion": "assertEquals ( date, avg )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, avg ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "avg",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "5_20.txt",
  "assertion": "assertEquals ( birthday, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( birthday, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_21.txt",
  "assertion": "assertEquals ( date, birthday )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, birthday ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_22.txt",
  "assertion": "assertEquals ( 42, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 42, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_23.txt",
  "assertion": "assertEquals ( date, 42 )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, 42 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_24.txt",
  "assertion": "assertEquals ( min, avg )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( min, avg ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "avg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_25.txt",
  "assertion": "assertEquals ( avg, min )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( avg, min ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "avg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_26.txt",
  "assertion": "assertEquals ( dat, avg )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( dat, avg ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "avg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_27.txt",
  "assertion": "assertEquals ( avg, dat )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( avg, dat ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "avg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_28.txt",
  "assertion": "assertEquals ( 10, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 10, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_29.txt",
  "assertion": "assertEquals ( date, 10 )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_3.txt",
  "assertion": "assertEquals ( avg, avg )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( avg, avg ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "5_4.txt",
  "assertion": "assertEquals ( min, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( min, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_5.txt",
  "assertion": "assertEquals ( date, min )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, min ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_6.txt",
  "assertion": "assertEquals ( dat, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( dat, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_7.txt",
  "assertion": "assertEquals ( date, dat )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, dat ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_8.txt",
  "assertion": "assertEquals ( now, date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( now, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "5_9.txt",
  "assertion": "assertEquals ( date, now )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, now ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "60_0.txt",
  "assertion": "assertFalse ( bid first. compare ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_1.txt",
  "assertion": "assertFalse ( bid 1. compare ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_10.txt",
  "assertion": "assertFalse ( bidId. is ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bidId. is ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_11.txt",
  "assertion": "assertFalse ( bid 1. compare ( bid 2 ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bid 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_12.txt",
  "assertion": "assertFalse ( bid first. is ( bid 2 ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bid 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_13.txt",
  "assertion": "assertFalse ( bid first. compare ( bidB ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bidB ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_14.txt",
  "assertion": "assertFalse ( bid 1. compare ( bid second ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bid second ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_15.txt",
  "assertion": "assertFalse ( bid first. is ( bid second ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bid second ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_16.txt",
  "assertion": "assertFalse ( bid2. compare ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid2. compare ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_17.txt",
  "assertion": "assertFalse ( bid 1. equal ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. equal ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_18.txt",
  "assertion": "assertFalse ( bid first. eq ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. eq ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_19.txt",
  "assertion": "assertFalse ( bid 1. is ( bid 2 ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. is ( bid 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_2.txt",
  "assertion": "assertFalse ( bid first. is ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_20.txt",
  "assertion": "assertFalse ( bidId. \u003d\u003d ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bidId. \u003d\u003d ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_21.txt",
  "assertion": "assertFalse ( bid first. compare ( bidb ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bidb ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_22.txt",
  "assertion": "assertFalse ( bid first. \u003d\u003d ( bid 2 ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. \u003d\u003d ( bid 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_23.txt",
  "assertion": "assertFalse ( bid 1. compare ( bidB ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. compare ( bidB ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_24.txt",
  "assertion": "assertFalse ( bid first. is ( bidB ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. is ( bidB ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_25.txt",
  "assertion": "assertFalse ( bid 1. is ( bid second ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. is ( bid second ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_26.txt",
  "assertion": "assertFalse ( bidId. compare ( bid 2 ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bidId. compare ( bid 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_27.txt",
  "assertion": "assertFalse ( bid first. \u003d\u003d ( bid second ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. \u003d\u003d ( bid second ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_28.txt",
  "assertion": "assertFalse ( bid first. equ ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. equ ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_29.txt",
  "assertion": "assertFalse ( bid2. is ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid2. is ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_3.txt",
  "assertion": "assertFalse ( bid 1. is ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. is ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_4.txt",
  "assertion": "assertFalse ( bid first. \u003d\u003d ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. \u003d\u003d ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_5.txt",
  "assertion": "assertFalse ( bidId. compare ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bidId. compare ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_6.txt",
  "assertion": "assertFalse ( bid first. compare ( bid 2 ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bid 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_7.txt",
  "assertion": "assertFalse ( bid first. compare ( bid second ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. compare ( bid second ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_8.txt",
  "assertion": "assertFalse ( bid 1. \u003d\u003d ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid 1. \u003d\u003d ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_9.txt",
  "assertion": "assertFalse ( bid first. equal ( bid ( ) )\r\n",
  "test": "class X {public void CreateBNode ( ) { BID bid1 \u003d dialect . createBNode ( ) ; BID bid2 \u003d dialect . createBNode ( ) ; assertFalse ( bid first. equal ( bid ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void equals( Object  var24678 ) { if ( o \u003d\u003d ( this ) ) { return true ; } else if ( o instanceof Year ) { return ( year ) \u003d\u003d ( ( ( Year ) ( o ) ) . year ) ; } else { return false ; } } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_0.txt",
  "assertion": "assertEquals ( null, null. 0 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_1.txt",
  "assertion": "assertEquals ( null, null. 2 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_10.txt",
  "assertion": "assertEquals ( null, null. 1 fileEmpty ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileEmpty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_11.txt",
  "assertion": "assertEquals ( null, null. 1 fileSet ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileSet ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_12.txt",
  "assertion": "assertEquals ( null, null. 0 files ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 files ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_13.txt",
  "assertion": "assertEquals ( null, null. 0 file count ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 file count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_14.txt",
  "assertion": "assertEquals ( null, null. 2 files ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 files ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_15.txt",
  "assertion": "assertEquals ( null, null. 2 file count ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 file count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_16.txt",
  "assertion": "assertEquals ( null, null. 1 files ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 files ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_17.txt",
  "assertion": "assertEquals ( null, null. 1 file count ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 file count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_18.txt",
  "assertion": "assertEquals ( 0, null. 0 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 0, null. 0 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_19.txt",
  "assertion": "assertEquals ( null, 0. 0 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 0. 0 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_2.txt",
  "assertion": "assertEquals ( null, null. 0 fileRule ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileRule ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_20.txt",
  "assertion": "assertEquals ( null, null. 0 FileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 FileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_21.txt",
  "assertion": "assertEquals ( 2, null. 0 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 2, null. 0 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_22.txt",
  "assertion": "assertEquals ( 0, null. 2 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 0, null. 2 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_23.txt",
  "assertion": "assertEquals ( null, 0. 2 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 0. 2 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_24.txt",
  "assertion": "assertEquals ( 0, null. 0 fileRule ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 0, null. 0 fileRule ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_25.txt",
  "assertion": "assertEquals ( null, 0. 0 fileRule ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 0. 0 fileRule ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_26.txt",
  "assertion": "assertEquals ( null, null. 2 FileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 FileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_27.txt",
  "assertion": "assertEquals ( null, null. 0 FileRule ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 FileRule ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_28.txt",
  "assertion": "assertEquals ( 1, null. 0 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( 1, null. 0 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_29.txt",
  "assertion": "assertEquals ( null, 1. 0 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, 1. 0 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_3.txt",
  "assertion": "assertEquals ( null, null. 1 fileRules ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileRules ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_4.txt",
  "assertion": "assertEquals ( null, null. 2 fileRule ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileRule ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_5.txt",
  "assertion": "assertEquals ( null, null. 1 fileRule ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 1 fileRule ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_6.txt",
  "assertion": "assertEquals ( null, null. 0 fileEmpty ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileEmpty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_7.txt",
  "assertion": "assertEquals ( null, null. 0 fileSet ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 0 fileSet ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_8.txt",
  "assertion": "assertEquals ( null, null. 2 fileEmpty ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileEmpty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_9.txt",
  "assertion": "assertEquals ( null, null. 2 fileSet ( ) )\r\n",
  "test": "class X {public void testReviewCmdBasicAllFilesDefault ( ) { EclipseUtils . createTestSourceFile ( testProject , \"/src/Test.js\" , \"function(arg)\u003csp\u003e{\u003csp\u003enotDeclaredVariable\u003csp\u003e\u003d\u003csp\u003e1;\u003csp\u003e}\" ) ; testProject . DEPTH_INFINITE . refreshLocal ( null ) ; IProjectProperties projectProperties \u003d PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . loadProjectProperties ( testProject ) ; RuleSet projectRuleSet \u003d projectProperties . getProjectRuleSet ( ) ; Rule emptyCatchBlock \u003d ReviewCmdTest . findRuleByName ( projectRuleSet , \"EmptyCatchBlock\" , \"java\" ) ; projectRuleSet \u003d RuleSetUtil . clearRules ( projectRuleSet ) ; projectRuleSet \u003d RuleSetUtil . addRule ( projectRuleSet , emptyCatchBlock ) ; projectProperties . setProjectRuleSet ( projectRuleSet ) ; PMDPlugin . getDefault ( ) . PMDPlugin . getPropertiesManager ( ) . PMDPlugin . storeProjectProperties ( projectProperties ) ; final ReviewCodeCmd cmd \u003d new ReviewCodeCmd ( ) ; cmd . testProject . addResource ( ) ; cmd . performExecute ( ) ; cmd . join ( ) ; assertEquals ( null, null. 2 fileSet ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getFileCount() { return fileCount ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "63_0.txt",
  "assertion": "assertEquals ( \"test\", test.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_1.txt",
  "assertion": "assertEquals ( \"test\", 1.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", 1.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_10.txt",
  "assertion": "assertEquals ( \"bar\", test.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"bar\", test.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_11.txt",
  "assertion": "assertEquals ( \"10\", test.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"10\", test.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_12.txt",
  "assertion": "assertEquals ( \"test\", out.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", out.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_13.txt",
  "assertion": "assertEquals ( \"test\", test.gettext ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test.gettext ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_14.txt",
  "assertion": "assertEquals ( \"1\", 1.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"1\", 1.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_15.txt",
  "assertion": "assertEquals ( \"test\", 0.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", 0.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_16.txt",
  "assertion": "assertEquals ( \"test\", 1.getValue ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", 1.getValue ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_17.txt",
  "assertion": "assertEquals ( \"2\", 1.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"2\", 1.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_18.txt",
  "assertion": "assertEquals ( \"test\", is.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", is.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_19.txt",
  "assertion": "assertEquals ( \"test\", 1.getMessage ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", 1.getMessage ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_2.txt",
  "assertion": "assertEquals ( \"test\", 1000.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", 1000.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_20.txt",
  "assertion": "assertEquals ( \"test\", true.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", true.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_21.txt",
  "assertion": "assertEquals ( \"test\", test.getResponse ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test.getResponse ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_22.txt",
  "assertion": "assertEquals ( \"test\", message.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", message.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_23.txt",
  "assertion": "assertEquals ( \"test\", 1.getLong ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", 1.getLong ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_24.txt",
  "assertion": "assertEquals ( \"test\", test. endT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test. endT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_25.txt",
  "assertion": "assertEquals ( \"foo\", 1.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"foo\", 1.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_26.txt",
  "assertion": "assertEquals ( \"bar\", 1.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"bar\", 1.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_27.txt",
  "assertion": "assertEquals ( \"hello\", test.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"hello\", test.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_28.txt",
  "assertion": "assertEquals ( \"test\", test.getName ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test.getName ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_29.txt",
  "assertion": "assertEquals ( \"test\", test. messageT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test. messageT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_3.txt",
  "assertion": "assertEquals ( \"1\", test.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"1\", test.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_4.txt",
  "assertion": "assertEquals ( \"test\", test.getValue ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test.getValue ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_5.txt",
  "assertion": "assertEquals ( \"2\", test.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"2\", test.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_6.txt",
  "assertion": "assertEquals ( \"test\", test.getMessage ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test.getMessage ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_7.txt",
  "assertion": "assertEquals ( \"test\", test.getLong ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", test.getLong ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "63_8.txt",
  "assertion": "assertEquals ( \"test\", 50.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"test\", 50.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_9.txt",
  "assertion": "assertEquals ( \"foo\", test.getT ( ) )\r\n",
  "test": "class X {public void JndiConnectTest ( ) { String cmdLine \u003d ( ( \"--jndi\u003csp\u003e/amqp/jndi.properties\u003csp\u003e-\" + ( co . nordlander . a . A . CMD_PUT ) ) + \"\\\"test\\\"\" ) + \"\u003csp\u003eTEST.QUEUE\" ; a . run ( cmdLine . split ( \"\u003csp\u003e\" ) ) ; MessageConsumer mc \u003d session . createConsumer ( testQueue ) ; TextMessage msg \u003d ( ( TextMessage ) ( mc . TEST_TIMEOUT . receive ( ) ) ) ; assertEquals ( \"foo\", test.getT ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void run( String [ ]  var24678 ) { Options opts \u003d createOptions ( ) ; if ( ( args . length ) \u003d\u003d 0 ) { HelpFormatter helpFormatter \u003d new HelpFormatter ( ) ; helpFormatter . printHelp ( \"java\u003csp\u003e-jar\u003csp\u003ea-\u003cversion\u003e-with-dependencies.jar\" , opts , true ) ; System . exit ( 0 ) ; } CommandLineParser cmdParser \u003d new PosixParser ( ) ; try { cmdLine \u003d cmdParser . parse ( opts , args ) ; if ( cmdLine . CMD_VERSION . hasOption ( ) ) { executeShowVersion ( ) ; return ; } Protocol protocol \u003d co . nordlander . a . A . Protocol . OpenWire ; if ( cmdLine . CMD_AMQP . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . AMQP ; } else if ( cmdLine . CMD_ARTEMIS_CORE . hasOption ( ) ) { protocol \u003d co . nordlander . a . A . Protocol . ArtemisCore ; } CMD_BROKER . connect ( cmdLine . CMD_BROKER . getOptionValue ( \"tcp://localhost:61616\" ) , cmdLine . CMD_USER . getOptionValue ( ) , cmdLine . CMD_PASS . getOptionValue ( ) , protocol , cmdLine . CMD_JNDI . getOptionValue ( \"\" ) , cmdLine . CMD_NO_TRANSACTION_SUPPORT . hasOption ( ) ) ; long startTime \u003d System . currentTimeMillis ( ) ; executeCommandLine ( cmdLine ) ; long stopTime \u003d System . currentTimeMillis ( ) ; long elapsedTime \u003d stopTime - startTime ; Long . output ( \"Operation\u003csp\u003ecompleted\u003csp\u003ein\u003csp\u003e\" , Long . toString ( elapsedTime ) , \"ms\u003csp\u003e(excluding\u003csp\u003econnect)\" ) ; } finally { try { if ( ( sess ) !\u003d null ) { sess . close ( ) ; } if ( ( conn ) !\u003d null ) { conn . close ( ) ; } } catch ( JMSException e2 ) { e2 . printStackTrace ( ) ; } } logger . debug ( \"Active\u003csp\u003ethreads\u003csp\u003e{}\" , Thread . activeCount ( ) ) ; logger . debug ( \"At\u003csp\u003ethe\u003csp\u003eend\u003csp\u003eof\u003csp\u003ethe\u003csp\u003eroad\" ) ; } }\r\n",
  "truth": "assertEquals ( \"test\", msg. getText ( ) )\r\n",
  "trivial_check": "finished",
  "stop parsing": "error in getTypeFromFM()",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "64_0.txt",
  "assertion": "assertEquals ( s s 2, SSL )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, SSL ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_1.txt",
  "assertion": "assertEquals ( s s 2, connection )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, connection ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_10.txt",
  "assertion": "assertEquals ( s s 2, 1 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_11.txt",
  "assertion": "assertEquals ( s s 2, 3 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_12.txt",
  "assertion": "assertEquals ( s s 0, SSL )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, SSL ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_13.txt",
  "assertion": "assertEquals ( s s 0, connection )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, connection ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_14.txt",
  "assertion": "assertEquals ( s s 0, 2 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_15.txt",
  "assertion": "assertEquals ( s s 2, 0 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_16.txt",
  "assertion": "assertEquals ( s s 2, 6 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 6 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_17.txt",
  "assertion": "assertEquals ( s s ), ) )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), ) ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_18.txt",
  "assertion": "assertEquals ( s s 2, \"\" )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_19.txt",
  "assertion": "assertEquals ( s s ), 1 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_2.txt",
  "assertion": "assertEquals ( s s 2, 2 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_20.txt",
  "assertion": "assertEquals ( s s 1, ) )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_21.txt",
  "assertion": "assertEquals ( s s 1, 1 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_22.txt",
  "assertion": "assertEquals ( s s ), 3 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_23.txt",
  "assertion": "assertEquals ( s s 1, 3 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_24.txt",
  "assertion": "assertEquals ( s s null, SSL )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s null, SSL ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_25.txt",
  "assertion": "assertEquals ( s s 2, 5 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_26.txt",
  "assertion": "assertEquals ( s s null, connection )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s null, connection ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_27.txt",
  "assertion": "assertEquals ( s s ), 0 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_28.txt",
  "assertion": "assertEquals ( s s 0, ) )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 0, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_29.txt",
  "assertion": "assertEquals ( s s 1, 0 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_3.txt",
  "assertion": "assertEquals ( s s ), SSL )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), SSL ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_4.txt",
  "assertion": "assertEquals ( s s ), connection )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), connection ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_5.txt",
  "assertion": "assertEquals ( s s 1, SSL )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, SSL ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_6.txt",
  "assertion": "assertEquals ( s s 1, connection )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, connection ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_7.txt",
  "assertion": "assertEquals ( s s ), 2 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s ), 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_8.txt",
  "assertion": "assertEquals ( s s 2, ) )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 2, ) ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_9.txt",
  "assertion": "assertEquals ( s s 1, 2 )\r\n",
  "test": "class X {public void testClientConfigCertificateVerification ( ) { boolean failureCaught \u003d false ; try { final Properties connectionProps \u003d new Properties ( ) ; connectionProps . ENABLE_TLS . setProperty ( \"true\" ) ; connectionProps . TRUSTSTORE_PATH . setProperty ( ) ; connectionProps . TRUSTSTORE_PASSWORD . setProperty ( \"drill123\" ) ; connectionProps . DISABLE_HOST_VERIFICATION . setProperty ( \"true\" ) ; DrillConfig sslConfig \u003d new DrillConfig ( DrillConfig . create ( cloneDefaultTestConfigProperties ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( true ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"JKS\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"drill123\" ) ) . DrillConfig . withValue ( ConfigValueFactory . fromAnyRef ( \"TLSv1.2\" ) ) ) ; updateTestCluster ( 1 , sslConfig , connectionProps ) ; } catch ( Exception e ) { failureCaught \u003d true ; } newConfig . updateTestCluster ( 1 ) ; assertEquals ( s s 1, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void updateTestCluster( int  var24678 , DrillConfig  var24678 , Properties  var24678 ) { Preconditions . checkArgument ( ( newDrillbitCount \u003e 0 ) , \"Number\u003csp\u003eof\u003csp\u003eDrillbits\u003csp\u003emust\u003csp\u003ebe\u003csp\u003eat\u003csp\u003eleast\u003csp\u003eone\" ) ; if ( ( ( org . apache . drill . test . BaseTestQuery . drillbitCount ) !\u003d newDrillbitCount ) || ( ( org . apache . drill . test . BaseTestQuery . config ) !\u003d null ) ) { try { BaseTestQuery . closeClient ( ) ; org . apache . drill . test . BaseTestQuery . drillbitCount \u003d newDrillbitCount ; if ( newConfig !\u003d null ) { org . apache . drill . test . BaseTestQuery . config \u003d newConfig ; } BaseTestQuery . openClient ( properties ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failure\u003csp\u003ewhile\u003csp\u003eupdating\u003csp\u003ethe\u003csp\u003etest\u003csp\u003eDrillbit\u003csp\u003ecluster.\" , e ) ; } } } }\r\n",
  "truth": "assertEquals ( failureCaught, true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "65_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_1.txt",
  "assertion": "assertEquals ( expected, result )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, result ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "65_10.txt",
  "assertion": "assertEquals (expected, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals (expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_11.txt",
  "assertion": "assertEquals ( null, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( null, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_12.txt",
  "assertion": "assertEquals ( expected, null )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, null ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_13.txt",
  "assertion": "assertEquals ( 0, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( 0, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_14.txt",
  "assertion": "assertEquals ( expected, 0 )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_15.txt",
  "assertion": "assertEquals ( 10, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( 10, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_16.txt",
  "assertion": "assertEquals ( \"\", expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( \"\", expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_17.txt",
  "assertion": "assertEquals ( expected, \"\" )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_18.txt",
  "assertion": "assertEquals ( unexpected, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( unexpected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_19.txt",
  "assertion": "assertEquals ( expected, unexpected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, unexpected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_2.txt",
  "assertion": "assertEquals ( result, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( result, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "65_20.txt",
  "assertion": "assertEquals ( found, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( found, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_21.txt",
  "assertion": "assertEquals ( expected, found )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, found ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_22.txt",
  "assertion": "assertEquals ( allowed, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( allowed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_23.txt",
  "assertion": "assertEquals ( expected, allowed )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, allowed ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_24.txt",
  "assertion": "assertEquals ( 3, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( 3, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_25.txt",
  "assertion": "assertEquals ( message, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( message, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_26.txt",
  "assertion": "assertEquals ( expected, message )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, message ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_27.txt",
  "assertion": "assertEquals ( expecting, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expecting, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_28.txt",
  "assertion": "assertEquals ( test, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( test, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_29.txt",
  "assertion": "assertEquals ( expected, test )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, test ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_3.txt",
  "assertion": "assertEquals ( expect, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expect, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_4.txt",
  "assertion": "assertEquals ( expected, expect )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, expect ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_5.txt",
  "assertion": "assertEquals (pected, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals (pected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_6.txt",
  "assertion": "assertEquals ( expected,pected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected,pected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_7.txt",
  "assertion": "assertEquals ( expectation, expected )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expectation, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_8.txt",
  "assertion": "assertEquals ( expected, expectation )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( expected, expectation ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "65_9.txt",
  "assertion": "assertEquals ( result, result )\r\n",
  "test": "class X {public void testJSON ( ) { final String testMsg \u003d \"Test\u003csp\u003emessage\u003csp\u003e{}\" ; final StringMapMessage msg \u003d new StringMapMessage ( ) ; msg . put ( \"message\" , testMsg ) ; msg . put ( \"project\" , \"Log4j\" ) ; final String result \u003d msg . getFormattedMessage ( new String [ ] { \"JSON\" } ) ; final String expected \u003d \"{\\\"message\\\":\\\"Test\u003csp\u003emessage\u003csp\u003e{}\\\",\u003csp\u003e\\\"project\\\":\\\"Log4j\\\"}\" ; assertEquals ( result, result ) ; }  }\r\n",
  "focal method": "class Y{ public void getFormattedMessage( String [ ]  var24678 ) { if ( ( message ) !\u003d null ) { return message ; } return super . getFormattedMessage ( formats ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_0.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_1.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_10.txt",
  "assertion": "assertEquals ( reminders reminder reminder, reminder 2 reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder 2 reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_11.txt",
  "assertion": "assertEquals ( reminder reminders reminder, reminder 2 reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder 2 reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_12.txt",
  "assertion": "assertEquals ( reminder reminder reminders, reminder 2 reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder 2 reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_13.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminders 2 reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminders 2 reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_14.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder 2 reminder reminders reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminder reminders reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_15.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminders )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminder reminder reminders ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_16.txt",
  "assertion": "assertEquals ( reminders reminder reminder, reminder [ reminders reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder [ reminders reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_17.txt",
  "assertion": "assertEquals ( reminder reminders reminder, reminder [ reminders reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder [ reminders reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_18.txt",
  "assertion": "assertEquals ( reminder reminder reminders, reminder [ reminders reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder [ reminders reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_19.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminders [ reminders reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminders [ reminders reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_2.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder [ reminders reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminders reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_20.txt",
  "assertion": "assertEquals ( reminders reminders reminder, reminder [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminders reminder, reminder [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_21.txt",
  "assertion": "assertEquals ( reminders reminder reminders, reminder [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminders, reminder [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_22.txt",
  "assertion": "assertEquals ( reminder reminders reminders, reminder [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminders, reminder [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_23.txt",
  "assertion": "assertEquals ( reminders reminder reminder, reminders [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminders [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_24.txt",
  "assertion": "assertEquals ( reminder reminders reminder, reminders [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminders [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_25.txt",
  "assertion": "assertEquals ( reminder reminder reminders, reminders [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminders [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_26.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder [ reminders reminders reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminders reminders reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_27.txt",
  "assertion": "assertEquals ( reminders reminder reminder, reminder [ reminder reminders reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder [ reminder reminders reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_28.txt",
  "assertion": "assertEquals ( reminder reminders reminder, reminder [ reminder reminders reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder [ reminder reminders reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_29.txt",
  "assertion": "assertEquals ( reminder reminder reminders, reminder [ reminder reminders reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder [ reminder reminders reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_3.txt",
  "assertion": "assertEquals ( reminders reminder reminder, reminder [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminders reminder reminder, reminder [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_4.txt",
  "assertion": "assertEquals ( reminder reminders reminder, reminder [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminders reminder, reminder [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_5.txt",
  "assertion": "assertEquals ( reminder reminder reminders, reminder [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminders, reminder [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_6.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminders [ reminder reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminders [ reminder reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_7.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder [ reminder reminders reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminder reminders reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_8.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminders )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder [ reminder reminder reminders ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_9.txt",
  "assertion": "assertEquals ( reminder reminder reminder, reminder 2 reminders reminder reminder )\r\n",
  "test": "class X {public void find_all_reminders_on_monday_before_12 ( ) { Reminder reminder \u003d meetingDiary . MONDAY . createReminder ( 9 , 0 , \"Get\u003csp\u003eCoffee\" ) ; Reminder reminder2 \u003d meetingDiary . MONDAY . createReminder ( 11 , 0 , \"Get\u003csp\u003eSnack\" ) ; meetingDiary . MONDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; meetingDiary . TUESDAY . createReminder ( 13 , 0 , \"Get\u003csp\u003eLunch\" ) ; Set \u003c Reminder \u003e expectedReminders \u003d new HashSet ( ) ; expectedReminders . add ( reminder ) ; expectedReminders . add ( reminder2 ) ; Set \u003c Reminder \u003e mondayMorningReminders \u003d meetingDiary . MONDAY . getRemindersOnDayBefore ( 12 , 0 ) ; assertEquals ( reminder reminder reminder, reminder 2 reminders reminder reminder ) ; }  }\r\n",
  "focal method": "class Y{ public void getRemindersOnDayBefore( DayOfWeek  var24678 , int  var24678 , int  var24678 ) { return reminders . stream ( ) . filter ( ( p ) -\u003e ( p . getTime ( ) . getDayOfWeek ( ) ) \u003d\u003d dayOfWeek ) . LocalTime . filter ( ( p ) -\u003e p . getTime ( ) . toLocalTime ( ) . LocalTime . isBefore ( LocalTime . of ( hour , minute ) ) ) . LocalTime . collect ( Collectors . toSet ( ) ) ; } }\r\n",
  "truth": "assertEquals ( expectedReminders, mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_0.txt",
  "assertion": "assertTrue ( out. is empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. is empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_1.txt",
  "assertion": "assertTrue ( out. next empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. next empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_10.txt",
  "assertion": "assertTrue ( out. are empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. are empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_11.txt",
  "assertion": "assertTrue ( out. _ empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. _ empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_12.txt",
  "assertion": "assertTrue ( out. to empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. to empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_13.txt",
  "assertion": "assertTrue ( out. already empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. already empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_14.txt",
  "assertion": "assertTrue ( out. now empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. now empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_15.txt",
  "assertion": "assertTrue ( out. isaining ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. isaining ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "67_16.txt",
  "assertion": "assertTrue ( out. add empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. add empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_17.txt",
  "assertion": "assertTrue ( out. nextaining ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. nextaining ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "67_18.txt",
  "assertion": "assertTrue ( out. hasaining ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. hasaining ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "67_19.txt",
  "assertion": "assertTrue ( out. can empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. can empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_2.txt",
  "assertion": "assertTrue ( out. has empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. has empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_20.txt",
  "assertion": "assertTrue ( out. was empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. was empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_21.txt",
  "assertion": "assertTrue ( out. removeaining ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. removeaining ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "67_22.txt",
  "assertion": "assertTrue ( out. e empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. e empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_23.txt",
  "assertion": "assertTrue ( out.. empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out.. empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_24.txt",
  "assertion": "assertTrue ( out. dis empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. dis empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_25.txt",
  "assertion": "assertTrue ( out. allaining ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. allaining ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "67_26.txt",
  "assertion": "assertTrue ( out.!aining ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out.!aining ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_27.txt",
  "assertion": "assertTrue ( out. boolean empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. boolean empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_28.txt",
  "assertion": "assertTrue ( outs. is empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( outs. is empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_29.txt",
  "assertion": "assertTrue ( out. elements empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. elements empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_3.txt",
  "assertion": "assertTrue ( out. remove empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. remove empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_4.txt",
  "assertion": "assertTrue ( out. all empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. all empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_5.txt",
  "assertion": "assertTrue ( out.! empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out.! empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_6.txt",
  "assertion": "assertTrue ( out. empty empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. empty empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_7.txt",
  "assertion": "assertTrue ( out. signals empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. signals empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_8.txt",
  "assertion": "assertTrue ( out. contains empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. contains empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_9.txt",
  "assertion": "assertTrue ( out. any empty ( ) )\r\n",
  "test": "class X {public void testSkipOtherMessage ( ) { when ( fixMessage . getMessageType ( ) ) . HEARTBEAT . thenReturn ( ) ; ArrayList \u003c Object \u003e out \u003d new ArrayList ( ) ; handler . decode ( ctx , fixMessage , out ) ; verifyZeroInteractions ( ctx ) ; assertTrue ( out. any empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void decode( ChannelHandlerContext  var24678 , Object  var24678 , List  var24678 ) { try { if ( msg instanceof FixMessage ) { onMessage ( ctx , ( ( FixMessage ) ( msg ) ) , out ) ; } else if ( msg instanceof LogonEvent ) { onLogon ( ctx , ( ( LogonEvent ) ( msg ) ) ) ; } else if ( msg instanceof LogoutEvent ) { onLogout ( ctx , ( ( LogoutEvent ) ( msg ) ) ) ; } } finally { ReferenceCountUtil . release ( msg ) ; } } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "69_0.txt",
  "assertion": "assertEquals ( actual list item, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_1.txt",
  "assertion": "assertEquals ( actual list item, actual list item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actual list item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_10.txt",
  "assertion": "assertEquals ( actualValue item, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualValue item, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_11.txt",
  "assertion": "assertEquals ( actual list item, actualValue 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualValue 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_12.txt",
  "assertion": "assertEquals ( actualEvent item, actualEvent item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualEvent item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_13.txt",
  "assertion": "assertEquals ( actualView item, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualView item, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_14.txt",
  "assertion": "assertEquals ( actual list item, actualView 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualView 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_15.txt",
  "assertion": "assertEquals ( actualL item, actualEvent item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actualEvent item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_16.txt",
  "assertion": "assertEquals ( actualValue item, actual list item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualValue item, actual list item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_17.txt",
  "assertion": "assertEquals ( actual list item, actualValue item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualValue item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_18.txt",
  "assertion": "assertEquals ( actualView item, actual list item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualView item, actual list item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_19.txt",
  "assertion": "assertEquals ( actual list item, actualView item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualView item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_2.txt",
  "assertion": "assertEquals ( actualEvent item, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_20.txt",
  "assertion": "assertEquals ( actualEvent item, actualValue 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualValue 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_21.txt",
  "assertion": "assertEquals ( actualValue item, actualEvent 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualValue item, actualEvent 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_22.txt",
  "assertion": "assertEquals ( actualClass item, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualClass item, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_23.txt",
  "assertion": "assertEquals ( actual list item, actualClass 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualClass 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_24.txt",
  "assertion": "assertEquals ( actual list1, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list1, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_25.txt",
  "assertion": "assertEquals ( actualL item, actualValue 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actualValue 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_26.txt",
  "assertion": "assertEquals ( actualModel item, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualModel item, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_27.txt",
  "assertion": "assertEquals ( actual list item, actualModel 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualModel 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_28.txt",
  "assertion": "assertEquals ( actualEvent item, actualView 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualView 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_29.txt",
  "assertion": "assertEquals ( actualView item, actualEvent 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualView item, actualEvent 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_3.txt",
  "assertion": "assertEquals ( actual list item, actualEvent 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualEvent 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_4.txt",
  "assertion": "assertEquals ( actualL item, actual list 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actual list 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_5.txt",
  "assertion": "assertEquals ( actualEvent item, actual list item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actual list item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_6.txt",
  "assertion": "assertEquals ( actual list item, actualEvent item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actual list item, actualEvent item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_7.txt",
  "assertion": "assertEquals ( actualL item, actual list item )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actual list item ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_8.txt",
  "assertion": "assertEquals ( actualEvent item, actualEvent 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualEvent item, actualEvent 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "69_9.txt",
  "assertion": "assertEquals ( actualL item, actualEvent 0 )\r\n",
  "test": "class X {public void testMakeListItem ( ) { final DataTypeListItem expectedListItem \u003d mock ( DataTypeListItem . class ) ; doCallRealMethod ( ) . when ( dataTypeList ) . makeListItem ( ) ; when ( listItems . get ( ) ) . thenReturn ( expectedListItem ) ; final DataTypeListItem actualListItem \u003d dataTypeList . makeListItem ( ) ; verify ( expectedListItem ) . init ( eq ( dataTypeList ) ) ; assertEquals ( actualL item, actualEvent 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void init( ImportsWidgetView$Presenter  var24678 ) { this . presenter \u003d presenter ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_0.txt",
  "assertion": "assertEquals ( 1, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_1.txt",
  "assertion": "assertEquals ( 1, 0. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 0. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_10.txt",
  "assertion": "assertEquals ( 0, 2. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 2. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_11.txt",
  "assertion": "assertEquals ( 1, 0. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 0. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_12.txt",
  "assertion": "assertEquals ( 0, 1. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 1. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_13.txt",
  "assertion": "assertEquals ( 2, 2. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2, 2. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_14.txt",
  "assertion": "assertEquals ( 2, 1. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2, 1. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_15.txt",
  "assertion": "assertEquals ( 1, 2. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 2. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_16.txt",
  "assertion": "assertEquals ( 4, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 4, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_17.txt",
  "assertion": "assertEquals ( 1, 4. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 4. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_18.txt",
  "assertion": "assertEquals ( 6, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 6, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_19.txt",
  "assertion": "assertEquals ( 3, 0. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 3, 0. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_2.txt",
  "assertion": "assertEquals ( 0, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_20.txt",
  "assertion": "assertEquals ( 0, 3. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 3. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_21.txt",
  "assertion": "assertEquals ( 5, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 5, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_22.txt",
  "assertion": "assertEquals ( 0, 0. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 0. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_23.txt",
  "assertion": "assertEquals ( 3, 2. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 3, 2. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_24.txt",
  "assertion": "assertEquals ( 2, 3. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2, 3. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_25.txt",
  "assertion": "assertEquals ( 3, 1. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 3, 1. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_26.txt",
  "assertion": "assertEquals ( 1, 3. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 3. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_27.txt",
  "assertion": "assertEquals ( 7, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 7, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_28.txt",
  "assertion": "assertEquals ( 9, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 9, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_29.txt",
  "assertion": "assertEquals ( 2, 0. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2, 0. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_3.txt",
  "assertion": "assertEquals ( 2, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_4.txt",
  "assertion": "assertEquals ( 1, 2. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 2. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_5.txt",
  "assertion": "assertEquals ( 1, 1. 2 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 1. 2 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_6.txt",
  "assertion": "assertEquals ( 0, 0. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 0. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_7.txt",
  "assertion": "assertEquals ( 3, 1. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 3, 1. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_8.txt",
  "assertion": "assertEquals ( 1, 3. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, 3. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_9.txt",
  "assertion": "assertEquals ( 2, 0. 1 ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2, 0. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_0.txt",
  "assertion": "assertTrue ( query. execute ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. execute ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_1.txt",
  "assertion": "assertTrue ( query. result ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_10.txt",
  "assertion": "assertTrue ( query. take ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. take ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_11.txt",
  "assertion": "assertTrue ( query. expand ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. expand ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_12.txt",
  "assertion": "assertTrue ( query. accept ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. accept ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_13.txt",
  "assertion": "assertTrue ( query. retrieve ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. retrieve ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_14.txt",
  "assertion": "assertTrue ( query. analyze ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. analyze ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_15.txt",
  "assertion": "assertTrue ( query. eval ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. eval ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_16.txt",
  "assertion": "assertTrue ( query. decide ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. decide ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_17.txt",
  "assertion": "assertTrue ( statement. execute ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( statement. execute ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_18.txt",
  "assertion": "assertTrue ( query. examine ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. examine ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_19.txt",
  "assertion": "assertTrue ( command. execute ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( command. execute ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_2.txt",
  "assertion": "assertTrue ( query. expr ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. expr ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_20.txt",
  "assertion": "assertTrue ( query. calculate ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. calculate ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_21.txt",
  "assertion": "assertTrue ( query. evaluation ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. evaluation ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_22.txt",
  "assertion": "assertTrue ( statement. result ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( statement. result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_23.txt",
  "assertion": "assertTrue ( command. result ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( command. result ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_24.txt",
  "assertion": "assertTrue ( query. isEnabled ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. isEnabled ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_25.txt",
  "assertion": "assertTrue ( query. assess ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. assess ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_26.txt",
  "assertion": "assertTrue ( query. evaluating ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. evaluating ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_27.txt",
  "assertion": "assertTrue ( statement. expr ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( statement. expr ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_28.txt",
  "assertion": "assertTrue ( command. expr ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( command. expr ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_29.txt",
  "assertion": "assertTrue ( query. optimize ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. optimize ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_3.txt",
  "assertion": "assertTrue ( query. expression ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. expression ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_4.txt",
  "assertion": "assertTrue ( query. update ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. update ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_5.txt",
  "assertion": "assertTrue ( query. find ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. find ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_6.txt",
  "assertion": "assertTrue ( query. count ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_7.txt",
  "assertion": "assertTrue ( query. validate ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. validate ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_8.txt",
  "assertion": "assertTrue ( query. evaluate ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. evaluate ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "find type in focal method": "evaluate",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_9.txt",
  "assertion": "assertTrue ( query. apply ( ) )\r\n",
  "test": "class X {public void testAskNoBindings ( ) { String queryString \u003d \"PREFIX\u003csp\u003e:\u003csp\u003e\u003chttp://www.semanticweb.org/ontologies/2013/7/untitled-ontology-150#\u003e\u003csp\u003e\" + \"ASK\u003csp\u003eWHERE\u003csp\u003e{?x\u003csp\u003e:hasVal1\u003csp\u003e?v1\u003csp\u003e.}\" ; BooleanQuery query \u003d conn . SPARQL . prepareBooleanQuery ( queryString ) ; assertTrue ( query. apply ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluate() { TupleResultSet res ; OntopStatement stm ; long start \u003d System . currentTimeMillis ( ) ; try { stm \u003d conn . createStatement ( ) ; if ( ( this . queryTimeout ) \u003e 0 ) stm . queryTimeout . setQueryTimeout ( ) ; try { SelectQuery inputQuery \u003d factory . createSelectQuery ( getQueryString ( ) , getParsedQuery ( ) ) ; res \u003d stm . execute ( inputQuery ) ; } catch ( OntopQueryAnsweringException e ) { long end \u003d System . currentTimeMillis ( ) ; if ( ( ( this . queryTimeout ) \u003e 0 ) \u0026\u0026 ( ( end - start ) \u003e\u003d ( ( this . queryTimeout ) * 1000 ) ) ) { throw new QueryEvaluationException ( ( ( \"OntopTupleQuery\u003csp\u003etimed\u003csp\u003eout.\u003csp\u003eMore\u003csp\u003ethan\u003csp\u003e\" + ( this . queryTimeout ) ) + \"\u003csp\u003eseconds\u003csp\u003epassed\" ) , e ) ; } else throw e ; } List \u003c String \u003e signature \u003d res . getSignature ( ) ; return new OntopTupleQueryResult ( res , signature ) ; } catch ( QueryEvaluationException e ) { throw e ; } catch ( Exception e ) { throw new QueryEvaluationException ( e ) ; } } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "72_0.txt",
  "assertion": "assertEquals ( 0, objects. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, objects. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_1.txt",
  "assertion": "assertEquals ( 1, objects. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, objects. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_10.txt",
  "assertion": "assertEquals ( 2, object. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, object. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_11.txt",
  "assertion": "assertEquals ( 2, results. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, results. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_12.txt",
  "assertion": "assertEquals ( 0, classes. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, classes. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_13.txt",
  "assertion": "assertEquals ( 0, elements. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, elements. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_14.txt",
  "assertion": "assertEquals ( 0, items. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, items. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_15.txt",
  "assertion": "assertEquals ( 0, Objects. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, Objects. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_16.txt",
  "assertion": "assertEquals ( 1, classes. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, classes. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_17.txt",
  "assertion": "assertEquals ( 3, objects. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 3, objects. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_18.txt",
  "assertion": "assertEquals ( 2, classes. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, classes. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_19.txt",
  "assertion": "assertEquals ( 1, elements. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, elements. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_2.txt",
  "assertion": "assertEquals ( 2, objects. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, objects. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_20.txt",
  "assertion": "assertEquals ( 2, elements. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, elements. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_21.txt",
  "assertion": "assertEquals ( 1, items. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, items. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_22.txt",
  "assertion": "assertEquals ( 0, types. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, types. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_23.txt",
  "assertion": "assertEquals ( 2, items. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, items. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_24.txt",
  "assertion": "assertEquals ( 1, Objects. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, Objects. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_25.txt",
  "assertion": "assertEquals ( 2, Objects. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, Objects. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_26.txt",
  "assertion": "assertEquals ( 0, entities. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, entities. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_27.txt",
  "assertion": "assertEquals ( 1, types. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, types. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_28.txt",
  "assertion": "assertEquals ( 2, types. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, types. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_29.txt",
  "assertion": "assertEquals ( 0, collections. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, collections. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_3.txt",
  "assertion": "assertEquals ( 0, result. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, result. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_4.txt",
  "assertion": "assertEquals ( 0, object. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, object. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_5.txt",
  "assertion": "assertEquals ( 0, results. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 0, results. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_6.txt",
  "assertion": "assertEquals ( 1, result. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, result. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_7.txt",
  "assertion": "assertEquals ( 2, result. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 2, result. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_8.txt",
  "assertion": "assertEquals ( 1, object. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, object. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_9.txt",
  "assertion": "assertEquals ( 1, results. 1 ( ) )\r\n",
  "test": "class X {public void testIdentifiableSearch2 ( ) { Query query \u003d Query . from ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; Junction disjunction \u003d new Disjunction ( schemaService . getDynamicSchema ( DataElementGroup . class ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupA\" ) ) ; disjunction . Restrictions . add ( Restrictions . eq ( \"name\" , \"DataElementGroupB\" ) ) ; query . add ( disjunction ) ; List \u003c ? extends IdentifiableObject \u003e objects \u003d queryEngine . query ( query ) ; assertEquals ( 1, results. 1 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return messages . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_0.txt",
  "assertion": "assertNull ( match )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( match ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "match",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "73_1.txt",
  "assertion": "assertNull ( fit )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( fit ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_10.txt",
  "assertion": "assertNull ( search )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( search ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_11.txt",
  "assertion": "assertNull ( matched )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( matched ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_12.txt",
  "assertion": "assertNull ( replace )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( replace ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_13.txt",
  "assertion": "assertNull ( 0 )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_14.txt",
  "assertion": "assertNull ( mate )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( mate ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_15.txt",
  "assertion": "assertNull ( result )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( result ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_16.txt",
  "assertion": "assertNull ( target )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( target ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_17.txt",
  "assertion": "assertNull ( bet )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( bet ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_18.txt",
  "assertion": "assertNull ( 2 )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_19.txt",
  "assertion": "assertNull ( stop )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( stop ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_2.txt",
  "assertion": "assertNull ( matching )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( matching ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_20.txt",
  "assertion": "assertNull ( change )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( change ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_21.txt",
  "assertion": "assertNull ( pattern )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( pattern ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_22.txt",
  "assertion": "assertNull ( meet )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( meet ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_23.txt",
  "assertion": "assertNull ( break )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( break ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_24.txt",
  "assertion": "assertNull ( check )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( check ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_25.txt",
  "assertion": "assertNull ( test )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( test ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_26.txt",
  "assertion": "assertNull ( join )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( join ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_27.txt",
  "assertion": "assertNull ( 1 )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_28.txt",
  "assertion": "assertNull ( look )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( look ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_29.txt",
  "assertion": "assertNull ( suit )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( suit ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_3.txt",
  "assertion": "assertNull ( connect )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( connect ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_4.txt",
  "assertion": "assertNull ( null )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_5.txt",
  "assertion": "assertNull ( matches )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( matches ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_6.txt",
  "assertion": "assertNull ( compare )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( compare ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_7.txt",
  "assertion": "assertNull ( mismatch )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull ( mismatch ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_8.txt",
  "assertion": "assertNull (Match )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull (Match ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "73_9.txt",
  "assertion": "assertNull (match )\r\n",
  "test": "class X {public void testYeahSure ( ) { Isotopes isofac \u003d Isotopes . getInstance ( ) ; IIsotope match \u003d isofac . getIsotope ( \"H\" , 13.00001 , 1.0E-4 ) ; assertNull (match ) ; }  }\r\n",
  "focal method": "class Y{ public void getIsotope( String  var24678 , double  var24678 , double  var24678 ) { IIsotope ret \u003d null ; double minDiff \u003d Double . MAX_VALUE ; int elem \u003d Elements . ofString ( symbol ) . Elements . number ( ) ; List \u003c IIsotope \u003e isotopes \u003d this . isotopes [ elem ] ; if ( isotopes \u003d\u003d null ) return null ; for ( IIsotope isotope : isotopes ) { double diff \u003d Math . abs ( ( ( isotope . getExactMass ( ) ) - exactMass ) ) ; if ( ( ( isotope . getSymbol ( ) . equals ( symbol ) ) \u0026\u0026 ( diff \u003c\u003d tolerance ) ) \u0026\u0026 ( diff \u003c minDiff ) ) { ret \u003d clone ( isotope ) ; minDiff \u003d diff ; } } return ret ; } }\r\n",
  "truth": "assertNull ( match )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "match",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "74_0.txt",
  "assertion": "assertEquals ( c s, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_1.txt",
  "assertion": "assertEquals ( c cs, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_10.txt",
  "assertion": "assertEquals ( crs, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( crs, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_11.txt",
  "assertion": "assertEquals ( cms, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cms, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_12.txt",
  "assertion": "assertEquals ( cus, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cus, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_13.txt",
  "assertion": "assertEquals ( cos, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cos, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_14.txt",
  "assertion": "assertEquals ( cst, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cst, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_15.txt",
  "assertion": "assertEquals ( cns, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cns, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_16.txt",
  "assertion": "assertEquals ( cds, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cds, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_17.txt",
  "assertion": "assertEquals ( cjs, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cjs, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_18.txt",
  "assertion": "assertEquals ( cass, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cass, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_19.txt",
  "assertion": "assertEquals ( c SS, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c SS, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_2.txt",
  "assertion": "assertEquals ( c ss, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c ss, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_20.txt",
  "assertion": "assertEquals ( c s, c c ( )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, c c ( ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_21.txt",
  "assertion": "assertEquals ( ( s, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ( s, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_22.txt",
  "assertion": "assertEquals ( c s, ( c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, ( c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_23.txt",
  "assertion": "assertEquals ( c s, c ( c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c s, c ( c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_24.txt",
  "assertion": "assertEquals ( cts, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cts, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_25.txt",
  "assertion": "assertEquals ( C s, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( C s, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_26.txt",
  "assertion": "assertEquals ( c cs, c c ( )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, c c ( ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_27.txt",
  "assertion": "assertEquals ( c cs, ( c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, ( c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_28.txt",
  "assertion": "assertEquals ( c cs, c ( c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c cs, c ( c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_29.txt",
  "assertion": "assertEquals ( ( cs, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ( cs, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_3.txt",
  "assertion": "assertEquals ( c stats, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c stats, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_4.txt",
  "assertion": "assertEquals ( cs, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cs, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_5.txt",
  "assertion": "assertEquals ( ccss, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ccss, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_6.txt",
  "assertion": "assertEquals ( c ], c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( c ], c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_7.txt",
  "assertion": "assertEquals ( cx, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( cx, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_8.txt",
  "assertion": "assertEquals ( css, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( css, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_9.txt",
  "assertion": "assertEquals ( ctx, c c c )\r\n",
  "test": "class X {public void testCopy ( ) { CommunicationSummaryStatistics css \u003d new CommunicationSummaryStatistics ( ) ; css . setAverageDuration ( 5 ) ; css . setCount ( 4 ) ; css . setId ( \"myid\" ) ; css . setMaximumDuration ( 65 ) ; css . setMinimumDuration ( 23 ) ; css . setOperation ( \"myop\" ) ; css . setSeverity ( 4 ) ; css . setUri ( \"myuri\" ) ; ConnectionStatistics cs \u003d new ConnectionStatistics ( ) ; cs . setAverageLatency ( 65 ) ; cs . setCount ( 3 ) ; cs . setMaximumLatency ( 766 ) ; cs . setMinimumLatency ( 23 ) ; cs . setSeverity ( 6 ) ; CommunicationSummaryStatistics css2 \u003d new CommunicationSummaryStatistics ( ) ; css2 . setId ( \"id2\" ) ; cs . setNode ( css2 ) ; css . getOutbound ( ) . put ( \"out1\" , cs ) ; CommunicationSummaryStatistics cssCopy \u003d new CommunicationSummaryStatistics ( css ) ; assertEquals ( ctx, c c c ) ; }  }\r\n",
  "focal method": "class Y{ public void put( String  var24678 , String  var24678 ) { header . put ( key , value ) ; } }\r\n",
  "truth": "assertEquals ( css, cssCopy )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "76_0.txt",
  "assertion": "assertTrue ( adapter. input has moreResources\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResources\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_1.txt",
  "assertion": "assertTrue ( adapter. input has moreResourcesResources ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesResources ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_10.txt",
  "assertion": "assertTrue ( adapter. input hasCacheResourcesResources ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheResourcesResources ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_11.txt",
  "assertion": "assertTrue ( adapter. input has moreMore\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreMore\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_12.txt",
  "assertion": "assertTrue ( adapter. input hasResourcesResources\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasResourcesResources\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_13.txt",
  "assertion": "assertTrue ( adapter. input has moreResourcesMore ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesMore ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_14.txt",
  "assertion": "assertTrue ( adapter. input has moreMoreResources ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreMoreResources ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_15.txt",
  "assertion": "assertTrue ( adapter. input hasResourcesResourcesResources ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasResourcesResourcesResources ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_16.txt",
  "assertion": "assertTrue ( adapter. input has moreResourcess ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcess ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_17.txt",
  "assertion": "assertTrue ( adapter. input has moreStreamResults ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreamResults ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_18.txt",
  "assertion": "assertTrue ( adapter. input has moreInput\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreInput\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_19.txt",
  "assertion": "assertTrue ( adapter. inputMore moreResourcesResults ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreResourcesResults ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_2.txt",
  "assertion": "assertTrue ( adapter. input has moreResourcesResults ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesResults ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_20.txt",
  "assertion": "assertTrue ( adapter. input hasCacheResourcesResults ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheResourcesResults ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_21.txt",
  "assertion": "assertTrue ( adapter. inputMore moreStream\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreStream\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_22.txt",
  "assertion": "assertTrue ( adapter. input has moreExt\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreExt\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_23.txt",
  "assertion": "assertTrue ( adapter. input hasCacheStream\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheStream\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_24.txt",
  "assertion": "assertTrue ( adapter. input has moreStreammore ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreammore ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_25.txt",
  "assertion": "assertTrue ( adapter. input has moreStreamStream ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreamStream ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_26.txt",
  "assertion": "assertTrue ( adapter. input has moreInputResources ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreInputResources ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_27.txt",
  "assertion": "assertTrue ( adapter. input has moreObject\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreObject\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_28.txt",
  "assertion": "assertTrue ( adapter. input. moreResources\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input. moreResources\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_29.txt",
  "assertion": "assertTrue ( adapter. inputMoreCacheResources\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMoreCacheResources\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_3.txt",
  "assertion": "assertTrue ( adapter. input has moreStream\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStream\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_4.txt",
  "assertion": "assertTrue ( adapter. inputMore moreResources\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreResources\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_5.txt",
  "assertion": "assertTrue ( adapter. input hasCacheResources\" ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input hasCacheResources\" ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_6.txt",
  "assertion": "assertTrue ( adapter. input has moreResourcesmore ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesmore ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_7.txt",
  "assertion": "assertTrue ( adapter. input has moreResourcesStream ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreResourcesStream ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_8.txt",
  "assertion": "assertTrue ( adapter. input has moreStreamResources ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. input has moreStreamResources ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_9.txt",
  "assertion": "assertTrue ( adapter. inputMore moreResourcesResources ( ) )\r\n",
  "test": "class X {public void testGetHasMoreStreamsTrue ( ) { when ( mockResult . getLastEvaluatedStreamArn ( ) ) . thenReturn ( TEST_STRING ) ; assertTrue ( adapter. inputMore moreResourcesResources ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getHasMoreStreams() { return ( internalResult . getLastEvaluatedStreamArn ( ) ) !\u003d null ; } }\r\n",
  "truth": "assertTrue ( adapter. getHasMoreStreams ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "77_0.txt",
  "assertion": "assertEquals ( languages, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_1.txt",
  "assertion": "assertEquals ( \"\", languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( \"\", languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_10.txt",
  "assertion": "assertEquals ( \"\", 2 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( \"\", 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_11.txt",
  "assertion": "assertEquals ( 2, \"\" )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 2, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_12.txt",
  "assertion": "assertEquals ( 2, 2 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 2, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_13.txt",
  "assertion": "assertEquals ( 4, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 4, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_14.txt",
  "assertion": "assertEquals ( languages, 4 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, 4 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_15.txt",
  "assertion": "assertEquals ( English, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( English, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_16.txt",
  "assertion": "assertEquals ( languages, English )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, English ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_17.txt",
  "assertion": "assertEquals ( \"\", 1 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( \"\", 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_18.txt",
  "assertion": "assertEquals ( 1, \"\" )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 1, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_19.txt",
  "assertion": "assertEquals ( 1, 2 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 1, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_2.txt",
  "assertion": "assertEquals ( languages, \"\" )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_20.txt",
  "assertion": "assertEquals ( 2, 1 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 2, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_21.txt",
  "assertion": "assertEquals ( \"\", 3 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( \"\", 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_22.txt",
  "assertion": "assertEquals ( 3, \"\" )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 3, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_23.txt",
  "assertion": "assertEquals ( 3, 2 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 3, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_24.txt",
  "assertion": "assertEquals ( 2, 3 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 2, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_25.txt",
  "assertion": "assertEquals ( null, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( null, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_26.txt",
  "assertion": "assertEquals ( languages, null )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, null ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_27.txt",
  "assertion": "assertEquals ( expected, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( expected, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_28.txt",
  "assertion": "assertEquals ( languages, expected )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_29.txt",
  "assertion": "assertEquals ( true, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( true, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_3.txt",
  "assertion": "assertEquals ( 2, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 2, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_4.txt",
  "assertion": "assertEquals ( languages, 2 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_5.txt",
  "assertion": "assertEquals ( 1, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 1, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_6.txt",
  "assertion": "assertEquals ( languages, 1 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_7.txt",
  "assertion": "assertEquals ( 3, languages )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( 3, languages ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_8.txt",
  "assertion": "assertEquals ( languages, 3 )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( languages, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "77_9.txt",
  "assertion": "assertEquals ( \"\", \"\" )\r\n",
  "test": "class X {public void translateQueryQuotedTitles ( ) { SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( ) ) ; SearchUtils . translateQuery ( \"title:\\\"paris\u003csp\u003eberlin\\\"\" , getLanguageList ( true ) ) ; assertEquals ( \"\", \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void getLanguageList( boolean  var24678 ) { ArrayList \u003c String \u003e languages \u003d new ArrayList ( ) ; if ( empty ) { return languages ; } languages . add ( \"da\" ) ; languages . add ( \"de\" ) ; languages . add ( \"fr\" ) ; languages . add ( \"ga\" ) ; languages . add ( \"it\" ) ; languages . add ( \"nl\" ) ; return languages ; } }\r\n",
  "truth": "assertEquals ( 1, 1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_0.txt",
  "assertion": "assertEquals ( h ( 1, h ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_1.txt",
  "assertion": "assertEquals ( 1 ( 1, h ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, h ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_10.txt",
  "assertion": "assertEquals ( 1 ( 1, h1 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, h1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_11.txt",
  "assertion": "assertEquals ( h ( 1, 11 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, 11 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_12.txt",
  "assertion": "assertEquals ( 1 ( 1, 11 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, 11 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_13.txt",
  "assertion": "assertEquals ( h ( 1, h_ 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h_ 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_14.txt",
  "assertion": "assertEquals ( h_ 1, h ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h_ 1, h ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_15.txt",
  "assertion": "assertEquals ( he ( 1, h1 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, h1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_16.txt",
  "assertion": "assertEquals ( h ( 1, he1 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, he1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_17.txt",
  "assertion": "assertEquals ( 1 ( 1, h_ 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, h_ 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_18.txt",
  "assertion": "assertEquals ( h ( 1, 1_ 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, 1_ 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_19.txt",
  "assertion": "assertEquals ( 1_ 1, h ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1_ 1, h ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_2.txt",
  "assertion": "assertEquals ( h ( 1, 1 ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, 1 ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_20.txt",
  "assertion": "assertEquals ( h_ 1, 1 ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h_ 1, 1 ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_21.txt",
  "assertion": "assertEquals ( 1 ( 1, he1 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, he1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_22.txt",
  "assertion": "assertEquals ( he ( 1, 11 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, 11 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_23.txt",
  "assertion": "assertEquals ( 1 ( 1, 1_ 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, 1_ 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_24.txt",
  "assertion": "assertEquals ( 1_ 1, 1 ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1_ 1, 1 ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_25.txt",
  "assertion": "assertEquals ( bet ( 1, h ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( bet ( 1, h ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_26.txt",
  "assertion": "assertEquals ( h ( 1, bet ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, bet ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_27.txt",
  "assertion": "assertEquals ( h ( true, h ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( true, h ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_28.txt",
  "assertion": "assertEquals ( h ( 1, h ( true )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h ( true ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_29.txt",
  "assertion": "assertEquals ( bet ( 1, 1 ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( bet ( 1, 1 ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_3.txt",
  "assertion": "assertEquals ( 1 ( 1, 1 ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, 1 ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_4.txt",
  "assertion": "assertEquals ( he ( 1, h ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, h ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_5.txt",
  "assertion": "assertEquals ( h ( 1, he ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, he ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_6.txt",
  "assertion": "assertEquals ( 1 ( 1, he ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( 1 ( 1, he ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_7.txt",
  "assertion": "assertEquals ( he ( 1, 1 ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, 1 ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_8.txt",
  "assertion": "assertEquals ( he ( 1, he ( 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( he ( 1, he ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_9.txt",
  "assertion": "assertEquals ( h ( 1, h1 1 )\r\n",
  "test": "class X {public void testGetPartnerPersoon ( ) { final PersoonHisVolledigImpl persoonHisVolledig \u003d TestPersoonJohnnyJordaan . maak ( ) ; HuwelijkGeregistreerdPartnerschapHisVolledig huwelijk \u003d null ; for ( final BetrokkenheidHisVolledigImpl betrokkenheid : persoonHisVolledig . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getRelatie ( ) ) instanceof HuwelijkGeregistreerdPartnerschapHisVolledig ) { huwelijk \u003d ( ( HuwelijkGeregistreerdPartnerschapHisVolledig ) ( betrokkenheid . getRelatie ( ) ) ) ; } } PersoonHisVolledig partnerPersoon \u003d null ; for ( final BetrokkenheidHisVolledig betrokkenheid : huwelijk . getBetrokkenheden ( ) ) { if ( ( betrokkenheid . getPersoon ( ) ) !\u003d persoonHisVolledig ) { partnerPersoon \u003d betrokkenheid . getPersoon ( ) ; } } final PersoonHisVolledig resultaat \u003d PersoonHisVolledigUtil . getPartnerPersoon ( persoonHisVolledig , huwelijk ) ; assertEquals ( h ( 1, h1 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getPartnerPersoon( PersoonHisVolledig  var24678 , HuwelijkGeregistreerdPartnerschapHisVolledig  var24678 ) { return hgp . geefPartnerVan ( persoon ) . getPersoon ( ) ; } }\r\n",
  "truth": "assertEquals ( partnerPersoon, resultaat )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_0.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_1.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_10.txt",
  "assertion": "assertTrue ( ( ( response. count ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. count ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_11.txt",
  "assertion": "assertTrue ( ( ( response. length ( ) ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_12.txt",
  "assertion": "assertTrue ( ( ( response. size ( ) ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_13.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d 3 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d 3 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_14.txt",
  "assertion": "assertTrue ( ( ( response. length ( ) ) \u003d\u003d size ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \u003d\u003d size ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_15.txt",
  "assertion": "assertTrue ( ( ( response. size ( ) ) \u003d\u003d size ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \u003d\u003d size ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_16.txt",
  "assertion": "assertTrue ( ( ( response. container ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. container ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_17.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d 4 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d 4 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_18.txt",
  "assertion": "assertTrue ( ( ( response. number ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. number ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_19.txt",
  "assertion": "assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_2.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d size ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d size ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_20.txt",
  "assertion": "assertTrue ( ( ( response. length ( ) ) \u003d\u003d 1 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \u003d\u003d 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_21.txt",
  "assertion": "assertTrue ( ( ( response. next ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. next ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_22.txt",
  "assertion": "assertTrue ( ( ( response. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \u003d\u003d 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_23.txt",
  "assertion": "assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d size ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d size ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_24.txt",
  "assertion": "assertTrue ( ( ( response. length ( ) ) \u003d\u003d null ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \u003d\u003d null ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_25.txt",
  "assertion": "assertTrue ( ( ( response. size ( ) ) \u003d\u003d null ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \u003d\u003d null ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_26.txt",
  "assertion": "assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d 1 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_27.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d 5 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d 5 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_28.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d 200 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d 200 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_29.txt",
  "assertion": "assertTrue ( ( ( response. count ( ) ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. count ( ) ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_3.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d 1 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_4.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d null ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d null ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_5.txt",
  "assertion": "assertTrue ( ( ( response. length ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. length ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_6.txt",
  "assertion": "assertTrue ( ( ( response. size ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. size ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_7.txt",
  "assertion": "assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d time ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. 1 ( ) ) \u003d\u003d time ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_8.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d 2 ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_9.txt",
  "assertion": "assertTrue ( ( ( response. index ( ) ) \u003d\u003d one ) )\r\n",
  "test": "class X {public void testQueryByLocalTime_NamedBinding ( ) { em . deleteAll ( LocalTimeField . class ) ; LocalTimeField entity \u003d new LocalTimeField ( ) ; LocalTime time \u003d LocalTime . of ( 0 , 0 , 0 , 1 ) ; entity . setStartTime ( time ) ; entity \u003d em . insert ( entity ) ; String query \u003d \"SELECT\u003csp\u003e*\u003csp\u003eFROM\u003csp\u003eLocalTimeField\u003csp\u003eWHERE\u003csp\u003estartTime\u003d@Time\" ; EntityQueryRequest request \u003d em . createEntityQueryRequest ( query ) ; request . setNamedBinding ( \"Time\" , time ) ; catatumbo . QueryResponse \u003c LocalTimeField \u003e response \u003d em . executeEntityQueryRequest ( LocalTimeField . class , request ) ; List \u003c LocalTimeField \u003e entities \u003d response . getResults ( ) ; out . println ( entities ) ; assertTrue ( ( ( response. index ( ) ) \u003d\u003d one ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return map . size ( ) ; } }\r\n",
  "truth": "assertTrue ( ( ( entities. size ( ) ) \u003d\u003d 1 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "7_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "7_1.txt",
  "assertion": "assertEquals ( 10, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 10, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_10.txt",
  "assertion": "assertEquals ( expected, 2 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_11.txt",
  "assertion": "assertEquals ( expect, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expect, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_12.txt",
  "assertion": "assertEquals ( expected, expect )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, expect ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_13.txt",
  "assertion": "assertEquals ( 20, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 20, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_14.txt",
  "assertion": "assertEquals ( expected, 20 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 20 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_15.txt",
  "assertion": "assertEquals ( 3, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 3, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_16.txt",
  "assertion": "assertEquals ( expected, 3 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_17.txt",
  "assertion": "assertEquals ( 5, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 5, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_18.txt",
  "assertion": "assertEquals ( expected, 5 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_19.txt",
  "assertion": "assertEquals ( 6, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 6, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_2.txt",
  "assertion": "assertEquals ( expected, 10 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_20.txt",
  "assertion": "assertEquals ( expected, 6 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 6 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_21.txt",
  "assertion": "assertEquals ( 4, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 4, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_22.txt",
  "assertion": "assertEquals ( expected, 4 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 4 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_23.txt",
  "assertion": "assertEquals (pected, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals (pected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_24.txt",
  "assertion": "assertEquals ( expected,pected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected,pected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_25.txt",
  "assertion": "assertEquals ( true, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( true, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_26.txt",
  "assertion": "assertEquals ( expected, true )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, true ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_27.txt",
  "assertion": "assertEquals ( null, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( null, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_28.txt",
  "assertion": "assertEquals ( 200, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 200, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_29.txt",
  "assertion": "assertEquals ( expected, 200 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 200 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_3.txt",
  "assertion": "assertEquals ( 0, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 0, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_4.txt",
  "assertion": "assertEquals ( expected, 0 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_5.txt",
  "assertion": "assertEquals ( 1, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 1, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_6.txt",
  "assertion": "assertEquals ( expected, 1 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_7.txt",
  "assertion": "assertEquals ( 8, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 8, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_8.txt",
  "assertion": "assertEquals ( expected, 8 )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected, 8 ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "7_9.txt",
  "assertion": "assertEquals ( 2, expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 2, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void score( String  var24678 , String  var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "80_0.txt",
  "assertion": "assertNull ( bias, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_1.txt",
  "assertion": "assertNull ( res, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( res, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_10.txt",
  "assertion": "assertNull ( bias, activation )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, activation ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_11.txt",
  "assertion": "assertNull ( \"\", bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( \"\", bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_12.txt",
  "assertion": "assertNull ( bias, \"\" )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_13.txt",
  "assertion": "assertNull ( biases, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( biases, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_14.txt",
  "assertion": "assertNull ( bias, biases )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, biases ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_15.txt",
  "assertion": "assertNull ( true, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( true, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_16.txt",
  "assertion": "assertNull ( bias, true )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, true ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_17.txt",
  "assertion": "assertNull ( res, res )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( res, res ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_18.txt",
  "assertion": "assertNull ( penalty, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( penalty, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_19.txt",
  "assertion": "assertNull ( bias, penalty )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, penalty ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_2.txt",
  "assertion": "assertNull ( bias, res )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, res ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_20.txt",
  "assertion": "assertNull ( 0, res )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 0, res ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_21.txt",
  "assertion": "assertNull ( res, 0 )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( res, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_22.txt",
  "assertion": "assertNull ( false, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( false, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_23.txt",
  "assertion": "assertNull ( bias, false )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, false ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_24.txt",
  "assertion": "assertNull ( sensitivity, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( sensitivity, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_25.txt",
  "assertion": "assertNull ( bias, sensitivity )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, sensitivity ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_26.txt",
  "assertion": "assertNull ( 0, 0 )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 0, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_27.txt",
  "assertion": "assertNull ( loss, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( loss, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_28.txt",
  "assertion": "assertNull ( 4, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 4, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_29.txt",
  "assertion": "assertNull ( bias, 4 )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, 4 ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_3.txt",
  "assertion": "assertNull ( 0, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 0, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_4.txt",
  "assertion": "assertNull ( bias, 0 )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_5.txt",
  "assertion": "assertNull ( null, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( null, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_6.txt",
  "assertion": "assertNull ( bias, null )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, null ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_7.txt",
  "assertion": "assertNull ( 1, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( 1, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_8.txt",
  "assertion": "assertNull ( bias, 1 )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( bias, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_9.txt",
  "assertion": "assertNull ( activation, bias )\r\n",
  "test": "class X {public void testLayerNormNoDeviation ( ) { final INDArray random \u003d Nd4j . rand ( new int [ ] { 10 , 4 } ) ; for ( int i \u003d 0 ; i \u003c 4 ; i ++ ) { random . putScalar ( 1 , i , 7 ) ; } final INDArray standardized \u003d random . ulike ( ) ; Nd4j . getExecutioner ( ) . Nd4j . exec ( new Standardize ( random , standardized , 1 ) ) ; final INDArray gain \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray bias \u003d Nd4j . rand ( new int [ ] { 1 , 4 } ) ; final INDArray res \u003d standardized . mulRowVector ( gain ) . addRowVector ( bias ) ; final INDArray expOut \u003d res . norm1 ( ) ; final int [ ] axis \u003d new int [ ] { 1 } ; SameDiff sd \u003d SameDiff . create ( ) ; SDVariable sdInput \u003d sd . var ( \"input\" , standardized ) ; SDVariable sdGain \u003d sd . var ( \"gain\" , gain ) ; SDVariable sdBias \u003d sd . var ( \"bias\" , bias ) ; SDVariable out \u003d nn . layerNorm ( sdInput , sdGain , sdBias , axis ) ; out . norm1 ( \"out\" ) ; String err \u003d OpValidation . validate ( new TestCase ( sd ) . expectedOutput ( \"out\" , expOut ) . Collections . gradCheckMask ( Collections . singletonMap ( \"input\" , random . neq ( 7 ) ) ) . Collections . gradientCheck ( true ) ) ; assertNull ( activation, bias ) ; }  }\r\n",
  "focal method": "class Y{ public void gradientCheck( boolean  var24678 ) { this . setGradientCheck ( isGradientCheck ) ; return this ; } }\r\n",
  "truth": "assertNull ( err, err )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
,
{
  "file": "82_0.txt",
  "assertion": "assertEquals ( 0, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 0, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_1.txt",
  "assertion": "assertEquals ( 1, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 1, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_10.txt",
  "assertion": "assertEquals ( 9, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 9, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_11.txt",
  "assertion": "assertEquals ( 1, false. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 1, false. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_12.txt",
  "assertion": "assertEquals ( index, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( index, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_13.txt",
  "assertion": "assertEquals ( 0, 0. index ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 0, 0. index ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_14.txt",
  "assertion": "assertEquals ( 8, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 8, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_15.txt",
  "assertion": "assertEquals ( null, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( null, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_16.txt",
  "assertion": "assertEquals ( 0, null. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 0, null. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_17.txt",
  "assertion": "assertEquals ( 10, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 10, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_18.txt",
  "assertion": "assertEquals ( 0, 0. count ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 0, 0. count ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_19.txt",
  "assertion": "assertEquals ( count, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( count, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_2.txt",
  "assertion": "assertEquals ( 2, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 2, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_20.txt",
  "assertion": "assertEquals ( 16, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 16, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_21.txt",
  "assertion": "assertEquals ( 20, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 20, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_22.txt",
  "assertion": "assertEquals ( 0, 0. size ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 0, 0. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_23.txt",
  "assertion": "assertEquals ( size, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( size, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_24.txt",
  "assertion": "assertEquals ( \"\", 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( \"\", 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_25.txt",
  "assertion": "assertEquals ( 12, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 12, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_26.txt",
  "assertion": "assertEquals ( 100, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 100, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_27.txt",
  "assertion": "assertEquals ( 1000, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 1000, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_28.txt",
  "assertion": "assertEquals ( 2, false. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 2, false. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_29.txt",
  "assertion": "assertEquals (0, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals (0, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_3.txt",
  "assertion": "assertEquals ( 0, false. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 0, false. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_4.txt",
  "assertion": "assertEquals ( false, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( false, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_5.txt",
  "assertion": "assertEquals ( 3, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 3, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_6.txt",
  "assertion": "assertEquals ( 4, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 4, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_7.txt",
  "assertion": "assertEquals ( 5, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 5, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_8.txt",
  "assertion": "assertEquals ( 6, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 6, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_9.txt",
  "assertion": "assertEquals ( 7, 0. 0 ( ) )\r\n",
  "test": "class X {public void falseBody ( ) { List \u003c Annotation \u003e list \u003d queryService . addCriteria ( \"oa:hasBody/ex:languageValue[@es]\" ) . execute ( ) ; assertEquals ( 7, 0. 0 ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { try { if ( ( _size ) \u003c 0 ) { synchronized ( this ) { if ( ( _size ) \u003c 0 ) { int index \u003d findSize ( ) ; _size \u003d index ; } } } return _size ; } catch ( RepositoryException e ) { throw new ObjectStoreException ( e ) ; } } }\r\n",
  "truth": "assertEquals ( 0, list. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_0.txt",
  "assertion": "assertEquals ( \" ( null, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_1.txt",
  "assertion": "assertEquals ( \" ( null, \" result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_10.txt",
  "assertion": "assertEquals ( \" result 1, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result 1, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_11.txt",
  "assertion": "assertEquals ( \" result null, \" null null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null, \" null null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_12.txt",
  "assertion": "assertEquals ( \" result null, \" result 1 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null, \" result 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_13.txt",
  "assertion": "assertEquals ( \" result 1, \" result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result 1, \" result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_14.txt",
  "assertion": "assertEquals ( \" ( 2, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( 2, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_15.txt",
  "assertion": "assertEquals ( \" ( null, \" ( 2 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" ( 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_16.txt",
  "assertion": "assertEquals ( \" ( null,\u0027( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null,\u0027( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_17.txt",
  "assertion": "assertEquals (\u0027( null, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals (\u0027( null, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_18.txt",
  "assertion": "assertEquals ( \" ( 2, \" result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( 2, \" result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_19.txt",
  "assertion": "assertEquals ( \" result 2, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result 2, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_2.txt",
  "assertion": "assertEquals ( \" result null, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_20.txt",
  "assertion": "assertEquals ( \" ( null, \" result 2 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" result 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_21.txt",
  "assertion": "assertEquals ( \" result null, \" ( 2 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null, \" ( 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_22.txt",
  "assertion": "assertEquals ( \" ( 0, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( 0, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_23.txt",
  "assertion": "assertEquals ( \" ( null, \" ( 0 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" ( 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_24.txt",
  "assertion": "assertEquals ( \" ( null,\u0027result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null,\u0027result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_25.txt",
  "assertion": "assertEquals (\u0027( null, \" result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals (\u0027( null, \" result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_26.txt",
  "assertion": "assertEquals (\u0027result null, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals (\u0027result null, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_27.txt",
  "assertion": "assertEquals ( \" result null,\u0027( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null,\u0027( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_28.txt",
  "assertion": "assertEquals ( \" result 2, \" result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result 2, \" result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_29.txt",
  "assertion": "assertEquals ( \" result null, \" result 2 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null, \" result 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_3.txt",
  "assertion": "assertEquals ( \" result null, \" result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null, \" result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_4.txt",
  "assertion": "assertEquals ( \" ( null, \" ( 1 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_5.txt",
  "assertion": "assertEquals ( \" ( 1, \" ( null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( 1, \" ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_6.txt",
  "assertion": "assertEquals ( \" ( null, \" null null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" null null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_7.txt",
  "assertion": "assertEquals ( \" ( null, \" result 1 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( null, \" result 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_8.txt",
  "assertion": "assertEquals ( \" result null, \" ( 1 )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" result null, \" ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_9.txt",
  "assertion": "assertEquals ( \" ( 1, \" result null )\r\n",
  "test": "class X {public void testSearchReusesNoParams ( ) { List \u003c IBaseResource \u003e resources \u003d new ArrayList ( ) ; for ( int i \u003d 0 ; i \u003c 50 ; i ++ ) { Organization org \u003d new Organization ( ) ; org . setName ( \"HELLO\" ) ; resources . add ( org ) ; } ourClient . transaction ( ) . withResources ( resources ) . prettyPrint ( ) . encodedXml ( ) . execute ( ) ; myDaoConfig . setReuseCachedSearchResultsForMillis ( 1000L ) ; Bundle result1 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid1 \u003d toSearchUuidFromLinkNext ( result1 ) ; Bundle result2 \u003d ourClient . search ( ) . forResource ( \"Organization\" ) . returnBundle ( Bundle . class ) . execute ( ) ; final String uuid2 \u003d toSearchUuidFromLinkNext ( result2 ) ; assertEquals ( \" ( 1, \" result null ) ; }  }\r\n",
  "focal method": "class Y{ public void toSearchUuidFromLinkNext( Bundle  var24678 ) { String linkNext \u003d theBundle . getLink ( \"next\" ) . getUrl ( ) ; linkNext \u003d linkNext . substring ( linkNext . indexOf ( \u0027?\u0027 ) ) ; Map \u003c String , String [ ] \u003e params \u003d UrlUtil . parseQueryString ( linkNext ) ; String [ ] uuidParams \u003d params . PARAM_PAGINGACTION . get ( ) ; String uuid \u003d uuidParams [ 0 ] ; return uuid ; } }\r\n",
  "truth": "assertEquals ( uuid1, uuid2 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "84_0.txt",
  "assertion": "assertEquals ( msg, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "84_1.txt",
  "assertion": "assertEquals ( msg, result )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, result ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "84_10.txt",
  "assertion": "assertEquals ( message, result )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( message, result ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_11.txt",
  "assertion": "assertEquals ( result, message )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, message ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_12.txt",
  "assertion": "assertEquals ( 0, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( 0, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_13.txt",
  "assertion": "assertEquals ( msg, 0 )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_14.txt",
  "assertion": "assertEquals (msg, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals (msg, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "84_15.txt",
  "assertion": "assertEquals ( msg,msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg,msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "84_16.txt",
  "assertion": "assertEquals ( out, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( out, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_17.txt",
  "assertion": "assertEquals ( msg, out )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, out ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_18.txt",
  "assertion": "assertEquals ( expected, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( expected, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_19.txt",
  "assertion": "assertEquals ( msg, expected )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_2.txt",
  "assertion": "assertEquals ( result, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "84_20.txt",
  "assertion": "assertEquals ( true, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( true, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_21.txt",
  "assertion": "assertEquals ( msg, true )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, true ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_22.txt",
  "assertion": "assertEquals ( ch, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( ch, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_23.txt",
  "assertion": "assertEquals ( msg, ch )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, ch ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_24.txt",
  "assertion": "assertEquals ( 1, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( 1, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_25.txt",
  "assertion": "assertEquals ( msg, 1 )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_26.txt",
  "assertion": "assertEquals ( reply, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( reply, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_27.txt",
  "assertion": "assertEquals ( msg, reply )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, reply ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_28.txt",
  "assertion": "assertEquals ( session, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( session, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "incompatible type"
}
,
{
  "file": "84_29.txt",
  "assertion": "assertEquals ( msg, session )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, session ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "session",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "incompatible type"
}
,
{
  "file": "84_3.txt",
  "assertion": "assertEquals ( result, result )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, result ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "84_4.txt",
  "assertion": "assertEquals ( null, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( null, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_5.txt",
  "assertion": "assertEquals ( msg, null )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, null ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_6.txt",
  "assertion": "assertEquals ( null, result )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( null, result ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_7.txt",
  "assertion": "assertEquals ( result, null )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( result, null ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_8.txt",
  "assertion": "assertEquals ( message, msg )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( message, msg ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "84_9.txt",
  "assertion": "assertEquals ( msg, message )\r\n",
  "test": "class X {public void readChokeMessage ( ) { long session \u003d 1L ; Message msg \u003d Messages . choke ( session ) ; byte [ ] bytes \u003d pack . Arrays . write ( Arrays . asList ( 6 , session , Arrays . asList ( ) ) ) ; Message result \u003d pack . MessageTemplate . read ( bytes , MessageTemplate . getInstance ( ) ) ; assertEquals ( msg, message ) ; }  }\r\n",
  "focal method": "class Y{ public void getInstance() { return cocaine . msgpack . MessageTemplate . instance ; } }\r\n",
  "truth": "assertEquals ( msg, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "msg",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "85_0.txt",
  "assertion": "assertNull ( mp )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mp ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "mp",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "85_1.txt",
  "assertion": "assertNull ( MP )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( MP ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_10.txt",
  "assertion": "assertNull ( sp )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( sp ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_11.txt",
  "assertion": "assertNull ( me )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( me ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_12.txt",
  "assertion": "assertNull ( pipe )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pipe ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_13.txt",
  "assertion": "assertNull ( msg )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( msg ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_14.txt",
  "assertion": "assertNull ( pm )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pm ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_15.txt",
  "assertion": "assertNull ( pup )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pup ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_16.txt",
  "assertion": "assertNull ( m )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( m ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_17.txt",
  "assertion": "assertNull ( dc )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( dc ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_18.txt",
  "assertion": "assertNull ( subp )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( subp ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_19.txt",
  "assertion": "assertNull ( cap )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( cap ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_2.txt",
  "assertion": "assertNull ( null )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_20.txt",
  "assertion": "assertNull ( ma )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ma ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_21.txt",
  "assertion": "assertNull ( poll )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( poll ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_22.txt",
  "assertion": "assertNull ( listening )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( listening ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_23.txt",
  "assertion": "assertNull ( mute )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mute ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_24.txt",
  "assertion": "assertNull ( sip )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( sip ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_25.txt",
  "assertion": "assertNull ( 0 )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_26.txt",
  "assertion": "assertNull ( pp )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pp ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_27.txt",
  "assertion": "assertNull ( mm )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mm ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_28.txt",
  "assertion": "assertNull ( ap )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ap ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_29.txt",
  "assertion": "assertNull ( ml )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ml ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_3.txt",
  "assertion": "assertNull (mp )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull (mp ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "mp",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "85_4.txt",
  "assertion": "assertNull ( mc )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( mc ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_5.txt",
  "assertion": "assertNull ( multip )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( multip ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_6.txt",
  "assertion": "assertNull ( ps )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ps ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_7.txt",
  "assertion": "assertNull ( ip )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( ip ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_8.txt",
  "assertion": "assertNull ( cp )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( cp ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "85_9.txt",
  "assertion": "assertNull ( pa )\r\n",
  "test": "class X {public void loadMarketplaceHistoryWithinPeriod_beforeMpCreation ( ) { createMarketplaceHistoryEntries ( ) ; MarketplaceHistory mp \u003d dao . MARKETPLACE_KEY1 . loadMarketplaceHistoryWithinPeriod ( ) ; assertNull ( pa ) ; }  }\r\n",
  "focal method": "class Y{ public void loadMarketplaceHistoryWithinPeriod( long  var24678 , long  var24678 ) { Query query \u003d dm . createNamedQuery ( \"MarketplaceHistory.findWithinPeriod\" ) ; query . Long . setParameter ( \"mpKey\" , Long . valueOf ( mpKey ) ) ; query . setParameter ( \"modDate\" , new Date ( endPeriod ) ) ; query . setMaxResults ( 1 ) ; try { return ( ( MarketplaceHistory ) ( query . getSingleResult ( ) ) ) ; } catch ( NoResultException e ) { return null ; } } }\r\n",
  "truth": "assertNull ( mp )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "86_0.txt",
  "assertion": "assertEquals ( 12, pages. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_1.txt",
  "assertion": "assertEquals ( 12, cells. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_10.txt",
  "assertion": "assertEquals ( 12, pages. number ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. number ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_11.txt",
  "assertion": "assertEquals ( 12, doubles. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_12.txt",
  "assertion": "assertEquals ( 12, cells. number ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. number ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_13.txt",
  "assertion": "assertEquals ( 12, tiles. size ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_14.txt",
  "assertion": "assertEquals ( 12, pages. numbers ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. numbers ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_15.txt",
  "assertion": "assertEquals ( 12, tiles. order ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. order ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_16.txt",
  "assertion": "assertEquals ( 12, phones. size ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_17.txt",
  "assertion": "assertEquals ( 12, tiles. cells ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. cells ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_18.txt",
  "assertion": "assertEquals ( 12, cells. numbers ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. numbers ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_19.txt",
  "assertion": "assertEquals ( 12, doubles. size ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_2.txt",
  "assertion": "assertEquals ( 12, pages. size ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_20.txt",
  "assertion": "assertEquals ( 12, keys. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, keys. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_21.txt",
  "assertion": "assertEquals ( 12, phones. order ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. order ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_22.txt",
  "assertion": "assertEquals ( 12, phones. cells ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. cells ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_23.txt",
  "assertion": "assertEquals ( 12, maps. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, maps. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_24.txt",
  "assertion": "assertEquals ( 12, doubles. order ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. order ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_25.txt",
  "assertion": "assertEquals ( 12, pages. elements ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. elements ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_26.txt",
  "assertion": "assertEquals ( 12, results. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, results. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_27.txt",
  "assertion": "assertEquals ( 12, doubles. cells ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, doubles. cells ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_28.txt",
  "assertion": "assertEquals ( 12, tiles. number ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. number ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_29.txt",
  "assertion": "assertEquals ( 12, ships. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, ships. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_3.txt",
  "assertion": "assertEquals ( 12, pages. order ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. order ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_4.txt",
  "assertion": "assertEquals ( 12, cells. size ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. size ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_5.txt",
  "assertion": "assertEquals ( 12, pages. cells ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, pages. cells ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_6.txt",
  "assertion": "assertEquals ( 12, tiles. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, tiles. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_7.txt",
  "assertion": "assertEquals ( 12, cells. order ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. order ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_8.txt",
  "assertion": "assertEquals ( 12, cells. cells ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, cells. cells ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_9.txt",
  "assertion": "assertEquals ( 12, phones. seeds ( ) )\r\n",
  "test": "class X {public void testItShouldFindTwelveMapsForBenzeneOntoBenzene ( ) { IMapper mapper \u003d new VFMapper ( benzene , true ) ; util . List \u003c Map \u003c INode , IAtom \u003e \u003e maps \u003d mapper . getMaps ( benzene ) ; assertEquals ( 12, phones. seeds ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return cells . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 12, maps. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_0.txt",
  "assertion": "assertEquals ( result, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "87_1.txt",
  "assertion": "assertEquals ( false, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( false, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "87_10.txt",
  "assertion": "assertEquals ( result, null )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, null ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_11.txt",
  "assertion": "assertEquals ( 0, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( 0, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_12.txt",
  "assertion": "assertEquals ( result, 0 )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_13.txt",
  "assertion": "assertEquals ( expected, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( expected, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_14.txt",
  "assertion": "assertEquals ( result, expected )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_15.txt",
  "assertion": "assertEquals ( value, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( value, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_16.txt",
  "assertion": "assertEquals ( result, value )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, value ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_17.txt",
  "assertion": "assertEquals ( return, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( return, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_18.txt",
  "assertion": "assertEquals ( result, return )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, return ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_19.txt",
  "assertion": "assertEquals ( \"\", result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( \"\", result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_2.txt",
  "assertion": "assertEquals ( result, false )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, false ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "87_20.txt",
  "assertion": "assertEquals ( result, \"\" )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_21.txt",
  "assertion": "assertEquals ( Result, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( Result, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_22.txt",
  "assertion": "assertEquals ( result, Result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, Result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_23.txt",
  "assertion": "assertEquals ( results, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( results, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_24.txt",
  "assertion": "assertEquals ( result, results )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, results ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_25.txt",
  "assertion": "assertEquals ( rule, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( rule, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_26.txt",
  "assertion": "assertEquals ( result, rule )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, rule ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_27.txt",
  "assertion": "assertEquals ( answer, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( answer, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_28.txt",
  "assertion": "assertEquals ( result, answer )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, answer ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_29.txt",
  "assertion": "assertEquals ( filter, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( filter, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_3.txt",
  "assertion": "assertEquals ( true, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( true, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_4.txt",
  "assertion": "assertEquals ( result, true )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result, true ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_5.txt",
  "assertion": "assertEquals (result, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals (result, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "87_6.txt",
  "assertion": "assertEquals ( result,result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result,result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "87_7.txt",
  "assertion": "assertEquals (Result, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals (Result, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_8.txt",
  "assertion": "assertEquals ( result,Result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( result,Result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "87_9.txt",
  "assertion": "assertEquals ( null, result )\r\n",
  "test": "class X {public void shouldReturnFalseGivenFeatureIsFlippedOff ( ) { FeatureContext featureContext \u003d mock ( FeatureContext . class ) ; FlipAnnotationAttributes flipAnnotationAttributes \u003d mock ( FlipAnnotationAttributes . class ) ; FlipOffCondition condition \u003d new FlipOffCondition ( ) ; boolean result \u003d condition . evaluateCondition ( featureContext , flipAnnotationAttributes ) ; assertEquals ( null, result ) ; }  }\r\n",
  "focal method": "class Y{ public void evaluateCondition( FeatureContext  var24678 , FlipAnnotationAttributes  var24678 ) { String expression \u003d flipAnnotationAttributes . getAttributeValue ( \"expression\" , \"\" ) ; ValidationUtils . requireNonEmpty ( expression , \"expression\u003csp\u003eelement\u003csp\u003ecan\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eNULL\u003csp\u003eor\u003csp\u003eEMPTY\u003csp\u003ewhen\u003csp\u003eusing\u003csp\u003e@FlipOnSpringExpression\" ) ; return evaluateExpression ( featureContext , expression ) ; } }\r\n",
  "truth": "assertEquals ( false, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "88_0.txt",
  "assertion": "assertEquals ( 1, 2. count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_1.txt",
  "assertion": "assertEquals ( 1, 2Files count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_10.txt",
  "assertion": "assertEquals ( 3, 2. count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 3, 2. count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_11.txt",
  "assertion": "assertEquals ( 2, 3. count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 3. count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_12.txt",
  "assertion": "assertEquals ( 1, 3. count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 3. count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_13.txt",
  "assertion": "assertEquals ( 1, 2. count ( 3 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 3 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_14.txt",
  "assertion": "assertEquals ( 1, 2D count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2D count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_15.txt",
  "assertion": "assertEquals ( 1, 3Files count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 3Files count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_16.txt",
  "assertion": "assertEquals ( 3, 2Files count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 3, 2Files count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_17.txt",
  "assertion": "assertEquals ( 2, 3Files count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 3Files count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_18.txt",
  "assertion": "assertEquals ( 1, 2Files count ( 3 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 3 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_19.txt",
  "assertion": "assertEquals ( 4, 2. count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 4, 2. count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_2.txt",
  "assertion": "assertEquals ( 2, 2. count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 2. count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_20.txt",
  "assertion": "assertEquals ( 1, 2. count ( 4 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 4 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_21.txt",
  "assertion": "assertEquals ( 3, 2. count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 3, 2. count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_22.txt",
  "assertion": "assertEquals ( 2, 3. count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 3. count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_23.txt",
  "assertion": "assertEquals ( 2, 2. count ( 3 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 2. count ( 3 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_24.txt",
  "assertion": "assertEquals ( 2, 2D count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 2D count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_25.txt",
  "assertion": "assertEquals ( 1, 2D count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2D count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_26.txt",
  "assertion": "assertEquals ( 1, 2M count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2M count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_27.txt",
  "assertion": "assertEquals ( 4, 2Files count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 4, 2Files count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_28.txt",
  "assertion": "assertEquals ( 1, 2Files count ( 4 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 4 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_29.txt",
  "assertion": "assertEquals ( 3, 2Files count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 3, 2Files count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_3.txt",
  "assertion": "assertEquals ( 1, 2. count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2. count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_4.txt",
  "assertion": "assertEquals ( 2, 2Files count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 2Files count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_5.txt",
  "assertion": "assertEquals ( 1, 2Files count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 2Files count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_6.txt",
  "assertion": "assertEquals ( 2, 2. count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 2. count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_7.txt",
  "assertion": "assertEquals ( 1, 3. count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 3. count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_8.txt",
  "assertion": "assertEquals ( 2, 2Files count ( 2 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 2, 2Files count ( 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_9.txt",
  "assertion": "assertEquals ( 1, 3Files count ( 1 ) )\r\n",
  "test": "class X {public void testValidSimpleModel ( ) { createJavaProjectWithRootSrc ( \"foo\" ) ; IFile file \u003d createFile ( ( \"foo/src/foo\" + ( F_EXT ) ) , \"object\u003csp\u003eFoo\u003csp\u003e\" ) ; build ( ) ; assertEquals ( 1, 3Files count ( 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void countMarkers( IFile  var24678 ) { return file . MARKER . findMarkers ( true ) . length ; } }\r\n",
  "truth": "assertEquals ( 0, countMarkers ( file ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_0.txt",
  "assertion": "assertEquals ( groups. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_1.txt",
  "assertion": "assertEquals ( groups. 0 ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. 0 ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_10.txt",
  "assertion": "assertEquals ( groups. n ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. n ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_11.txt",
  "assertion": "assertEquals ( groups. get ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. get ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_12.txt",
  "assertion": "assertEquals ( this. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( this. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_13.txt",
  "assertion": "assertEquals ( output. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( output. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_14.txt",
  "assertion": "assertEquals ( items. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( items. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_15.txt",
  "assertion": "assertEquals ( groups. count ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. count ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_16.txt",
  "assertion": "assertEquals ( groups. empty ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. empty ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_17.txt",
  "assertion": "assertEquals ( elements. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( elements. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_18.txt",
  "assertion": "assertEquals ( results. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( results. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_19.txt",
  "assertion": "assertEquals ( groups. group ( ), 0 )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. group ( ), 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_2.txt",
  "assertion": "assertEquals ( groups. group ( ), group )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. group ( ), group ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_20.txt",
  "assertion": "assertEquals ( groups. 0 ( ), group )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. 0 ( ), group ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_21.txt",
  "assertion": "assertEquals ( 0. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( 0. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_22.txt",
  "assertion": "assertEquals ( group. 0 ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( group. 0 ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_23.txt",
  "assertion": "assertEquals ( groups. order ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. order ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_24.txt",
  "assertion": "assertEquals ( data. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( data. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_25.txt",
  "assertion": "assertEquals ( list. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( list. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_26.txt",
  "assertion": "assertEquals ( Group. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( Group. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_27.txt",
  "assertion": "assertEquals ( groups. remaining ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. remaining ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_28.txt",
  "assertion": "assertEquals ( collection. 0 ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( collection. 0 ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_29.txt",
  "assertion": "assertEquals ( groups. sizes ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. sizes ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_3.txt",
  "assertion": "assertEquals ( group. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( group. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_4.txt",
  "assertion": "assertEquals ( collection. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( collection. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_5.txt",
  "assertion": "assertEquals ( Groups. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( Groups. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_6.txt",
  "assertion": "assertEquals ( collections. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( collections. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_7.txt",
  "assertion": "assertEquals ( g. group ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( g. group ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "89_8.txt",
  "assertion": "assertEquals ( groups. size ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. size ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in focal method": "size",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "incompatible type"
}
,
{
  "file": "89_9.txt",
  "assertion": "assertEquals ( groups. members ( ), groups )\r\n",
  "test": "class X {public void chunk_empty ( ) { RichIterable \u003c String \u003e collection \u003d this . newWith ( ) ; api . RichIterable \u003c RichIterable \u003c String \u003e \u003e groups \u003d collection . chunk ( 2 ) ; assertEquals ( groups. members ( ), groups ) ; }  }\r\n",
  "focal method": "class Y{ public void size() { return 0 ; } }\r\n",
  "truth": "assertEquals ( groups. size ( ), 0 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "groups",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_0.txt",
  "assertion": "assertEquals ( businessOB 0, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_1.txt",
  "assertion": "assertEquals ( businessOB 0, 2 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_10.txt",
  "assertion": "assertEquals ( businessOB data, data )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, data ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_11.txt",
  "assertion": "assertEquals ( business_ 0, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_12.txt",
  "assertion": "assertEquals ( businessOB 1, 2 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_13.txt",
  "assertion": "assertEquals ( businessOB 1, 5 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_14.txt",
  "assertion": "assertEquals ( businessOB data, 1 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_15.txt",
  "assertion": "assertEquals ( businessOB 1, data )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, data ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_16.txt",
  "assertion": "assertEquals ( businessOB 0, 7 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 7 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_17.txt",
  "assertion": "assertEquals ( business_ 0, 2 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_18.txt",
  "assertion": "assertEquals ( businessOB data, value )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, value ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_19.txt",
  "assertion": "assertEquals ( businessOB 0, 12 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 12 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_2.txt",
  "assertion": "assertEquals ( businessOB 0, 5 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_20.txt",
  "assertion": "assertEquals ( business_ 0, 5 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_21.txt",
  "assertion": "assertEquals ( business_ data, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ data, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_22.txt",
  "assertion": "assertEquals ( business_ 0, data )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business_ 0, data ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_23.txt",
  "assertion": "assertEquals ( businessOB 10, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 10, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_24.txt",
  "assertion": "assertEquals ( businessOB 0, 10 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 10 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_25.txt",
  "assertion": "assertEquals ( businessOB 1, 1 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_26.txt",
  "assertion": "assertEquals ( business. 0, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business. 0, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_27.txt",
  "assertion": "assertEquals ( business ${ 0, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( business ${ 0, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_28.txt",
  "assertion": "assertEquals ( businessOB 0, null )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, null ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_29.txt",
  "assertion": "assertEquals ( businessOB 1, value )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, value ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_3.txt",
  "assertion": "assertEquals ( businessOB data, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_4.txt",
  "assertion": "assertEquals ( businessOB 0, data )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, data ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_5.txt",
  "assertion": "assertEquals ( businessOB 1, 0 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 1, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_6.txt",
  "assertion": "assertEquals ( businessOB 0, 1 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_7.txt",
  "assertion": "assertEquals ( businessOB data, 2 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_8.txt",
  "assertion": "assertEquals ( businessOB 0, value )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB 0, value ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_9.txt",
  "assertion": "assertEquals ( businessOB data, 5 )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( businessOB data, 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper() { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_0.txt",
  "assertion": "assertEquals ( transformed.\", transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_1.txt",
  "assertion": "assertEquals ( transformed ), transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed ), transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_10.txt",
  "assertion": "assertEquals ( transformed\", transformed\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed\", transformed\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_11.txt",
  "assertion": "assertEquals ( transformed \", transformed ) )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed \", transformed ) ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_12.txt",
  "assertion": "assertEquals ( transformed ), transformed \" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed ), transformed \" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_13.txt",
  "assertion": "assertEquals ( transformed \", transformed\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed \", transformed\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_14.txt",
  "assertion": "assertEquals ( transformed\", transformed \" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed\", transformed \" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_15.txt",
  "assertion": "assertEquals ( transformed-\", transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed-\", transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_16.txt",
  "assertion": "assertEquals ( transformed.\", transformed-\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed-\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_17.txt",
  "assertion": "assertEquals ( transformed,\", transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed,\", transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_18.txt",
  "assertion": "assertEquals ( transformed.\", transformed,\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed,\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_19.txt",
  "assertion": "assertEquals ( transformed \", transformed \" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed \", transformed \" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_2.txt",
  "assertion": "assertEquals ( transformed.\", transformed ) )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed ) ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_20.txt",
  "assertion": "assertEquals ( transformed}\", transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed}\", transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_21.txt",
  "assertion": "assertEquals ( transformed.\", transformed}\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed}\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_22.txt",
  "assertion": "assertEquals ( transformed:\", transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed:\", transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_23.txt",
  "assertion": "assertEquals ( transformed.\", transformed:\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed:\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_24.txt",
  "assertion": "assertEquals ( transformed-\", transformed ) )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed-\", transformed ) ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_25.txt",
  "assertion": "assertEquals ( transformed ), transformed-\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed ), transformed-\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_26.txt",
  "assertion": "assertEquals ( transformedPath, transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformedPath, transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_27.txt",
  "assertion": "assertEquals ( transformed.\", transformedPath )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformedPath ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_28.txt",
  "assertion": "assertEquals ( transformed-\", transformed\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed-\", transformed\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_29.txt",
  "assertion": "assertEquals ( transformed\", transformed-\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed\", transformed-\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_3.txt",
  "assertion": "assertEquals ( transformed.\", transformed\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_4.txt",
  "assertion": "assertEquals ( transformed\", transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed\", transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_5.txt",
  "assertion": "assertEquals ( transformed \", transformed.\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed \", transformed.\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_6.txt",
  "assertion": "assertEquals ( transformed.\", transformed \" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed.\", transformed \" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_7.txt",
  "assertion": "assertEquals ( transformed ), transformed ) )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed ), transformed ) ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_8.txt",
  "assertion": "assertEquals ( transformed\", transformed ) )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed\", transformed ) ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "90_9.txt",
  "assertion": "assertEquals ( transformed ), transformed\" )\r\n",
  "test": "class X {public void testReplaceBinaryBuildRuleRefsInCmd ( ) { BuildTarget buildTarget \u003d BuildTargetFactory . newInstance ( \"//java/com/facebook/util:ManifestGenerator\" ) ; createConverter ( buildTarget ) ; new JavaBinaryRuleBuilder ( buildTarget ) . setMainClass ( \"com.facebook.util.ManifestGenerator\" ) . build ( graphBuilder ) ; String transformedString \u003d coerceAndStringify ( \"$(exe\u003csp\u003e//java/com/facebook/util:ManifestGenerator)\u003csp\u003e$OUT\" , graphBuilder . requireRule ( buildTarget ) ) ; Path expectedClasspath \u003d filesystem . getBuckPaths ( ) . getGenDir ( ) . resolve ( \"java/com/facebook/util/ManifestGenerator.jar\" ) . toAbsolutePath ( ) ; String expectedCmd \u003d String . format ( \"java\u003csp\u003e-jar\u003csp\u003e%s\u003csp\u003e$OUT\" , expectedClasspath ) ; assertEquals ( transformed ), transformed\" ) ; }  }\r\n",
  "focal method": "class Y{ public void format( String  var24678 , Object [ ]  var24678 ) { String . write ( String . format ( format , args ) ) ; return this ; } }\r\n",
  "truth": "assertEquals ( expectedCmd, transformedString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_0.txt",
  "assertion": "assertEquals ( expectU, expect 2 repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect 2 repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_1.txt",
  "assertion": "assertEquals ( expectU, expect 2 repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect 2 repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_10.txt",
  "assertion": "assertEquals ( expectI, expect 2 repS )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect 2 repS ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_11.txt",
  "assertion": "assertEquals ( expectU, expect10 repS )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect10 repS ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_12.txt",
  "assertion": "assertEquals ( expectU, expect, repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect, repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_13.txt",
  "assertion": "assertEquals ( expectU, expect, repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect, repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_14.txt",
  "assertion": "assertEquals ( expectU, expect 2 repU )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect 2 repU ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_15.txt",
  "assertion": "assertEquals ( expectI, expect10 repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect10 repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_16.txt",
  "assertion": "assertEquals ( expectI, expect 2 repA )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect 2 repA ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_17.txt",
  "assertion": "assertEquals ( expectU, expect10 repA )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect10 repA ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_18.txt",
  "assertion": "assertEquals ( expectI, expect10 repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect10 repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_19.txt",
  "assertion": "assertEquals ( expect URI, expect 2 repS )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expect URI, expect 2 repS ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_2.txt",
  "assertion": "assertEquals ( expectU, expect 2 repS )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect 2 repS ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_20.txt",
  "assertion": "assertEquals ( expectU, expect, repS )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect, repS ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_21.txt",
  "assertion": "assertEquals ( expect URI, expect10 repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expect URI, expect10 repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_22.txt",
  "assertion": "assertEquals ( expect URI, expect 2 repA )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expect URI, expect 2 repA ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_23.txt",
  "assertion": "assertEquals ( expect URI, expect10 repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expect URI, expect10 repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_24.txt",
  "assertion": "assertEquals ( expectI, expect10 repS )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect10 repS ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_25.txt",
  "assertion": "assertEquals ( expectri, expect 2 repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectri, expect 2 repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_26.txt",
  "assertion": "assertEquals ( expectI, expect, repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect, repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_27.txt",
  "assertion": "assertEquals ( expectri, expect 2 repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectri, expect 2 repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_28.txt",
  "assertion": "assertEquals ( expectU, expect, repA )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect, repA ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_29.txt",
  "assertion": "assertEquals ( expectI, expect, repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect, repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_3.txt",
  "assertion": "assertEquals ( expectI, expect 2 repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect 2 repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_4.txt",
  "assertion": "assertEquals ( expectU, expect10 repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect10 repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_5.txt",
  "assertion": "assertEquals ( expectU, expect 2 repA )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect 2 repA ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_6.txt",
  "assertion": "assertEquals ( expectI, expect 2 repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectI, expect 2 repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_7.txt",
  "assertion": "assertEquals ( expectU, expect10 repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expectU, expect10 repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_8.txt",
  "assertion": "assertEquals ( expect URI, expect 2 repR )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expect URI, expect 2 repR ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_9.txt",
  "assertion": "assertEquals ( expect URI, expect 2 repIENT )\r\n",
  "test": "class X {public void testGetP2RepURIFromCompFile_zip ( ) { File compFile \u003d new File ( \"/tmp/testcomp.zip\" ) ; URI p2RepURI \u003d PathUtils . getP2RepURIFromCompFile ( compFile ) ; URI expectURI \u003d URI . create ( ( ( \"jar:\" + ( compFile . toURI ( ) . toString ( ) ) ) + \"!/\" ) ) ; assertEquals ( expect URI, expect 2 repIENT ) ; }  }\r\n",
  "focal method": "class Y{ public void toString() { return ( ( project ) + \"-------\" ) + ( mappingNLProject ) ; } }\r\n",
  "truth": "assertEquals ( expectURI, p2RepURI )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_0.txt",
  "assertion": "assertEquals ( status )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( status ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_1.txt",
  "assertion": "assertEquals ( Status )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( Status ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_10.txt",
  "assertion": "assertEquals ( STAT )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( STAT ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_11.txt",
  "assertion": "assertEquals ( code )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( code ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_12.txt",
  "assertion": "assertEquals ( source )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( source ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_13.txt",
  "assertion": "assertEquals ( false )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( false ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_14.txt",
  "assertion": "assertEquals ( 200 )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( 200 ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_15.txt",
  "assertion": "assertEquals ( type )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( type ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_16.txt",
  "assertion": "assertEquals ( mode )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( mode ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_17.txt",
  "assertion": "assertEquals ( stage )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( stage ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_18.txt",
  "assertion": "assertEquals ( 100 )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( 100 ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_19.txt",
  "assertion": "assertEquals ( ( )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( ( ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_2.txt",
  "assertion": "assertEquals ( state )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( state ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_20.txt",
  "assertion": "assertEquals ( ) )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_21.txt",
  "assertion": "assertEquals ( visibility )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( visibility ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_22.txt",
  "assertion": "assertEquals ( version )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( version ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_23.txt",
  "assertion": "assertEquals ( condition )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( condition ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_24.txt",
  "assertion": "assertEquals ( content )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( content ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_25.txt",
  "assertion": "assertEquals ( str )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( str ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_26.txt",
  "assertion": "assertEquals ( update )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( update ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_27.txt",
  "assertion": "assertEquals ( method )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( method ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_28.txt",
  "assertion": "assertEquals ( 4 )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( 4 ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_29.txt",
  "assertion": "assertEquals ( expected )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_3.txt",
  "assertion": "assertEquals (status )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals (status ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_4.txt",
  "assertion": "assertEquals ( 0 )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_5.txt",
  "assertion": "assertEquals (Status )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals (Status ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_6.txt",
  "assertion": "assertEquals ( null )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_7.txt",
  "assertion": "assertEquals ( 1 )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_8.txt",
  "assertion": "assertEquals ( stat )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( stat ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_9.txt",
  "assertion": "assertEquals ( true )\r\n",
  "test": "class X {public void testSetState ( ) { parameters . STATUS . put ( new Setting ( PropertyHandler . STATUS , \"CREATION_EXECUTING_WORKLOAD\" ) ) ; propertyHandler \u003d new PropertyHandler ( settings ) ; propertyHandler . FINISHED . setState ( ) ; FlowState status \u003d propertyHandler . getState ( ) ; assertEquals ( true ) ; }  }\r\n",
  "focal method": "class Y{ public void getState() { return state ; } }\r\n",
  "truth": "assertEquals ( status )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_0.txt",
  "assertion": "assertNotNull ( results )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( results ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "results",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "93_1.txt",
  "assertion": "assertNotNull (results )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull (results ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "results",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "93_10.txt",
  "assertion": "assertNotNull ( rows )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( rows ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_11.txt",
  "assertion": "assertNotNull ( records )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( records ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_12.txt",
  "assertion": "assertNotNull ( permissions )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( permissions ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_13.txt",
  "assertion": "assertNotNull ( runs )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( runs ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_14.txt",
  "assertion": "assertNotNull ( works )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( works ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_15.txt",
  "assertion": "assertNotNull ( blocks )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( blocks ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_16.txt",
  "assertion": "assertNotNull ( maps )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( maps ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_17.txt",
  "assertion": "assertNotNull ( executions )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( executions ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_18.txt",
  "assertion": "assertNotNull ( completes )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( completes ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_19.txt",
  "assertion": "assertNotNull ( findings )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( findings ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_2.txt",
  "assertion": "assertNotNull ( values )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( values ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_20.txt",
  "assertion": "assertNotNull ( fills )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( fills ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_21.txt",
  "assertion": "assertNotNull ( succeeds )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( succeeds ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_22.txt",
  "assertion": "assertNotNull ( details )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( details ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_23.txt",
  "assertion": "assertNotNull ( exists )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( exists ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_24.txt",
  "assertion": "assertNotNull ( filters )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( filters ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_25.txt",
  "assertion": "assertNotNull ( assignments )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( assignments ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_26.txt",
  "assertion": "assertNotNull ( closes )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( closes ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_27.txt",
  "assertion": "assertNotNull ( ends )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( ends ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_28.txt",
  "assertion": "assertNotNull ( contents )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( contents ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_29.txt",
  "assertion": "assertNotNull ( methods )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( methods ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_3.txt",
  "assertion": "assertNotNull ( result )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( result ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_4.txt",
  "assertion": "assertNotNull ( executes )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( executes ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_5.txt",
  "assertion": "assertNotNull ( null )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( null ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_6.txt",
  "assertion": "assertNotNull ( Results )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( Results ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_7.txt",
  "assertion": "assertNotNull ( answers )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( answers ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_8.txt",
  "assertion": "assertNotNull ( metrics )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull ( metrics ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_9.txt",
  "assertion": "assertNotNull (Results )\r\n",
  "test": "class X {public void testPLFM_5240Open ( ) { createSchemaOneOfEachType ( ) ; createTableWithSchema ( ) ; grantReadToPublicOnTable ( ) ; DataType dataType \u003d org . sagebionetworks . repo . model . DataType . OPEN_DATA ; entityManager . changeEntityDataType ( adminUserInfo , tableId , dataType ) ; String sql \u003d \"select\u003csp\u003erow_id\u003csp\u003efrom\u003csp\u003e\" + ( tableId ) ; query . setSql ( sql ) ; query . setLimit ( 8L ) ; QueryResult results \u003d waitForConsistentQuery ( anonymousUser , query , queryOptions ) ; assertNotNull (Results ) ; }  }\r\n",
  "focal method": "class Y{ public void waitForConsistentQuery( UserInfo  var24678 , Query  var24678 , QueryOptions  var24678 ) { long start \u003d System . currentTimeMillis ( ) ; while ( true ) { try { QueryResultBundle queryResult \u003d tableQueryManger . querySinglePage ( mockProgressCallbackVoid , user , query , options ) ; return queryResult . getQueryResult ( ) ; } catch ( LockUnavilableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003elock:\u003csp\u003e\" + ( e . getLocalizedMessage ( ) ) ) ) ; } catch ( TableUnavailableException e ) { out . println ( ( \"Waiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003ebuild\u003csp\u003etable.\u003csp\u003eStatus:\u003csp\u003e\" + ( e . getStatus ( ) ) ) ) ; } Assert . assertTrue ( \"Timed\u003csp\u003eout\u003csp\u003ewaiting\u003csp\u003efor\u003csp\u003etable\u003csp\u003eindex\u003csp\u003eworker\u003csp\u003eto\u003csp\u003emake\u003csp\u003ethe\u003csp\u003etable\u003csp\u003eavailable.\" , ( ( ( System . currentTimeMillis ( ) ) - start ) \u003c ( org . sagebionetworks . table . worker . TableWorkerIntegrationTest . MAX_WAIT_MS ) ) ) ; Thread . sleep ( 1000 ) ; } } }\r\n",
  "truth": "assertNotNull ( results )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_1.txt",
  "assertion": "assertEquals ( expect, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expect, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_10.txt",
  "assertion": "assertEquals ( expected, assumed )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, assumed ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_11.txt",
  "assertion": "assertEquals ( 0, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( 0, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_12.txt",
  "assertion": "assertEquals ( expected, 0 )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_13.txt",
  "assertion": "assertEquals ( 10, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( 10, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_14.txt",
  "assertion": "assertEquals (expected, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals (expected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_15.txt",
  "assertion": "assertEquals ( anticipated, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( anticipated, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_16.txt",
  "assertion": "assertEquals ( expected, anticipated )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, anticipated ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_17.txt",
  "assertion": "assertEquals ( 1, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( 1, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_18.txt",
  "assertion": "assertEquals ( expected, 1 )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_19.txt",
  "assertion": "assertEquals ( 8, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( 8, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_2.txt",
  "assertion": "assertEquals ( expected, expect )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, expect ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_20.txt",
  "assertion": "assertEquals ( input, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( input, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_21.txt",
  "assertion": "assertEquals ( expected, input )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, input ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_22.txt",
  "assertion": "assertEquals ( predicted, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( predicted, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_23.txt",
  "assertion": "assertEquals ( unexpected, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( unexpected, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_24.txt",
  "assertion": "assertEquals ( target, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( target, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_25.txt",
  "assertion": "assertEquals ( expected, target )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, target ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_26.txt",
  "assertion": "assertEquals ( 2, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( 2, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_27.txt",
  "assertion": "assertEquals ( expects, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expects, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_28.txt",
  "assertion": "assertEquals ( original, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( original, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_29.txt",
  "assertion": "assertEquals ( expected, original )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, original ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_3.txt",
  "assertion": "assertEquals ( expected, actual )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, actual ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "actual",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "94_4.txt",
  "assertion": "assertEquals ( actual, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( actual, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "94_5.txt",
  "assertion": "assertEquals ( null, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( null, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_6.txt",
  "assertion": "assertEquals ( expected, null )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, null ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_7.txt",
  "assertion": "assertEquals ( expecting, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expecting, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_8.txt",
  "assertion": "assertEquals ( expected, expecting )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( expected, expecting ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "94_9.txt",
  "assertion": "assertEquals ( assumed, expected )\r\n",
  "test": "class X {public void testGetSchema ( ) { Schema expected \u003d AvroUtils . _string ( ) ; AvroConverter \u003c ? , ? \u003e converter \u003d new BigDecimalStringConverter ( ) ; Schema actual \u003d converter . getSchema ( ) ; assertEquals ( assumed, expected ) ; }  }\r\n",
  "focal method": "class Y{ public void getSchema() { throw new UnsupportedOperationException ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "95_0.txt",
  "assertion": "assertTrue ( ( ( result sr ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_1.txt",
  "assertion": "assertTrue ( ( ( result sp ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_10.txt",
  "assertion": "assertTrue ( ( ( result s\u0027 ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s\u0027 ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_11.txt",
  "assertion": "assertTrue ( ( ( result sp ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_12.txt",
  "assertion": "assertTrue ( ( ( result sr ) \u003d\u003d 2 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \u003d\u003d 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_13.txt",
  "assertion": "assertTrue ( ( ( result s q ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s q ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_14.txt",
  "assertion": "assertTrue ( ( ( result ssq ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result ssq ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_15.txt",
  "assertion": "assertTrue ( ( ( result sf ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sf ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_16.txt",
  "assertion": "assertTrue ( ( ( result sp ) \u003d\u003d 2 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \u003d\u003d 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_17.txt",
  "assertion": "assertTrue ( ( ( result sc ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sc ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_18.txt",
  "assertion": "assertTrue ( ( ( result s1 ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s1 ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_19.txt",
  "assertion": "assertTrue ( ( ( result sr ) \u003d\u003d 1 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \u003d\u003d 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_2.txt",
  "assertion": "assertTrue ( ( ( result s q ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s q ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_20.txt",
  "assertion": "assertTrue ( ( ( result s q ) \u003d\u003d 2 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s q ) \u003d\u003d 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_21.txt",
  "assertion": "assertTrue ( ( ( result sv ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sv ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_22.txt",
  "assertion": "assertTrue ( ( ( result sr ) \u003d\u003d null ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \u003d\u003d null ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_23.txt",
  "assertion": "assertTrue ( ( ( result sf ) \u003d\u003d 2 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sf ) \u003d\u003d 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_24.txt",
  "assertion": "assertTrue ( ( ( result sk ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sk ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_25.txt",
  "assertion": "assertTrue ( ( ( result sx ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sx ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_26.txt",
  "assertion": "assertTrue ( ( ( result sg ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sg ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_27.txt",
  "assertion": "assertTrue ( ( ( result sp ) \u003d\u003d 1 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sp ) \u003d\u003d 1 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_28.txt",
  "assertion": "assertTrue ( ( ( result smp ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result smp ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_29.txt",
  "assertion": "assertTrue ( ( ( result sc ) \u003d\u003d 2 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sc ) \u003d\u003d 2 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_3.txt",
  "assertion": "assertTrue ( ( ( result sf ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sf ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_4.txt",
  "assertion": "assertTrue ( ( ( result sc ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sc ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_5.txt",
  "assertion": "assertTrue ( ( ( result s1 ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result s1 ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_6.txt",
  "assertion": "assertTrue ( ( ( result sv ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sv ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_7.txt",
  "assertion": "assertTrue ( ( ( result sk ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sk ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_8.txt",
  "assertion": "assertTrue ( ( ( result sg ) \u003d\u003d expected ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sg ) \u003d\u003d expected ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_9.txt",
  "assertion": "assertTrue ( ( ( result sr ) \u003d\u003d 0 ) )\r\n",
  "test": "class X {public void testGetIndirectMoveSq_ConstraintsA1_5 ( ) { resultSq \u003d Direction . getIndirectMoveSq ( inputSq ) ; assertTrue ( ( ( result sr ) \u003d\u003d 0 ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getIndirectMoveSq( Direction  var24678 , GenericPosition  var24678 ) { GenericPosition retVal \u003d null ; switch ( dir ) { case downLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case downRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R2 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . prev ( ) . rank . prev ( ) ) ; } break ; case leftUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . next ( ) ) ; } break ; case leftDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fb ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) . file . prev ( ) , rank . prev ( ) ) ; } break ; case rightUp : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . next ( ) ) ; } break ; case rightDown : if ( ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fg ) ) \u0026\u0026 ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R1 ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) . file . next ( ) , rank . prev ( ) ) ; } break ; case upLeft : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fa ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . prev ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; case upRight : if ( ( ( onSquare . file ) !\u003d ( com . fluxchess . jcpi . models . GenericFile . Fh ) ) \u0026\u0026 ( ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R8 ) ) \u0026\u0026 ( ( onSquare . rank ) !\u003d ( com . fluxchess . jcpi . models . GenericRank . R7 ) ) ) ) { retVal \u003d GenericPosition . valueOf ( file . next ( ) , rank . next ( ) . rank . next ( ) ) ; } break ; default : break ; } return retVal ; } }\r\n",
  "truth": "assertTrue ( ( ( resultSq ) \u003d\u003d null ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "96_0.txt",
  "assertion": "assertTrue ( p. value ( \"value\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \"value\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_1.txt",
  "assertion": "assertTrue ( p. value ( \"c\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \"c\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_10.txt",
  "assertion": "assertTrue ( p. validate ( \"c\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \"c\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_11.txt",
  "assertion": "assertTrue ( p. can ( \"value\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. can ( \"value\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_12.txt",
  "assertion": "assertTrue ( p. evaluate ( \"value\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. evaluate ( \"value\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_13.txt",
  "assertion": "assertTrue ( p. group ( \"cas\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \"cas\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_14.txt",
  "assertion": "assertTrue ( p. matches ( \"c\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \"c\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_15.txt",
  "assertion": "assertTrue ( p. match ( \"c\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \"c\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_16.txt",
  "assertion": "assertTrue ( p. can ( \"c\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. can ( \"c\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_17.txt",
  "assertion": "assertTrue ( p. evaluate ( \"c\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. evaluate ( \"c\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_18.txt",
  "assertion": "assertTrue ( p. validate ( \"cas\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \"cas\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_19.txt",
  "assertion": "assertTrue ( p. matches ( \"cas\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \"cas\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_2.txt",
  "assertion": "assertTrue ( p. value ( \"cas\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \"cas\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_20.txt",
  "assertion": "assertTrue ( p. group ( \"matched\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \"matched\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_21.txt",
  "assertion": "assertTrue ( p. match ( \"cas\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \"cas\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_22.txt",
  "assertion": "assertTrue ( p. group ( \"1\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \"1\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_23.txt",
  "assertion": "assertTrue ( p. can ( \"cas\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. can ( \"cas\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_24.txt",
  "assertion": "assertTrue ( p. value ( \"test\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \"test\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_25.txt",
  "assertion": "assertTrue ( p. evaluate ( \"cas\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. evaluate ( \"cas\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_26.txt",
  "assertion": "assertTrue ( p. validate ( \"matched\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \"matched\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_27.txt",
  "assertion": "assertTrue ( p. validate ( \"1\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \"1\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_28.txt",
  "assertion": "assertTrue ( p. matches ( \"matched\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \"matched\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_29.txt",
  "assertion": "assertTrue ( p. match ( \"matched\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \"matched\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_3.txt",
  "assertion": "assertTrue ( p. group ( \"value\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \"value\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_4.txt",
  "assertion": "assertTrue ( p. group ( \"c\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. group ( \"c\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_5.txt",
  "assertion": "assertTrue ( p. value ( \"matched\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \"matched\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_6.txt",
  "assertion": "assertTrue ( p. validate ( \"value\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. validate ( \"value\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_7.txt",
  "assertion": "assertTrue ( p. value ( \"1\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. value ( \"1\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_8.txt",
  "assertion": "assertTrue ( p. matches ( \"value\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. matches ( \"value\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_9.txt",
  "assertion": "assertTrue ( p. match ( \"value\" ) )\r\n",
  "test": "class X {public void testValidPrincipalMultivaluedAttributeToGreet ( ) { final Map map \u003d new HashMap ( ) ; map . Arrays . put ( \"firstName\" , Arrays . asList ( \"cas\" , \"sso\" ) ) ; map . put ( \"lastName\" , \"user\" ) ; final Principal p \u003d principalFactory . createPrincipal ( \"userid\" , map ) ; final MultifactorLoginViewPrincipalAttributeGreeter greeter \u003d new MultifactorLoginViewPrincipalAttributeGreeter ( \"firstName\" ) ; configureMessageContextForPrincipal ( \"cas\" ) ; final String value \u003d greeter . messageContext . getPersonToGreet ( p ) ; assertTrue ( p. match ( \"value\" ) ) ; }  }\r\n",
  "focal method": "class Y{ public void getPersonToGreet( Principal  var24678 , MessageContext  var24678 ) { String personId \u003d p . getId ( ) ; final Object attrValue \u003d p . getAttributes ( ) . greetingAttributeName . get ( ) ; if ( attrValue \u003d\u003d null ) { LOGGER . warn ( \"No\u003csp\u003eattribute\u003csp\u003evalue\u003csp\u003ecould\u003csp\u003ebe\u003csp\u003efound\u003csp\u003efor\u003csp\u003e[{}]\" ) ; return p . getId ( ) ; } String greetingPersonId \u003d attrValue . toString ( ) ; if ( attrValue instanceof Collection ) { final Collection col \u003d ( ( Collection ) ( attrValue ) ) ; if ( ! ( col . isEmpty ( ) ) ) { greetingPersonId \u003d col . iterator ( ) . next ( ) . toString ( ) ; LOGGER . warn ( \"Found\u003csp\u003emultiple\u003csp\u003eattribute\u003csp\u003evalues\u003csp\u003e[{}]\u003csp\u003efor\u003csp\u003e[{}]\u003csp\u003eto\u003csp\u003egreet.\u003csp\u003ePicked\u003csp\u003e[{}]\" , attrValue , greetingPersonId ) ; } } if ( ! ( StringUtils . isBlank ( greetingPersonId ) ) ) { personId \u003d greetingPersonId ; } final MessageResolver resolver \u003d new MessageBuilder ( ) . CODE . source ( ) . CODE . info ( ) . CODE . code ( ) . CODE . arg ( personId ) . CODE . build ( ) ; messageContext . addMessage ( resolver ) ; final Message [ ] messages \u003d messageContext . CODE . getMessagesBySource ( ) ; if ( ( messages \u003d\u003d null ) || ( ( messages . length ) \u003d\u003d 0 ) ) { LOGGER . warn ( ( \"The\u003csp\u003egreeting\u003csp\u003emessage\u003csp\u003efor\u003csp\u003eprincipal\u003csp\u003e[{}]\u003csp\u003ecould\u003csp\u003enot\u003csp\u003ebe\u003csp\u003eresolved\u003csp\u003eby\u003csp\u003ethe\u003csp\u003e\" + \"code\u003csp\u003e[{}]\u003csp\u003ein\u003csp\u003eany\u003csp\u003eof\u003csp\u003ethe\u003csp\u003econfigured\u003csp\u003emessage\u003csp\u003eresource\u003csp\u003ebundles.\u003csp\u003eFalling\u003csp\u003eback\u003csp\u003eto\u003csp\u003eprincipal\u003csp\u003eid\u003csp\u003e[{}]\" ) , p , p . getId ( ) ) ; return p . getId ( ) ; } return messages [ 0 ] . getText ( ) ; } }\r\n",
  "truth": "assertTrue ( value. contains ( \"cas\" ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_0.txt",
  "assertion": "assertEquals ( new file ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_1.txt",
  "assertion": "assertEquals ( read file ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_10.txt",
  "assertion": "assertEquals ( read file ( file ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( file ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_11.txt",
  "assertion": "assertEquals ( new Read ( file ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( file ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_12.txt",
  "assertion": "assertEquals ( read Read ( download ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( download ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_13.txt",
  "assertion": "assertEquals ( get file ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( get file ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_14.txt",
  "assertion": "assertEquals ( read file ( local ), new File )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( local ), new File ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_15.txt",
  "assertion": "assertEquals ( read File ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read File ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_16.txt",
  "assertion": "assertEquals ( new Read ( local ), new File )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( local ), new File ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_17.txt",
  "assertion": "assertEquals ( read Read ( file ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( file ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_18.txt",
  "assertion": "assertEquals ( new Local ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Local ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_19.txt",
  "assertion": "assertEquals ( new Stream ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Stream ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_2.txt",
  "assertion": "assertEquals ( new Read ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_20.txt",
  "assertion": "assertEquals ( get Read ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( get Read ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_21.txt",
  "assertion": "assertEquals ( read Read ( local ), new File )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( local ), new File ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_22.txt",
  "assertion": "assertEquals ( new file ( source ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( source ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_23.txt",
  "assertion": "assertEquals ( new file ( path ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( path ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_24.txt",
  "assertion": "assertEquals ( new file ( content ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( content ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_25.txt",
  "assertion": "assertEquals ( read Local ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Local ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_26.txt",
  "assertion": "assertEquals ( read Stream ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Stream ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_27.txt",
  "assertion": "assertEquals ( new file ( input ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( input ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_28.txt",
  "assertion": "assertEquals ( new file ( local ), local file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( local ), local file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_29.txt",
  "assertion": "assertEquals ( local file ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( local file ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_3.txt",
  "assertion": "assertEquals ( read Read ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read Read ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_4.txt",
  "assertion": "assertEquals ( new file ( download ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( download ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_5.txt",
  "assertion": "assertEquals ( new file ( file ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( file ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_6.txt",
  "assertion": "assertEquals ( read file ( download ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( read file ( download ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_7.txt",
  "assertion": "assertEquals ( new Read ( download ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new Read ( download ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_8.txt",
  "assertion": "assertEquals ( new file ( local ), new File )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new file ( local ), new File ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_9.txt",
  "assertion": "assertEquals ( new File ( local ), new file )\r\n",
  "test": "class X {public void copyFromLocalFileToDstPathTest ( ) { String dataString \u003d \"copyFromLocalFileToDstPathTest\" ; byte [ ] data \u003d dataString . getBytes ( ) ; File localDir \u003d new File ( ( ( mLocalAlluxioCluster . getAlluxioHome ( ) ) + \"/localDir\" ) ) ; localDir . mkdir ( ) ; File localFile \u003d generateFileContent ( \"/localDir/testFile\" , data ) ; alluxioInterpreter . interpret ( \"mkdir\u003csp\u003e/dstDir\" , null ) ; alluxioInterpreter . interpret ( ( ( \"copyFromLocal\u003csp\u003e\" + ( localFile . getPath ( ) ) ) + \"\u003csp\u003e/dstDir\" ) , null ) ; FileInStream fStream \u003d fs . openFile ( new AlluxioURI ( \"/dstDir/testFile\" ) ) ; long fileLength \u003d fs . getStatus ( new AlluxioURI ( \"/dstDir/testFile\" ) ) . getLength ( ) ; byte [ ] read \u003d new byte [ ( ( int ) ( fileLength ) ) ] ; fStream . read ( read ) ; assertEquals ( new File ( local ), new file ) ; }  }\r\n",
  "focal method": "class Y{ public void read( JsonReader  var24678 ) { JsonElement jsonElement \u003d Streams . parse ( in ) ; JsonElement labelJsonElement \u003d jsonElement . getAsJsonObject ( ) . remove ( typeFieldName ) ; String label \u003d ( labelJsonElement \u003d\u003d null ) ? null : labelJsonElement . getAsString ( ) ; @ org . apache . zeppelin . display . SuppressWarnings ( \"unchecked\" ) TypeAdapter \u003c R \u003e delegate \u003d ( ( TypeAdapter \u003c R \u003e ) ( labelToDelegate . get ( label ) ) ) ; if ( delegate \u003d\u003d null ) { throw new JsonParseException ( ( ( ( ( \"cannot\u003csp\u003edeserialize\u003csp\u003e\" + ( baseType ) ) + \"\u003csp\u003esubtype\u003csp\u003enamed\u003csp\u003e\" ) + label ) + \";\u003csp\u003edid\u003csp\u003eyou\u003csp\u003eforget\u003csp\u003eto\u003csp\u003eregister\u003csp\u003ea\u003csp\u003esubtype?\" ) ) ; } return delegate . fromJsonTree ( jsonElement ) ; } }\r\n",
  "truth": "assertEquals ( new String ( read ), dataString )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_0.txt",
  "assertion": "assertTrue ( figures. ends contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. ends contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_1.txt",
  "assertion": "assertTrue ( figures. ends empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. ends empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_10.txt",
  "assertion": "assertTrue ( figures. empty contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. empty contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_11.txt",
  "assertion": "assertTrue ( figures. empty empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. empty empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_12.txt",
  "assertion": "assertTrue ( figures. is contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. is contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_13.txt",
  "assertion": "assertTrue ( figures. is empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. is empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_14.txt",
  "assertion": "assertTrue ( figures. first contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. first contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_15.txt",
  "assertion": "assertTrue ( figures. first empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. first empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_16.txt",
  "assertion": "assertTrue ( figures. zero contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. zero contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_17.txt",
  "assertion": "assertTrue ( figures. zero empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. zero empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_18.txt",
  "assertion": "assertTrue ( figures. impl contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. impl contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_19.txt",
  "assertion": "assertTrue ( figures. has contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. has contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_2.txt",
  "assertion": "assertTrue ( figures. matches contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. matches contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_20.txt",
  "assertion": "assertTrue ( figures. impl empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. impl empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_21.txt",
  "assertion": "assertTrue ( figures. has empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. has empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_22.txt",
  "assertion": "assertTrue ( figures. all contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. all contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_23.txt",
  "assertion": "assertTrue ( figures. all empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. all empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_24.txt",
  "assertion": "assertTrue ( figures. equals contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. equals contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_25.txt",
  "assertion": "assertTrue ( figures. equals empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. equals empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_26.txt",
  "assertion": "assertTrue ( figures. e contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. e contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_27.txt",
  "assertion": "assertTrue ( figures. e empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. e empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_28.txt",
  "assertion": "assertTrue ( figures. test contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. test contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_29.txt",
  "assertion": "assertTrue ( figures. test empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. test empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_3.txt",
  "assertion": "assertTrue ( figures. matches empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. matches empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_4.txt",
  "assertion": "assertTrue ( figures. starts contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. starts contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_5.txt",
  "assertion": "assertTrue ( figures. starts empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. starts empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_6.txt",
  "assertion": "assertTrue ( figures. null contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. null contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_7.txt",
  "assertion": "assertTrue ( figures. null empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. null empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_8.txt",
  "assertion": "assertTrue ( figures. contains contains ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. contains contains ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_9.txt",
  "assertion": "assertTrue ( figures. contains empty ( ) )\r\n",
  "test": "class X {public void extractFigDesc4 ( ) { String pargraphText \u003d \"FIG.\u003csp\u003e1\" ; List \u003c Figure \u003e figures \u003d new ArrayList \u003c Figure \u003e ( ) ; DescriptionFigures . findFigures ( pargraphText , figures ) ; assertTrue ( figures. contains empty ( ) ) ; }  }\r\n",
  "focal method": "class Y{ public void findFigures( String  var24678 , List  var24678 ) { Figure figure \u003d null ; int figEnd \u003d 0 ; String figText \u003d \"\" ; Matcher matchFig \u003d PATENT_FIG . matcher ( pargraphText ) ; if ( matchFig . lookingAt ( ) ) { String id \u003d matchFig . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFig . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; figure \u003d new Figure ( figText , id ) ; } } else { Matcher matchFigs \u003d PATENT_FIGS . matcher ( pargraphText ) ; if ( matchFigs . lookingAt ( ) ) { String id \u003d matchFigs . group ( 1 ) ; if ( ! ( id . equals ( pargraphText ) ) ) { figEnd \u003d matchFigs . end ( ) ; figText \u003d pargraphText . substring ( ( figEnd + 1 ) ) ; Figure fig \u003d new Figure ( figText , id ) ; figureList . add ( fig ) ; } } else { if ( pargraphText . matches ( \"^FIG\" ) ) { LOGGER . warn ( ( \"Unable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } else { LOGGER . trace ( ( \"2.\u003csp\u003eUnable\u003csp\u003eto\u003csp\u003eParse\u003csp\u003ePatent\u003csp\u003eFigure\u003csp\u003eID:\u003csp\u003e\u0027\" + pargraphText ) ) ; } } } if ( figure !\u003d null ) { figureList . add ( figure ) ; } } }\r\n",
  "truth": "assertTrue ( figures. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_0.txt",
  "assertion": "assertEquals ( new 1 [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_1.txt",
  "assertion": "assertEquals ( new byte [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_10.txt",
  "assertion": "assertEquals ( new b [ 1 ], b [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new b [ 1 ], b [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "99_11.txt",
  "assertion": "assertEquals ( io b [ 1 ], b [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io b [ 1 ], b [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_12.txt",
  "assertion": "assertEquals ( new 1 [ 1 ], a [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], a [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_13.txt",
  "assertion": "assertEquals ( new byte [ 1 ], a [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], a [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "99_14.txt",
  "assertion": "assertEquals ( io 1 [ 1 ], a [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], a [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_15.txt",
  "assertion": "assertEquals ( io byte [ 1 ], a [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], a [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_16.txt",
  "assertion": "assertEquals ( new b [ 1 ], a [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new b [ 1 ], a [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "99_17.txt",
  "assertion": "assertEquals ( io b [ 1 ], a [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io b [ 1 ], a [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_18.txt",
  "assertion": "assertEquals ( new 2 [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 2 [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_19.txt",
  "assertion": "assertEquals ( new 1 [ 2 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 2 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_2.txt",
  "assertion": "assertEquals ( io 1 [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_20.txt",
  "assertion": "assertEquals ( new 1 [ 1 ], byte [ 2 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], byte [ 2 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_21.txt",
  "assertion": "assertEquals ( new byte [ 2 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new byte [ 2 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_22.txt",
  "assertion": "assertEquals ( new byte [ 1 ], byte [ 2 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], byte [ 2 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_23.txt",
  "assertion": "assertEquals ( io 2 [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io 2 [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_24.txt",
  "assertion": "assertEquals ( io 1 [ 2 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 2 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_25.txt",
  "assertion": "assertEquals ( io 1 [ 1 ], byte [ 2 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], byte [ 2 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_26.txt",
  "assertion": "assertEquals ( io byte [ 2 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io byte [ 2 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_27.txt",
  "assertion": "assertEquals ( io byte [ 1 ], byte [ 2 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], byte [ 2 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_28.txt",
  "assertion": "assertEquals ( new 1 [ 0 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 0 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_29.txt",
  "assertion": "assertEquals ( new 1 [ 1 ], byte [ 0 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], byte [ 0 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_3.txt",
  "assertion": "assertEquals ( io byte [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_4.txt",
  "assertion": "assertEquals ( new 1 [ 1 ], b [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new 1 [ 1 ], b [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_5.txt",
  "assertion": "assertEquals ( new byte [ 1 ], b [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new byte [ 1 ], b [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "99_6.txt",
  "assertion": "assertEquals ( new b [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( new b [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_7.txt",
  "assertion": "assertEquals ( io 1 [ 1 ], b [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io 1 [ 1 ], b [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_8.txt",
  "assertion": "assertEquals ( io b [ 1 ], byte [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io b [ 1 ], byte [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_9.txt",
  "assertion": "assertEquals ( io byte [ 1 ], b [ 1 ] )\r\n",
  "test": "class X {public void testGet ( ) { ByteBuffer bb1 \u003d ByteBuffer . allocate ( 5 ) ; bb1 . put ( \"012\" . getBytes ( ) ) ; bb1 . flip ( ) ; ByteBuffer bb2 \u003d ByteBuffer . allocate ( 5 ) ; bb2 . put ( \"345\" . getBytes ( ) ) ; bb2 . flip ( ) ; ByteBuffer bb3 \u003d ByteBuffer . allocate ( 5 ) ; bb3 . put ( \"6789\" . getBytes ( ) ) ; bb3 . flip ( ) ; IoBuffer ioBuffer \u003d IoBuffer . newInstance ( ) ; ioBuffer . add ( bb1 , bb2 ) . add ( bb3 ) ; ioBuffer . position ( 2 ) ; ioBuffer . limit ( 8 ) ; byte [ ] block \u003d new byte [ 6 ] ; ioBuffer . get ( block ) ; byte [ ] seg \u003d \"234567\" . getBytes ( ) ; for ( int i \u003d 0 ; i \u003c 6 ; i ++ ) { } assertEquals ( io byte [ 1 ], b [ 1 ] ) ; }  }\r\n",
  "focal method": "class Y{ public void get( Object  var24678 ) { ExpiringValue \u003c V \u003e expValue \u003d map . get ( key ) ; if ( expValue !\u003d null ) { return expValue . value ; } return null ; } }\r\n",
  "truth": "assertEquals ( seg [ i ], block [ i ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "9_0.txt",
  "assertion": "assertEquals ( instant, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_1.txt",
  "assertion": "assertEquals ( null, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( null, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_10.txt",
  "assertion": "assertEquals ( instant, date )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, date ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_11.txt",
  "assertion": "assertEquals ( 0, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 0, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_12.txt",
  "assertion": "assertEquals ( instant, 0 )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, 0 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_13.txt",
  "assertion": "assertEquals ( \"\", instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( \"\", instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_14.txt",
  "assertion": "assertEquals ( instant, \"\" )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, \"\" ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_15.txt",
  "assertion": "assertEquals (Instant, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals (Instant, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_16.txt",
  "assertion": "assertEquals ( instant,Instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant,Instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_17.txt",
  "assertion": "assertEquals ( expected, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( expected, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "9_18.txt",
  "assertion": "assertEquals ( 2, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 2, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_19.txt",
  "assertion": "assertEquals ( instant, 2 )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, 2 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_2.txt",
  "assertion": "assertEquals ( instant, null )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, null ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_20.txt",
  "assertion": "assertEquals ( 3, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 3, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_21.txt",
  "assertion": "assertEquals ( instant, 3 )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, 3 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_22.txt",
  "assertion": "assertEquals ( epoch, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( epoch, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_23.txt",
  "assertion": "assertEquals ( instant, epoch )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, epoch ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_24.txt",
  "assertion": "assertEquals ( 2010, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 2010, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_25.txt",
  "assertion": "assertEquals ( leap, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( leap, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_26.txt",
  "assertion": "assertEquals ( now, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( now, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_27.txt",
  "assertion": "assertEquals ( instant, now )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, now ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_28.txt",
  "assertion": "assertEquals ( 5, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 5, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_29.txt",
  "assertion": "assertEquals ( instant, 5 )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, 5 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_3.txt",
  "assertion": "assertEquals ( Instant, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( Instant, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_4.txt",
  "assertion": "assertEquals ( instant, Instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, Instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_5.txt",
  "assertion": "assertEquals ( 1, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 1, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_6.txt",
  "assertion": "assertEquals ( instant, 1 )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, 1 ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_7.txt",
  "assertion": "assertEquals ( UTC, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( UTC, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_8.txt",
  "assertion": "assertEquals ( instant, UTC )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( instant, UTC ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "9_9.txt",
  "assertion": "assertEquals ( date, instant )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( date, instant ) ; }  }\r\n",
  "focal method": "class Y{ public void parse( String  var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "instant",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
