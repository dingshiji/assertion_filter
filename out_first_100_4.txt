{
  "file": "0_0.txt",
  "assertion": "assertNotNull ( existingLayout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( existingLayout ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "existingLayout",
  "parse context": "finished",
  "correct answer": "true",
  "result": "Good assertion"
}
,
{
  "file": "0_1.txt",
  "assertion": "assertNotNull ( oldLocation )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( oldLocation ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_10.txt",
  "assertion": "assertNotNull ( previous layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( previous layout ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_11.txt",
  "assertion": "assertNotNull ( alreadyConfiguration )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( alreadyConfiguration ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_12.txt",
  "assertion": "assertNotNull ( appAppearance )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( appAppearance ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_13.txt",
  "assertion": "assertNotNull ( creatingView )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( creatingView ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_14.txt",
  "assertion": "assertNotNull ( current Layout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( current Layout ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "0_15.txt",
  "assertion": "assertNotNull ( removingDesign )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( removingDesign ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_16.txt",
  "assertion": "assertNotNull ( usingPattern )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( usingPattern ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_17.txt",
  "assertion": "assertNotNull ( activeWidget )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( activeWidget ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_18.txt",
  "assertion": "assertNotNull ( existedLay )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( existedLay ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_19.txt",
  "assertion": "assertNotNull ( theParent )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( theParent ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_2.txt",
  "assertion": "assertNotNull ( newStyle )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( newStyle ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_20.txt",
  "assertion": "assertNotNull ( expectedContent )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( expectedContent ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_21.txt",
  "assertion": "assertNotNull ( beingComponent )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( beingComponent ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_22.txt",
  "assertion": "assertNotNull ( actualDelta )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( actualDelta ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_23.txt",
  "assertion": "assertNotNull ( originalContainer )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( originalContainer ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_24.txt",
  "assertion": "assertNotNull ( replacingL )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( replacingL ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_25.txt",
  "assertion": "assertNotNull ( missingUpdate )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( missingUpdate ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_26.txt",
  "assertion": "assertNotNull ( availableLanguage )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( availableLanguage ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_27.txt",
  "assertion": "assertNotNull ( emptyBuilder )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( emptyBuilder ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_28.txt",
  "assertion": "assertNotNull ( readingLeft )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( readingLeft ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_29.txt",
  "assertion": "assertNotNull ( remainingAlias )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( remainingAlias ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_3.txt",
  "assertion": "assertNotNull ( editinglayout )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( editinglayout ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_4.txt",
  "assertion": "assertNotNull ( matchingFont )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( matchingFont ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_5.txt",
  "assertion": "assertNotNull (istingWidth )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull (istingWidth ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_6.txt",
  "assertion": "assertNotNull ( existsOffset )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( existsOffset ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_7.txt",
  "assertion": "assertNotNull ( updatingTemplate )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( updatingTemplate ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_8.txt",
  "assertion": "assertNotNull (existingPosition )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull (existingPosition ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "0_9.txt",
  "assertion": "assertNotNull ( validLayer )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertNotNull ( validLayer ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertNotNull ( existingLayout )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_0.txt",
  "assertion": "assertEquals ( date, date )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( date, date ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_1.txt",
  "assertion": "assertEquals ( avg, dat )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( avg, dat ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_10.txt",
  "assertion": "assertEquals ( agg, now )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( agg, now ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_11.txt",
  "assertion": "assertEquals ( 7, data )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, data ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_12.txt",
  "assertion": "assertEquals ( today, 2 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( today, 2 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_13.txt",
  "assertion": "assertEquals ( now, 42 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( now, 42 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_14.txt",
  "assertion": "assertEquals ( 3, average )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, average ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_15.txt",
  "assertion": "assertEquals ( expected, time )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( expected, time ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_16.txt",
  "assertion": "assertEquals ( start, rate )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( start, rate ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_17.txt",
  "assertion": "assertEquals ( min, value )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( min, value ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_18.txt",
  "assertion": "assertEquals ( time, 8 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( time, 8 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_19.txt",
  "assertion": "assertEquals ( base, Date )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( base, Date ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_2.txt",
  "assertion": "assertEquals ( 0, avg )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, avg ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_20.txt",
  "assertion": "assertEquals ( update, d )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( update, d ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_21.txt",
  "assertion": "assertEquals ( 8, start )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, start ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_22.txt",
  "assertion": "assertEquals ( Date, age )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( Date, age ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_23.txt",
  "assertion": "assertEquals ( 4, 2018 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, 2018 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_24.txt",
  "assertion": "assertEquals ( bc, end )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( bc, end ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_25.txt",
  "assertion": "assertEquals ( data, m )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( data, m ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_26.txt",
  "assertion": "assertEquals ( aggregate, result )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( aggregate, result ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_27.txt",
  "assertion": "assertEquals ( year, 3 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( year, 3 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_28.txt",
  "assertion": "assertEquals ( current, mean )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( current, mean ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_29.txt",
  "assertion": "assertEquals ( 42, 2015 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 42, 2015 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_3.txt",
  "assertion": "assertEquals ( dat, 0 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( dat, 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_4.txt",
  "assertion": "assertEquals ( 1, g )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, g ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_5.txt",
  "assertion": "assertEquals ( average, today )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( average, today ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_6.txt",
  "assertion": "assertEquals ( index, 1 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( index, 1 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_7.txt",
  "assertion": "assertEquals ( 2, index )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, index ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_8.txt",
  "assertion": "assertEquals ( g, 7 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( g, 7 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "10_9.txt",
  "assertion": "assertEquals ( mean, update )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( mean, update ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( avg, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "11_0.txt",
  "assertion": "assertEquals ( 1, res. size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1, res. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_1.txt",
  "assertion": "assertEquals ( 0, 0.size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_10.txt",
  "assertion": "assertEquals ( 10, list. sizeof ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 10, list. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_11.txt",
  "assertion": "assertEquals ( 100, 3. number ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 100, 3. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_12.txt",
  "assertion": "assertEquals ( 16, this. bytes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 16, this. bytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_13.txt",
  "assertion": "assertEquals ( 20, 4. name ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 20, 4. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_14.txt",
  "assertion": "assertEquals (1, Res. score ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals (1, Res. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_15.txt",
  "assertion": "assertEquals ( 15, exception. shape ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 15, exception. shape ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_16.txt",
  "assertion": "assertEquals ( 255, Array. values ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 255, Array. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_17.txt",
  "assertion": "assertEquals ( 11, ex. index ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 11, ex. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_18.txt",
  "assertion": "assertEquals ( 19, map. sizing ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 19, map. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_19.txt",
  "assertion": "assertEquals ( 12, results. empty ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 12, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_2.txt",
  "assertion": "assertEquals ( 3, set. Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 3, set. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_20.txt",
  "assertion": "assertEquals ( 200, 2. value ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 200, 2. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_21.txt",
  "assertion": "assertEquals ( null, true. run ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( null, true. run ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_22.txt",
  "assertion": "assertEquals ( 98, int. resize ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 98, int. resize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_23.txt",
  "assertion": "assertEquals ( size, sys. capacity ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( size, sys. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_24.txt",
  "assertion": "assertEquals ( 23, sets. order ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 23, sets. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_25.txt",
  "assertion": "assertEquals ( one, count. rank ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( one, count. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_26.txt",
  "assertion": "assertEquals ( 31, size. weight ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 31, size. weight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_27.txt",
  "assertion": "assertEquals ( 33, 6. members ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 33, 6. members ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_28.txt",
  "assertion": "assertEquals ( expected, system. member ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expected, system. member ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_29.txt",
  "assertion": "assertEquals ( \"\", result. body ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( \"\", result. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_3.txt",
  "assertion": "assertEquals ( 2, 1. count ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 2, 1. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "11_4.txt",
  "assertion": "assertEquals ( 4, Exception. sizes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 4, Exception. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_5.txt",
  "assertion": "assertEquals ( 6, System. length ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 6, System. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_6.txt",
  "assertion": "assertEquals ( 5, exceptions. get ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 5, exceptions. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_7.txt",
  "assertion": "assertEquals ( 8, null. sum ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 8, null. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_8.txt",
  "assertion": "assertEquals ( 9, resources. sized ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 9, resources. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "11_9.txt",
  "assertion": "assertEquals ( 7, array.Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 7, array.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 0, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_0.txt",
  "assertion": "assertEquals ( 1, res. size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1, res. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_1.txt",
  "assertion": "assertEquals ( 0, 0.size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_10.txt",
  "assertion": "assertEquals ( 10, list. sizeof ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 10, list. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_11.txt",
  "assertion": "assertEquals ( 100, 3. number ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 100, 3. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_12.txt",
  "assertion": "assertEquals ( 16, this. bytes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 16, this. bytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_13.txt",
  "assertion": "assertEquals ( 20, 4. name ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 20, 4. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_14.txt",
  "assertion": "assertEquals (1, Res. score ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals (1, Res. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_15.txt",
  "assertion": "assertEquals ( 15, exception. shape ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 15, exception. shape ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_16.txt",
  "assertion": "assertEquals ( 255, Array. values ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 255, Array. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_17.txt",
  "assertion": "assertEquals ( 11, ex. index ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 11, ex. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_18.txt",
  "assertion": "assertEquals ( 19, map. sizing ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 19, map. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_19.txt",
  "assertion": "assertEquals ( 12, results. empty ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 12, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_2.txt",
  "assertion": "assertEquals ( 3, set. Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 3, set. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_20.txt",
  "assertion": "assertEquals ( 200, 2. value ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 200, 2. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_21.txt",
  "assertion": "assertEquals ( null, true. run ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( null, true. run ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_22.txt",
  "assertion": "assertEquals ( 98, int. resize ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 98, int. resize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_23.txt",
  "assertion": "assertEquals ( size, sys. capacity ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( size, sys. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_24.txt",
  "assertion": "assertEquals ( 23, sets. order ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 23, sets. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_25.txt",
  "assertion": "assertEquals ( one, count. rank ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( one, count. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_26.txt",
  "assertion": "assertEquals ( 31, size. weight ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 31, size. weight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_27.txt",
  "assertion": "assertEquals ( 33, 6. members ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 33, 6. members ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_28.txt",
  "assertion": "assertEquals ( expected, system. member ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expected, system. member ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_29.txt",
  "assertion": "assertEquals ( \"\", result. body ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( \"\", result. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_3.txt",
  "assertion": "assertEquals ( 2, 1. count ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 2, 1. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "12_4.txt",
  "assertion": "assertEquals ( 4, Exception. sizes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 4, Exception. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_5.txt",
  "assertion": "assertEquals ( 6, System. length ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 6, System. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_6.txt",
  "assertion": "assertEquals ( 5, exceptions. get ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 5, exceptions. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_7.txt",
  "assertion": "assertEquals ( 8, null. sum ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 8, null. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_8.txt",
  "assertion": "assertEquals ( 9, resources. sized ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 9, resources. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "12_9.txt",
  "assertion": "assertEquals ( 7, array.Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 7, array.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 200, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_0.txt",
  "assertion": "assertEquals ( 1, res. size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1, res. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_1.txt",
  "assertion": "assertEquals ( 0, 0.size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_10.txt",
  "assertion": "assertEquals ( 10, list. sizeof ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 10, list. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_11.txt",
  "assertion": "assertEquals ( 100, 3. number ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 100, 3. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_12.txt",
  "assertion": "assertEquals ( 16, this. bytes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 16, this. bytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_13.txt",
  "assertion": "assertEquals ( 20, 4. name ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 20, 4. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_14.txt",
  "assertion": "assertEquals (1, Res. score ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals (1, Res. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_15.txt",
  "assertion": "assertEquals ( 15, exception. shape ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 15, exception. shape ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_16.txt",
  "assertion": "assertEquals ( 255, Array. values ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 255, Array. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_17.txt",
  "assertion": "assertEquals ( 11, ex. index ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 11, ex. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_18.txt",
  "assertion": "assertEquals ( 19, map. sizing ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 19, map. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_19.txt",
  "assertion": "assertEquals ( 12, results. empty ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 12, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_2.txt",
  "assertion": "assertEquals ( 3, set. Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 3, set. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_20.txt",
  "assertion": "assertEquals ( 200, 2. value ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 200, 2. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_21.txt",
  "assertion": "assertEquals ( null, true. run ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( null, true. run ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_22.txt",
  "assertion": "assertEquals ( 98, int. resize ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 98, int. resize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_23.txt",
  "assertion": "assertEquals ( size, sys. capacity ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( size, sys. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_24.txt",
  "assertion": "assertEquals ( 23, sets. order ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 23, sets. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_25.txt",
  "assertion": "assertEquals ( one, count. rank ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( one, count. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_26.txt",
  "assertion": "assertEquals ( 31, size. weight ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 31, size. weight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_27.txt",
  "assertion": "assertEquals ( 33, 6. members ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 33, 6. members ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_28.txt",
  "assertion": "assertEquals ( expected, system. member ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expected, system. member ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_29.txt",
  "assertion": "assertEquals ( \"\", result. body ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( \"\", result. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_3.txt",
  "assertion": "assertEquals ( 2, 1. count ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 2, 1. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "13_4.txt",
  "assertion": "assertEquals ( 4, Exception. sizes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 4, Exception. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_5.txt",
  "assertion": "assertEquals ( 6, System. length ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 6, System. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_6.txt",
  "assertion": "assertEquals ( 5, exceptions. get ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 5, exceptions. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_7.txt",
  "assertion": "assertEquals ( 8, null. sum ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 8, null. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_8.txt",
  "assertion": "assertEquals ( 9, resources. sized ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 9, resources. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "13_9.txt",
  "assertion": "assertEquals ( 7, array.Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 7, array.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 1, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_0.txt",
  "assertion": "assertEquals ( 1, res. size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1, res. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_1.txt",
  "assertion": "assertEquals ( 0, 0.size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, 0.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_10.txt",
  "assertion": "assertEquals ( 10, list. sizeof ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 10, list. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_11.txt",
  "assertion": "assertEquals ( 100, 3. number ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 100, 3. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_12.txt",
  "assertion": "assertEquals ( 16, this. bytes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 16, this. bytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_13.txt",
  "assertion": "assertEquals ( 20, 4. name ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 20, 4. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_14.txt",
  "assertion": "assertEquals (1, Res. score ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals (1, Res. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_15.txt",
  "assertion": "assertEquals ( 15, exception. shape ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 15, exception. shape ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_16.txt",
  "assertion": "assertEquals ( 255, Array. values ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 255, Array. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_17.txt",
  "assertion": "assertEquals ( 11, ex. index ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 11, ex. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_18.txt",
  "assertion": "assertEquals ( 19, map. sizing ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 19, map. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_19.txt",
  "assertion": "assertEquals ( 12, results. empty ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 12, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_2.txt",
  "assertion": "assertEquals ( 3, set. Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 3, set. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_20.txt",
  "assertion": "assertEquals ( 200, 2. value ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 200, 2. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_21.txt",
  "assertion": "assertEquals ( null, true. run ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( null, true. run ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_22.txt",
  "assertion": "assertEquals ( 98, int. resize ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 98, int. resize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_23.txt",
  "assertion": "assertEquals ( size, sys. capacity ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( size, sys. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_24.txt",
  "assertion": "assertEquals ( 23, sets. order ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 23, sets. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_25.txt",
  "assertion": "assertEquals ( one, count. rank ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( one, count. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_26.txt",
  "assertion": "assertEquals ( 31, size. weight ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 31, size. weight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_27.txt",
  "assertion": "assertEquals ( 33, 6. members ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 33, 6. members ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_28.txt",
  "assertion": "assertEquals ( expected, system. member ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expected, system. member ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_29.txt",
  "assertion": "assertEquals ( \"\", result. body ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( \"\", result. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_3.txt",
  "assertion": "assertEquals ( 2, 1. count ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 2, 1. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "14_4.txt",
  "assertion": "assertEquals ( 4, Exception. sizes ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 4, Exception. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_5.txt",
  "assertion": "assertEquals ( 6, System. length ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 6, System. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_6.txt",
  "assertion": "assertEquals ( 5, exceptions. get ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 5, exceptions. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_7.txt",
  "assertion": "assertEquals ( 8, null. sum ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 8, null. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_8.txt",
  "assertion": "assertEquals ( 9, resources. sized ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 9, resources. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "14_9.txt",
  "assertion": "assertEquals ( 7, array.Size ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 7, array.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( 4, res. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "15_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expected, expected ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_1.txt",
  "assertion": "assertEquals ( target, result )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( target, result ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_10.txt",
  "assertion": "assertEquals ( predicted, given )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( predicted, given ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_11.txt",
  "assertion": "assertEquals ( expect, right )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expect, right ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_12.txt",
  "assertion": "assertEquals ( found, thrown )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( found, thrown ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_13.txt",
  "assertion": "assertEquals ( intended, returned )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( intended, returned ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_14.txt",
  "assertion": "assertEquals ( right, 0 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( right, 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_15.txt",
  "assertion": "assertEquals ( corrected, updated )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( corrected, updated ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_16.txt",
  "assertion": "assertEquals ( desired, corrected )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( desired, corrected ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_17.txt",
  "assertion": "assertEquals ( given, estimated )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( given, estimated ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_18.txt",
  "assertion": "assertEquals (expected, ret )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals (expected, ret ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_19.txt",
  "assertion": "assertEquals ( calculated, expectation )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( calculated, expectation ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_2.txt",
  "assertion": "assertEquals ( actual, actual )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( actual, actual ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_20.txt",
  "assertion": "assertEquals ( c, new )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( c, new ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "15_21.txt",
  "assertion": "assertEquals ( observed, object )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( observed, object ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_22.txt",
  "assertion": "assertEquals ( passed, c )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( passed, c ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_23.txt",
  "assertion": "assertEquals ( expectation, response )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expectation, response ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_24.txt",
  "assertion": "assertEquals ( input, observed )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( input, observed ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_25.txt",
  "assertion": "assertEquals ( estimated, intended )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( estimated, intended ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_26.txt",
  "assertion": "assertEquals ( exact, 2 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( exact, 2 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_27.txt",
  "assertion": "assertEquals ( updated, e )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( updated, e ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_28.txt",
  "assertion": "assertEquals ( guessed, received )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( guessed, received ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_29.txt",
  "assertion": "assertEquals ( targeted, desired )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( targeted, desired ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_3.txt",
  "assertion": "assertEquals ( 2, target )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 2, target ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_4.txt",
  "assertion": "assertEquals ( 0, expecting )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_5.txt",
  "assertion": "assertEquals ( 1, expect )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1, expect ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_6.txt",
  "assertion": "assertEquals ( expecting, found )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expecting, found ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_7.txt",
  "assertion": "assertEquals ( 3, correct )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 3, correct ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_8.txt",
  "assertion": "assertEquals ( result, calculated )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( result, calculated ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "15_9.txt",
  "assertion": "assertEquals ( correct, value )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( correct, value ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( expected, top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_0.txt",
  "assertion": "assertNull ( expected )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( expected ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_1.txt",
  "assertion": "assertNull ( ) )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "16_10.txt",
  "assertion": "assertNull ( target )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( target ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_11.txt",
  "assertion": "assertNull ( given )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( given ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_12.txt",
  "assertion": "assertNull ( e )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( e ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_13.txt",
  "assertion": "assertNull ( expect )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( expect ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_14.txt",
  "assertion": "assertNull ( checked )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( checked ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_15.txt",
  "assertion": "assertNull ( estimated )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( estimated ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_16.txt",
  "assertion": "assertNull ( updated )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( updated ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_17.txt",
  "assertion": "assertNull ( passed )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( passed ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_18.txt",
  "assertion": "assertNull ( calculated )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( calculated ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_19.txt",
  "assertion": "assertNull ( ret )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_2.txt",
  "assertion": "assertNull ( result )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_20.txt",
  "assertion": "assertNull ( corrected )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( corrected ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_21.txt",
  "assertion": "assertNull ( value )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_22.txt",
  "assertion": "assertNull ( c )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( c ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_23.txt",
  "assertion": "assertNull ( expectations )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( expectations ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_24.txt",
  "assertion": "assertNull (pected )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull (pected ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_25.txt",
  "assertion": "assertNull ( considered )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( considered ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_26.txt",
  "assertion": "assertNull ( true )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_27.txt",
  "assertion": "assertNull ( observed )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( observed ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_28.txt",
  "assertion": "assertNull ( d )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( d ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_29.txt",
  "assertion": "assertNull ( event )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( event ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_3.txt",
  "assertion": "assertNull ( actual )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( actual ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_4.txt",
  "assertion": "assertNull ( expectation )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( expectation ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_5.txt",
  "assertion": "assertNull ( thrown )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( thrown ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_6.txt",
  "assertion": "assertNull ( found )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( found ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_7.txt",
  "assertion": "assertNull ( expecting )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_8.txt",
  "assertion": "assertNull ( returned )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull ( returned ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "16_9.txt",
  "assertion": "assertNull (expected )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNull (expected ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNull ( top )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_0.txt",
  "assertion": "assertEquals ( businessObjectData, 1 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( businessObjectData, 1 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_1.txt",
  "assertion": "assertEquals ( Business Object Data, 0 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( Business Object Data, 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_10.txt",
  "assertion": "assertEquals ( rulePart 1, 100 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( rulePart 1, 100 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_11.txt",
  "assertion": "assertEquals (BusinessDataKey, ID )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals (BusinessDataKey, ID ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_12.txt",
  "assertion": "assertEquals ( commerceArt 0, 5 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( commerceArt 0, 5 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_13.txt",
  "assertion": "assertEquals ( resultEntityCount, value )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( resultEntityCount, value ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_14.txt",
  "assertion": "assertEquals ( bIntIndex, 201 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( bIntIndex, 201 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_15.txt",
  "assertion": "assertEquals ( jobJType, true )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( jobJType, true ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_16.txt",
  "assertion": "assertEquals ( readClassValue, 200 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( readClassValue, 200 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_17.txt",
  "assertion": "assertEquals ( BIFieldPosition, 10 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( BIFieldPosition, 10 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_18.txt",
  "assertion": "assertEquals ( 5Version ID, 7 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 5Version ID, 7 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_19.txt",
  "assertion": "assertEquals ( bytesPrimaryState, \"\" )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( bytesPrimaryState, \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_2.txt",
  "assertion": "assertEquals (businessobjectDATA, data )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals (businessobjectDATA, data ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_20.txt",
  "assertion": "assertEquals ( 3ContentDate, DATA )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 3ContentDate, DATA ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_21.txt",
  "assertion": "assertEquals ( 0DetDelete, 6 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 0DetDelete, 6 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_22.txt",
  "assertion": "assertEquals ( idArrayadata, 202 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( idArrayadata, 202 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_23.txt",
  "assertion": "assertEquals ( keyOrderResult, expected )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( keyOrderResult, expected ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_24.txt",
  "assertion": "assertEquals ( requestJobCode, NULL )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( requestJobCode, NULL ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_25.txt",
  "assertion": "assertEquals ( \"AccessAlias, 8 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( \"AccessAlias, 8 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_26.txt",
  "assertion": "assertEquals ( dateDNo, 1000 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( dateDNo, 1000 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_27.txt",
  "assertion": "assertEquals ( property.Object,DATA )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( property.Object,DATA ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_28.txt",
  "assertion": "assertEquals ( 92Id 2,Data )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 92Id 2,Data ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_29.txt",
  "assertion": "assertEquals ( probeNumberStruct, Id )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( probeNumberStruct, Id ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_3.txt",
  "assertion": "assertEquals ( logical objectId, 2 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( logical objectId, 2 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_4.txt",
  "assertion": "assertEquals ( 1, data, 3 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 1, data, 3 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_5.txt",
  "assertion": "assertEquals ( expectedOBdata, 4 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( expectedOBdata, 4 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_6.txt",
  "assertion": "assertEquals ( 2ObjID, null )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( 2ObjID, null ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_7.txt",
  "assertion": "assertEquals ( byte.Meta, Data )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( byte.Meta, Data ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "17_8.txt",
  "assertion": "assertEquals ( dataJECTVersion, result )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( dataJECTVersion, result ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "17_9.txt",
  "assertion": "assertEquals ( value_Number, id )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertEquals ( value_Number, id ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertEquals ( businessObjectData, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_0.txt",
  "assertion": "assertNotNull ( null )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( null ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_1.txt",
  "assertion": "assertNotNull ( result )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_10.txt",
  "assertion": "assertNotNull ( NULL )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( NULL ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_11.txt",
  "assertion": "assertNotNull ( ret )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_12.txt",
  "assertion": "assertNotNull ( 1 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( 1 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_13.txt",
  "assertion": "assertNotNull ( json )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( json ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_14.txt",
  "assertion": "assertNotNull ( model )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( model ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_15.txt",
  "assertion": "assertNotNull ( listener )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( listener ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_16.txt",
  "assertion": "assertNotNull ( request )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( request ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_17.txt",
  "assertion": "assertNotNull ( ID )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( ID ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_18.txt",
  "assertion": "assertNotNull ( results )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( results ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_19.txt",
  "assertion": "assertNotNull ( consumer )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( consumer ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_2.txt",
  "assertion": "assertNotNull ( data )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( data ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_20.txt",
  "assertion": "assertNotNull ( 2 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( 2 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_21.txt",
  "assertion": "assertNotNull ( obj )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( obj ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_22.txt",
  "assertion": "assertNotNull ( exception )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( exception ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_23.txt",
  "assertion": "assertNotNull ( Data )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( Data ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_24.txt",
  "assertion": "assertNotNull ( 0 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_25.txt",
  "assertion": "assertNotNull ( 201 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( 201 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_26.txt",
  "assertion": "assertNotNull ( callback )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( callback ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_27.txt",
  "assertion": "assertNotNull ( entity )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( entity ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_28.txt",
  "assertion": "assertNotNull ( record )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( record ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_29.txt",
  "assertion": "assertNotNull ( 3 )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( 3 ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_3.txt",
  "assertion": "assertNotNull ( true )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_4.txt",
  "assertion": "assertNotNull ( id )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( id ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_5.txt",
  "assertion": "assertNotNull ( response )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( response ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_6.txt",
  "assertion": "assertNotNull ( value )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_7.txt",
  "assertion": "assertNotNull ( success )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( success ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_8.txt",
  "assertion": "assertNotNull ( false )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( false ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "18_9.txt",
  "assertion": "assertNotNull ( object )\r\n",
  "test": "class X {public void testEmptyInitialization ( ) { WaitTimer timer \u003d None . class . newInstance ( ) ; timer . init ( new double [ 0 ] ) ; for ( int i \u003d 0 ; i \u003c 1000 ; i ++ ) { } assertNotNull ( object ) ; } }\r\n",
  "focal method": "class Y{ public void getWaitTime ( ) { return ( min ) + ( random . nextInt ( range ) ) ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "19_0.txt",
  "assertion": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( d_analysis. getDependencies ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_1.txt",
  "assertion": "assertNotNull ( expected_activity.getSdependency ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( expected_activity.getSdependency ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_10.txt",
  "assertion": "assertNotNull ( k_sample. newGodividRelations ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( k_sample. newGodividRelations ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_11.txt",
  "assertion": "assertNotNull ( allowed_category. gDirectipancies ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( allowed_category. gDirectipancies ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_12.txt",
  "assertion": "assertNotNull ( result_activation. deMandVarions ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( result_activation. deMandVarions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_13.txt",
  "assertion": "assertNotNull ( parsed_site. addAyprees ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( parsed_site. addAyprees ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_14.txt",
  "assertion": "assertNotNull ( expect_Analysis. deleDsovalhips ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( expect_Analysis. deleDsovalhips ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_15.txt",
  "assertion": "assertNotNull ( is_study. checkAntliginitions ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( is_study. checkAntliginitions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_16.txt",
  "assertion": "assertNotNull ( target_frequency. determineRelatedulaints ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( target_frequency. determineRelatedulaints ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_17.txt",
  "assertion": "assertNotNull ( r_graph. setRevFlags ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( r_graph. setRevFlags ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_18.txt",
  "assertion": "assertNotNull ( natural_function.Get Dolicinates ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( natural_function.Get Dolicinates ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_19.txt",
  "assertion": "assertNotNull ( s_library. hasMetupNames ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( s_library. hasMetupNames ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_2.txt",
  "assertion": "assertNotNull ( e_group. GetEependent dependencies ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( e_group. GetEependent dependencies ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_20.txt",
  "assertion": "assertNotNull ( i_score. relatedDi dependReferences ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( i_score. relatedDi dependReferences ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_21.txt",
  "assertion": "assertNotNull ( digest_example. resolveYibifacts ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( digest_example. resolveYibifacts ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_22.txt",
  "assertion": "assertNotNull (d_active. filterIdRepilies ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull (d_active. filterIdRepilies ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_23.txt",
  "assertion": "assertNotNull ( output_content. removeTestingicates ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( output_content. removeTestingicates ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_24.txt",
  "assertion": "assertNotNull ( dependent_stats. pollVendependence ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( dependent_stats. pollVendependence ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_25.txt",
  "assertion": "assertNotNull ( returned_average. createDepExties ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( returned_average. createDepExties ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_26.txt",
  "assertion": "assertNotNull ( c_base. gotOerories ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( c_base. gotOerories ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_27.txt",
  "assertion": "assertNotNull ( o_context. validBdepositories ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( o_context. validBdepositories ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_28.txt",
  "assertion": "assertNotNull ( defined_model. readQediations ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( defined_model. readQediations ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_29.txt",
  "assertion": "assertNotNull ( check_error. dirtyShouldivels ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( check_error. dirtyShouldivels ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_3.txt",
  "assertion": "assertNotNull ( actual_report. eCod Dependants ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( actual_report. eCod Dependants ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_4.txt",
  "assertion": "assertNotNull ( detected_author. dIndivalences ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( detected_author. dIndivalences ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_5.txt",
  "assertion": "assertNotNull ( found_ analysis. getsDoDepities ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( found_ analysis. getsDoDepities ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "19_6.txt",
  "assertion": "assertNotNull ( required_system. isIependenceensions ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( required_system. isIependenceensions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_7.txt",
  "assertion": "assertNotNull ( m_reference. findPredicents ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( m_reference. findPredicents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_8.txt",
  "assertion": "assertNotNull ( q_article. gettingCepRequirements ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( q_article. gettingCepRequirements ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "19_9.txt",
  "assertion": "assertNotNull ( doc_search. todigments ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertNotNull ( doc_search. todigments ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertNotNull ( d_analysis. getDependencies ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_0.txt",
  "assertion": "assertEquals ( 0, users. size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 0, users. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_1.txt",
  "assertion": "assertEquals ( \"\", Users. empty ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( \"\", Users. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_10.txt",
  "assertion": "assertEquals ( null, devices. Size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( null, devices. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_11.txt",
  "assertion": "assertEquals (0, keys. 0 ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals (0, keys. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_12.txt",
  "assertion": "assertEquals ( 10, people. none ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 10, people. none ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_13.txt",
  "assertion": "assertEquals ( 100, values. body ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 100, values. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_14.txt",
  "assertion": "assertEquals ( 200, profiles. clear ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 200, profiles. clear ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_15.txt",
  "assertion": "assertEquals ( length, items. sizes ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( length, items. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_16.txt",
  "assertion": "assertEquals ( 16, u. map ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 16, u. map ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_17.txt",
  "assertion": "assertEquals ( 8, consumers.List ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 8, consumers.List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_18.txt",
  "assertion": "assertEquals ( size, accounts.size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( size, accounts.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_19.txt",
  "assertion": "assertEquals ( 6, null. entries ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 6, null. entries ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_2.txt",
  "assertion": "assertEquals ( 3, 0. values ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 3, 0. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_20.txt",
  "assertion": "assertEquals ( 7, empty. array ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 7, empty. array ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_21.txt",
  "assertion": "assertEquals ( \u0027\u0027, us. sort ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( \u0027\u0027, us. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "1_22.txt",
  "assertion": "assertEquals ( false, followers. index ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( false, followers. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_23.txt",
  "assertion": "assertEquals ( N, it. iterator ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( N, it. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_24.txt",
  "assertion": "assertEquals ( zero, roles. clone ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( zero, roles. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_25.txt",
  "assertion": "assertEquals ( 50, clients. of ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 50, clients. of ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_26.txt",
  "assertion": "assertEquals ( EMP, authors. zero ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( EMP, authors. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_27.txt",
  "assertion": "assertEquals ( 12, ones. content ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 12, ones. content ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_28.txt",
  "assertion": "assertEquals ( 15, names. List ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 15, names. List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_29.txt",
  "assertion": "assertEquals ( 11, sessions. stream ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 11, sessions. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_3.txt",
  "assertion": "assertEquals ( 1, user. list ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 1, user. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_4.txt",
  "assertion": "assertEquals ( 4, Collections. count ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 4, Collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_5.txt",
  "assertion": "assertEquals ( empty,Users. EMP ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( empty,Users. EMP ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_6.txt",
  "assertion": "assertEquals ( 2, members. length ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 2, members. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_7.txt",
  "assertion": "assertEquals ( 20, messages.Size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 20, messages.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_8.txt",
  "assertion": "assertEquals ( 5, list.Empty ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 5, list.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "1_9.txt",
  "assertion": "assertEquals ( 204,users. filter ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 204,users. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 0, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "20_0.txt",
  "assertion": "assertEquals ( date, instant )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, instant ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "20_1.txt",
  "assertion": "assertEquals ( \"\", date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( \"\", date ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "20_10.txt",
  "assertion": "assertEquals ( \", UTC )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( \", UTC ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "20_11.txt",
  "assertion": "assertEquals ( timestamp, month )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( timestamp, month ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_12.txt",
  "assertion": "assertEquals ( text, today )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( text, today ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_13.txt",
  "assertion": "assertEquals ( str, now )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( str, now ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_14.txt",
  "assertion": "assertEquals ( parsed, s )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( parsed, s ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_15.txt",
  "assertion": "assertEquals ( UTC, delta )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( UTC, delta ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_16.txt",
  "assertion": "assertEquals ( moment, offset )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( moment, offset ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_17.txt",
  "assertion": "assertEquals ( expecting, epoch )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( expecting, epoch ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_18.txt",
  "assertion": "assertEquals ( string, formatted )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( string, formatted ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_19.txt",
  "assertion": "assertEquals ( result, 0 )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( result, 0 ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_2.txt",
  "assertion": "assertEquals ( expected, \"\" )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( expected, \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_20.txt",
  "assertion": "assertEquals ( Date, example )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( Date, example ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_21.txt",
  "assertion": "assertEquals ( 1, text )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 1, text ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_22.txt",
  "assertion": "assertEquals ( 0, answer )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 0, answer ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_23.txt",
  "assertion": "assertEquals ( 2, a )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 2, a ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_24.txt",
  "assertion": "assertEquals ( 2010, obj )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 2010, obj ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_25.txt",
  "assertion": "assertEquals ( day, format )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( day, format ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_26.txt",
  "assertion": "assertEquals ( a, str )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( a, str ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_27.txt",
  "assertion": "assertEquals ( java, instance )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( java, instance ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_28.txt",
  "assertion": "assertEquals ( actual, 1830 )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( actual, 1830 ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_29.txt",
  "assertion": "assertEquals ( value, value )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( value, value ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_3.txt",
  "assertion": "assertEquals ( instant, Instant )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( instant, Instant ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_4.txt",
  "assertion": "assertEquals ( Instant, expected )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( Instant, expected ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_5.txt",
  "assertion": "assertEquals ( month, result )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( month, result ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_6.txt",
  "assertion": "assertEquals ( String, moment )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( String, moment ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_7.txt",
  "assertion": "assertEquals ( format, stamp )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( format, stamp ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_8.txt",
  "assertion": "assertEquals ( stamp, dat )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( stamp, dat ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "20_9.txt",
  "assertion": "assertEquals ( formatted, timestamp )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( formatted, timestamp ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( expected, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_0.txt",
  "assertion": "assertEquals ( date, instant )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( date, instant ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "21_1.txt",
  "assertion": "assertEquals ( \"\", date )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( \"\", date ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "date",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "21_10.txt",
  "assertion": "assertEquals ( \", UTC )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( \", UTC ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "21_11.txt",
  "assertion": "assertEquals ( timestamp, month )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( timestamp, month ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_12.txt",
  "assertion": "assertEquals ( text, today )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( text, today ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_13.txt",
  "assertion": "assertEquals ( str, now )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( str, now ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_14.txt",
  "assertion": "assertEquals ( parsed, s )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( parsed, s ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_15.txt",
  "assertion": "assertEquals ( UTC, delta )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( UTC, delta ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_16.txt",
  "assertion": "assertEquals ( moment, offset )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( moment, offset ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_17.txt",
  "assertion": "assertEquals ( expecting, epoch )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( expecting, epoch ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_18.txt",
  "assertion": "assertEquals ( string, formatted )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( string, formatted ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_19.txt",
  "assertion": "assertEquals ( result, 0 )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( result, 0 ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_2.txt",
  "assertion": "assertEquals ( expected, \"\" )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( expected, \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_20.txt",
  "assertion": "assertEquals ( Date, example )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( Date, example ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_21.txt",
  "assertion": "assertEquals ( 1, text )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 1, text ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_22.txt",
  "assertion": "assertEquals ( 0, answer )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 0, answer ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_23.txt",
  "assertion": "assertEquals ( 2, a )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 2, a ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_24.txt",
  "assertion": "assertEquals ( 2010, obj )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 2010, obj ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_25.txt",
  "assertion": "assertEquals ( day, format )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( day, format ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_26.txt",
  "assertion": "assertEquals ( a, str )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( a, str ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_27.txt",
  "assertion": "assertEquals ( java, instance )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( java, instance ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_28.txt",
  "assertion": "assertEquals ( actual, 1830 )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( actual, 1830 ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_29.txt",
  "assertion": "assertEquals ( value, value )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( value, value ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_3.txt",
  "assertion": "assertEquals ( instant, Instant )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( instant, Instant ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_4.txt",
  "assertion": "assertEquals ( Instant, expected )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( Instant, expected ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_5.txt",
  "assertion": "assertEquals ( month, result )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( month, result ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_6.txt",
  "assertion": "assertEquals ( String, moment )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( String, moment ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_7.txt",
  "assertion": "assertEquals ( format, stamp )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( format, stamp ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_8.txt",
  "assertion": "assertEquals ( stamp, dat )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( stamp, dat ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "21_9.txt",
  "assertion": "assertEquals ( formatted, timestamp )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( formatted, timestamp ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( instant, instant )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_0.txt",
  "assertion": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 3, resultSet. getColumnCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_1.txt",
  "assertion": "assertEquals ( 2,Resultset.getcolumn Count ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 2,Resultset.getcolumn Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_10.txt",
  "assertion": "assertEquals ( 10, columnSET. countFieldNum ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 10, columnSET. countFieldNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_11.txt",
  "assertion": "assertEquals ( 16, expectedResult. colCountCall ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 16, expectedResult. colCountCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_12.txt",
  "assertion": "assertEquals ( 20, numMet. gettingConnectionRange ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 20, numMet. gettingConnectionRange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_13.txt",
  "assertion": "assertEquals ( 100, retPoint. incrementResultDepth ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 100, retPoint. incrementResultDepth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_14.txt",
  "assertion": "assertEquals ( 12, 10Offset. intCharacterOffset ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 12, 10Offset. intCharacterOffset ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_15.txt",
  "assertion": "assertEquals ( 15, 3Query. _TableResult ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 15, 3Query. _TableResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_16.txt",
  "assertion": "assertEquals ( 200, rowMessage. guessCs ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 200, rowMessage. guessCs ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_17.txt",
  "assertion": "assertEquals ( expected, dataObject. currentUniqueows ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( expected, dataObject. currentUniqueows ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_18.txt",
  "assertion": "assertEquals (3, 7Spec. gItemArray ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals (3, 7Spec. gItemArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_19.txt",
  "assertion": "assertEquals ( 1000, *List. calculateElementResults ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 1000, *List. calculateElementResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_2.txt",
  "assertion": "assertEquals ( 4, Result Set. GetRowcount ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 4, Result Set. GetRowcount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_20.txt",
  "assertion": "assertEquals ( 11, tableMeta. cFileLength ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 11, tableMeta. cFileLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_21.txt",
  "assertion": "assertEquals (2, trueMap. executePoolAST ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals (2, trueMap. executePoolAST ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_22.txt",
  "assertion": "assertEquals ( 19, returnSetting. fetchArticleacity ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 19, returnSetting. fetchArticleacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_23.txt",
  "assertion": "assertEquals ( 13,!Ut. nContentC ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 13,!Ut. nContentC ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_24.txt",
  "assertion": "assertEquals ( 14, numericET. findMaximumAmount ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 14, numericET. findMaximumAmount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_25.txt",
  "assertion": "assertEquals ( 30, (ets. addMethodContent ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 30, (ets. addMethodContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_26.txt",
  "assertion": "assertEquals ( three, ++Item. sizeMaxPosition ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( three, ++Item. sizeMaxPosition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_27.txt",
  "assertion": "assertEquals ( two, nullUpdate. eParameterTop ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( two, nullUpdate. eParameterTop ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_28.txt",
  "assertion": "assertEquals ( N, -Count. newMessageCache ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( N, -Count. newMessageCache ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "22_29.txt",
  "assertion": "assertEquals ( 23, constKey. xComponentMore ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 23, constKey. xComponentMore ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_3.txt",
  "assertion": "assertEquals ( 1, resultsGet. columnCol count ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 1, resultsGet. columnCol count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_4.txt",
  "assertion": "assertEquals ( 0, 0et. num columnSize ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 0, 0et. num columnSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_5.txt",
  "assertion": "assertEquals ( 5, countRow. gets ColumnCounter ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 5, countRow. gets ColumnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_6.txt",
  "assertion": "assertEquals ( 6, numberData. gotObjectount ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 6, numberData. gotObjectount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "22_7.txt",
  "assertion": "assertEquals ( 8, 1S. resultCellOUNT ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 8, 1S. resultCellOUNT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_8.txt",
  "assertion": "assertEquals ( 7, 2Source. numberFunctionNumber ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 7, 2Source. numberFunctionNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "22_9.txt",
  "assertion": "assertEquals ( 9,result set. toAttributeLimit ( ) )\r\n",
  "test": "class X {public void testAvg ( ) { BaseProperty \u003c Date \u003e avgProp \u003d PropertyFactory . createBase ( DATE_OF_BIRTH . avgExp ( DATE_OF_BIRTH . getExpression ( ) ) , Date . class ) ; Date avg \u003d ObjectSelect . query ( Artist . class ) . ObjectSelect . column ( avgProp ) . ObjectSelect . selectOne ( context ) ; Date date \u003d dateFormat . parse ( \"1/3/17\" ) ; assertEquals ( 9,result set. toAttributeLimit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { SimpleNode nodeTree ; try { nodeTree \u003d velocityRuntime . parse ( new StringReader ( template ) , new Template ( ) ) ; } catch ( ParseException pex ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e\u0027%s\u0027\u003csp\u003e:\u003csp\u003e%s\" , template , pex . getMessage ( ) ) ; } if ( nodeTree \u003d\u003d null ) { throw new CayenneRuntimeException ( \"Error\u003csp\u003eparsing\u003csp\u003etemplate\u003csp\u003e%s\" , template ) ; } return nodeTree ; } }\r\n",
  "truth": "assertEquals ( 2, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_0.txt",
  "assertion": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 3, resultSet. getColumnCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_1.txt",
  "assertion": "assertEquals ( 2,Resultset.getcolumn Count ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2,Resultset.getcolumn Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_10.txt",
  "assertion": "assertEquals ( 10, columnSET. countFieldNum ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 10, columnSET. countFieldNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_11.txt",
  "assertion": "assertEquals ( 16, expectedResult. colCountCall ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 16, expectedResult. colCountCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_12.txt",
  "assertion": "assertEquals ( 20, numMet. gettingConnectionRange ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 20, numMet. gettingConnectionRange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_13.txt",
  "assertion": "assertEquals ( 100, retPoint. incrementResultDepth ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 100, retPoint. incrementResultDepth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_14.txt",
  "assertion": "assertEquals ( 12, 10Offset. intCharacterOffset ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 12, 10Offset. intCharacterOffset ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_15.txt",
  "assertion": "assertEquals ( 15, 3Query. _TableResult ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 15, 3Query. _TableResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_16.txt",
  "assertion": "assertEquals ( 200, rowMessage. guessCs ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 200, rowMessage. guessCs ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_17.txt",
  "assertion": "assertEquals ( expected, dataObject. currentUniqueows ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( expected, dataObject. currentUniqueows ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_18.txt",
  "assertion": "assertEquals (3, 7Spec. gItemArray ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (3, 7Spec. gItemArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_19.txt",
  "assertion": "assertEquals ( 1000, *List. calculateElementResults ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1000, *List. calculateElementResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_2.txt",
  "assertion": "assertEquals ( 4, Result Set. GetRowcount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 4, Result Set. GetRowcount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_20.txt",
  "assertion": "assertEquals ( 11, tableMeta. cFileLength ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 11, tableMeta. cFileLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_21.txt",
  "assertion": "assertEquals (2, trueMap. executePoolAST ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (2, trueMap. executePoolAST ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_22.txt",
  "assertion": "assertEquals ( 19, returnSetting. fetchArticleacity ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 19, returnSetting. fetchArticleacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_23.txt",
  "assertion": "assertEquals ( 13,!Ut. nContentC ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 13,!Ut. nContentC ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "23_24.txt",
  "assertion": "assertEquals ( 14, numericET. findMaximumAmount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 14, numericET. findMaximumAmount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_25.txt",
  "assertion": "assertEquals ( 30, (ets. addMethodContent ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 30, (ets. addMethodContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_26.txt",
  "assertion": "assertEquals ( three, ++Item. sizeMaxPosition ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( three, ++Item. sizeMaxPosition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "23_27.txt",
  "assertion": "assertEquals ( two, nullUpdate. eParameterTop ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( two, nullUpdate. eParameterTop ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_28.txt",
  "assertion": "assertEquals ( N, -Count. newMessageCache ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( N, -Count. newMessageCache ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "23_29.txt",
  "assertion": "assertEquals ( 23, constKey. xComponentMore ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 23, constKey. xComponentMore ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_3.txt",
  "assertion": "assertEquals ( 1, resultsGet. columnCol count ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, resultsGet. columnCol count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_4.txt",
  "assertion": "assertEquals ( 0, 0et. num columnSize ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 0et. num columnSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_5.txt",
  "assertion": "assertEquals ( 5, countRow. gets ColumnCounter ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 5, countRow. gets ColumnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_6.txt",
  "assertion": "assertEquals ( 6, numberData. gotObjectount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 6, numberData. gotObjectount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "23_7.txt",
  "assertion": "assertEquals ( 8, 1S. resultCellOUNT ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 8, 1S. resultCellOUNT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_8.txt",
  "assertion": "assertEquals ( 7, 2Source. numberFunctionNumber ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 7, 2Source. numberFunctionNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "23_9.txt",
  "assertion": "assertEquals ( 9,result set. toAttributeLimit ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 9,result set. toAttributeLimit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_0.txt",
  "assertion": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 3, resultSet. getColumnCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_1.txt",
  "assertion": "assertEquals ( 2,Resultset.getcolumn Count ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2,Resultset.getcolumn Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_10.txt",
  "assertion": "assertEquals ( 10, columnSET. countFieldNum ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 10, columnSET. countFieldNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_11.txt",
  "assertion": "assertEquals ( 16, expectedResult. colCountCall ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 16, expectedResult. colCountCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_12.txt",
  "assertion": "assertEquals ( 20, numMet. gettingConnectionRange ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 20, numMet. gettingConnectionRange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_13.txt",
  "assertion": "assertEquals ( 100, retPoint. incrementResultDepth ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 100, retPoint. incrementResultDepth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_14.txt",
  "assertion": "assertEquals ( 12, 10Offset. intCharacterOffset ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 12, 10Offset. intCharacterOffset ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_15.txt",
  "assertion": "assertEquals ( 15, 3Query. _TableResult ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 15, 3Query. _TableResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_16.txt",
  "assertion": "assertEquals ( 200, rowMessage. guessCs ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 200, rowMessage. guessCs ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_17.txt",
  "assertion": "assertEquals ( expected, dataObject. currentUniqueows ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( expected, dataObject. currentUniqueows ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_18.txt",
  "assertion": "assertEquals (3, 7Spec. gItemArray ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (3, 7Spec. gItemArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_19.txt",
  "assertion": "assertEquals ( 1000, *List. calculateElementResults ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1000, *List. calculateElementResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_2.txt",
  "assertion": "assertEquals ( 4, Result Set. GetRowcount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 4, Result Set. GetRowcount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_20.txt",
  "assertion": "assertEquals ( 11, tableMeta. cFileLength ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 11, tableMeta. cFileLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_21.txt",
  "assertion": "assertEquals (2, trueMap. executePoolAST ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (2, trueMap. executePoolAST ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_22.txt",
  "assertion": "assertEquals ( 19, returnSetting. fetchArticleacity ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 19, returnSetting. fetchArticleacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_23.txt",
  "assertion": "assertEquals ( 13,!Ut. nContentC ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 13,!Ut. nContentC ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "24_24.txt",
  "assertion": "assertEquals ( 14, numericET. findMaximumAmount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 14, numericET. findMaximumAmount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_25.txt",
  "assertion": "assertEquals ( 30, (ets. addMethodContent ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 30, (ets. addMethodContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_26.txt",
  "assertion": "assertEquals ( three, ++Item. sizeMaxPosition ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( three, ++Item. sizeMaxPosition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "24_27.txt",
  "assertion": "assertEquals ( two, nullUpdate. eParameterTop ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( two, nullUpdate. eParameterTop ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_28.txt",
  "assertion": "assertEquals ( N, -Count. newMessageCache ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( N, -Count. newMessageCache ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "24_29.txt",
  "assertion": "assertEquals ( 23, constKey. xComponentMore ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 23, constKey. xComponentMore ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_3.txt",
  "assertion": "assertEquals ( 1, resultsGet. columnCol count ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, resultsGet. columnCol count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_4.txt",
  "assertion": "assertEquals ( 0, 0et. num columnSize ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 0et. num columnSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_5.txt",
  "assertion": "assertEquals ( 5, countRow. gets ColumnCounter ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 5, countRow. gets ColumnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_6.txt",
  "assertion": "assertEquals ( 6, numberData. gotObjectount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 6, numberData. gotObjectount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "24_7.txt",
  "assertion": "assertEquals ( 8, 1S. resultCellOUNT ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 8, 1S. resultCellOUNT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_8.txt",
  "assertion": "assertEquals ( 7, 2Source. numberFunctionNumber ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 7, 2Source. numberFunctionNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "24_9.txt",
  "assertion": "assertEquals ( 9,result set. toAttributeLimit ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 9,result set. toAttributeLimit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_0.txt",
  "assertion": "assertEquals ( 3, resultSet. getColumnCount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 3, resultSet. getColumnCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_1.txt",
  "assertion": "assertEquals ( 2,Resultset.getcolumn Count ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 2,Resultset.getcolumn Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_10.txt",
  "assertion": "assertEquals ( 10, columnSET. countFieldNum ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 10, columnSET. countFieldNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_11.txt",
  "assertion": "assertEquals ( 16, expectedResult. colCountCall ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 16, expectedResult. colCountCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_12.txt",
  "assertion": "assertEquals ( 20, numMet. gettingConnectionRange ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 20, numMet. gettingConnectionRange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_13.txt",
  "assertion": "assertEquals ( 100, retPoint. incrementResultDepth ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 100, retPoint. incrementResultDepth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_14.txt",
  "assertion": "assertEquals ( 12, 10Offset. intCharacterOffset ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 12, 10Offset. intCharacterOffset ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_15.txt",
  "assertion": "assertEquals ( 15, 3Query. _TableResult ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 15, 3Query. _TableResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_16.txt",
  "assertion": "assertEquals ( 200, rowMessage. guessCs ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 200, rowMessage. guessCs ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_17.txt",
  "assertion": "assertEquals ( expected, dataObject. currentUniqueows ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( expected, dataObject. currentUniqueows ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_18.txt",
  "assertion": "assertEquals (3, 7Spec. gItemArray ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (3, 7Spec. gItemArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_19.txt",
  "assertion": "assertEquals ( 1000, *List. calculateElementResults ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1000, *List. calculateElementResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_2.txt",
  "assertion": "assertEquals ( 4, Result Set. GetRowcount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 4, Result Set. GetRowcount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_20.txt",
  "assertion": "assertEquals ( 11, tableMeta. cFileLength ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 11, tableMeta. cFileLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_21.txt",
  "assertion": "assertEquals (2, trueMap. executePoolAST ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (2, trueMap. executePoolAST ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_22.txt",
  "assertion": "assertEquals ( 19, returnSetting. fetchArticleacity ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 19, returnSetting. fetchArticleacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_23.txt",
  "assertion": "assertEquals ( 13,!Ut. nContentC ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 13,!Ut. nContentC ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "25_24.txt",
  "assertion": "assertEquals ( 14, numericET. findMaximumAmount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 14, numericET. findMaximumAmount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_25.txt",
  "assertion": "assertEquals ( 30, (ets. addMethodContent ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 30, (ets. addMethodContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_26.txt",
  "assertion": "assertEquals ( three, ++Item. sizeMaxPosition ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( three, ++Item. sizeMaxPosition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "25_27.txt",
  "assertion": "assertEquals ( two, nullUpdate. eParameterTop ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( two, nullUpdate. eParameterTop ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_28.txt",
  "assertion": "assertEquals ( N, -Count. newMessageCache ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( N, -Count. newMessageCache ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "25_29.txt",
  "assertion": "assertEquals ( 23, constKey. xComponentMore ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 23, constKey. xComponentMore ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_3.txt",
  "assertion": "assertEquals ( 1, resultsGet. columnCol count ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 1, resultsGet. columnCol count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_4.txt",
  "assertion": "assertEquals ( 0, 0et. num columnSize ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 0, 0et. num columnSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_5.txt",
  "assertion": "assertEquals ( 5, countRow. gets ColumnCounter ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 5, countRow. gets ColumnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_6.txt",
  "assertion": "assertEquals ( 6, numberData. gotObjectount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 6, numberData. gotObjectount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "25_7.txt",
  "assertion": "assertEquals ( 8, 1S. resultCellOUNT ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 8, 1S. resultCellOUNT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_8.txt",
  "assertion": "assertEquals ( 7, 2Source. numberFunctionNumber ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 7, 2Source. numberFunctionNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "25_9.txt",
  "assertion": "assertEquals ( 9,result set. toAttributeLimit ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( 9,result set. toAttributeLimit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, resultSet. getColumnCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_0.txt",
  "assertion": "assertEquals ( set1, set3 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( set1, set3 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_1.txt",
  "assertion": "assertEquals ( add3, sets2 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( add3, sets2 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_10.txt",
  "assertion": "assertEquals ( get 2,setSet )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( get 2,setSet ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_11.txt",
  "assertion": "assertEquals (setTwo, SET 2 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (setTwo, SET 2 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_12.txt",
  "assertion": "assertEquals (SetLeft, new0 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (SetLeft, new0 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_13.txt",
  "assertion": "assertEquals ( [ 3, unValue )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( [ 3, unValue ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_14.txt",
  "assertion": "assertEquals ( _First, _False )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( _First, _False ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_15.txt",
  "assertion": "assertEquals ( newSet, check8 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( newSet, check8 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_16.txt",
  "assertion": "assertEquals ( base11, systemRight )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( base11, systemRight ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_17.txt",
  "assertion": "assertEquals ( check7, subjectD )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( check7, subjectD ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_18.txt",
  "assertion": "assertEquals ( assignSecond, [True )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( assignSecond, [True ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_19.txt",
  "assertion": "assertEquals ( (8, remove7 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( (8, remove7 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_2.txt",
  "assertion": "assertEquals ( sets2, Set1 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( sets2, Set1 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_20.txt",
  "assertion": "assertEquals ( systemRight, subset11 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( systemRight, subset11 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_21.txt",
  "assertion": "assertEquals ( settingRule, assignOne )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( settingRule, assignOne ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_22.txt",
  "assertion": "assertEquals ( cA, oHash )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( cA, oHash ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_23.txt",
  "assertion": "assertEquals ( contextThree, settingRule )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( contextThree, settingRule ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_24.txt",
  "assertion": "assertEquals ( subjectName, (Type )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( subjectName, (Type ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_25.txt",
  "assertion": "assertEquals ( kTo, cAll )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( kTo, cAll ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_26.txt",
  "assertion": "assertEquals ( commona, mapTo )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( commona, mapTo ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_27.txt",
  "assertion": "assertEquals ( subsetInput, readA )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( subsetInput, readA ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_28.txt",
  "assertion": "assertEquals ( topAdd, contextName )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( topAdd, contextName ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_29.txt",
  "assertion": "assertEquals ( removeValue, baseSecond )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( removeValue, baseSecond ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_3.txt",
  "assertion": "assertEquals ( s4, s4 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( s4, s4 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_4.txt",
  "assertion": "assertEquals ( objectOne, add5 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( objectOne, add5 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_5.txt",
  "assertion": "assertEquals ( Set5, clear6 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( Set5, clear6 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_6.txt",
  "assertion": "assertEquals ( group0,SetTwo )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( group0,SetTwo ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_7.txt",
  "assertion": "assertEquals ( clear6, objectThird )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( clear6, objectThird ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "26_8.txt",
  "assertion": "assertEquals ( SET 1, group 3 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( SET 1, group 3 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "26_9.txt",
  "assertion": "assertEquals ( unThird, getThree )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( unThird, getThree ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set3, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_0.txt",
  "assertion": "assertEquals ( set1, set3 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( set1, set3 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_1.txt",
  "assertion": "assertEquals ( add3, sets2 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( add3, sets2 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_10.txt",
  "assertion": "assertEquals ( get 2,setSet )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( get 2,setSet ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_11.txt",
  "assertion": "assertEquals (setTwo, SET 2 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (setTwo, SET 2 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_12.txt",
  "assertion": "assertEquals (SetLeft, new0 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (SetLeft, new0 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_13.txt",
  "assertion": "assertEquals ( [ 3, unValue )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( [ 3, unValue ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_14.txt",
  "assertion": "assertEquals ( _First, _False )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( _First, _False ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_15.txt",
  "assertion": "assertEquals ( newSet, check8 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( newSet, check8 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_16.txt",
  "assertion": "assertEquals ( base11, systemRight )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( base11, systemRight ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_17.txt",
  "assertion": "assertEquals ( check7, subjectD )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( check7, subjectD ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_18.txt",
  "assertion": "assertEquals ( assignSecond, [True )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( assignSecond, [True ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_19.txt",
  "assertion": "assertEquals ( (8, remove7 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( (8, remove7 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_2.txt",
  "assertion": "assertEquals ( sets2, Set1 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( sets2, Set1 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_20.txt",
  "assertion": "assertEquals ( systemRight, subset11 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( systemRight, subset11 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_21.txt",
  "assertion": "assertEquals ( settingRule, assignOne )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( settingRule, assignOne ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_22.txt",
  "assertion": "assertEquals ( cA, oHash )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( cA, oHash ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_23.txt",
  "assertion": "assertEquals ( contextThree, settingRule )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( contextThree, settingRule ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_24.txt",
  "assertion": "assertEquals ( subjectName, (Type )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( subjectName, (Type ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_25.txt",
  "assertion": "assertEquals ( kTo, cAll )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( kTo, cAll ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_26.txt",
  "assertion": "assertEquals ( commona, mapTo )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( commona, mapTo ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_27.txt",
  "assertion": "assertEquals ( subsetInput, readA )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( subsetInput, readA ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_28.txt",
  "assertion": "assertEquals ( topAdd, contextName )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( topAdd, contextName ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_29.txt",
  "assertion": "assertEquals ( removeValue, baseSecond )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( removeValue, baseSecond ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_3.txt",
  "assertion": "assertEquals ( s4, s4 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( s4, s4 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_4.txt",
  "assertion": "assertEquals ( objectOne, add5 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( objectOne, add5 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_5.txt",
  "assertion": "assertEquals ( Set5, clear6 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( Set5, clear6 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_6.txt",
  "assertion": "assertEquals ( group0,SetTwo )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( group0,SetTwo ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_7.txt",
  "assertion": "assertEquals ( clear6, objectThird )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( clear6, objectThird ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "27_8.txt",
  "assertion": "assertEquals ( SET 1, group 3 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( SET 1, group 3 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "27_9.txt",
  "assertion": "assertEquals ( unThird, getThree )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( unThird, getThree ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set2, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_0.txt",
  "assertion": "assertEquals ( set1, set3 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( set1, set3 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_1.txt",
  "assertion": "assertEquals ( add3, sets2 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( add3, sets2 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_10.txt",
  "assertion": "assertEquals ( get 2,setSet )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( get 2,setSet ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_11.txt",
  "assertion": "assertEquals (setTwo, SET 2 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (setTwo, SET 2 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_12.txt",
  "assertion": "assertEquals (SetLeft, new0 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (SetLeft, new0 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_13.txt",
  "assertion": "assertEquals ( [ 3, unValue )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( [ 3, unValue ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_14.txt",
  "assertion": "assertEquals ( _First, _False )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( _First, _False ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_15.txt",
  "assertion": "assertEquals ( newSet, check8 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( newSet, check8 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_16.txt",
  "assertion": "assertEquals ( base11, systemRight )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( base11, systemRight ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_17.txt",
  "assertion": "assertEquals ( check7, subjectD )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( check7, subjectD ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_18.txt",
  "assertion": "assertEquals ( assignSecond, [True )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( assignSecond, [True ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_19.txt",
  "assertion": "assertEquals ( (8, remove7 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( (8, remove7 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_2.txt",
  "assertion": "assertEquals ( sets2, Set1 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( sets2, Set1 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_20.txt",
  "assertion": "assertEquals ( systemRight, subset11 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( systemRight, subset11 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_21.txt",
  "assertion": "assertEquals ( settingRule, assignOne )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( settingRule, assignOne ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_22.txt",
  "assertion": "assertEquals ( cA, oHash )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( cA, oHash ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_23.txt",
  "assertion": "assertEquals ( contextThree, settingRule )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( contextThree, settingRule ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_24.txt",
  "assertion": "assertEquals ( subjectName, (Type )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( subjectName, (Type ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_25.txt",
  "assertion": "assertEquals ( kTo, cAll )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( kTo, cAll ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_26.txt",
  "assertion": "assertEquals ( commona, mapTo )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( commona, mapTo ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_27.txt",
  "assertion": "assertEquals ( subsetInput, readA )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( subsetInput, readA ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_28.txt",
  "assertion": "assertEquals ( topAdd, contextName )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( topAdd, contextName ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_29.txt",
  "assertion": "assertEquals ( removeValue, baseSecond )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( removeValue, baseSecond ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_3.txt",
  "assertion": "assertEquals ( s4, s4 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( s4, s4 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_4.txt",
  "assertion": "assertEquals ( objectOne, add5 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( objectOne, add5 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_5.txt",
  "assertion": "assertEquals ( Set5, clear6 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( Set5, clear6 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_6.txt",
  "assertion": "assertEquals ( group0,SetTwo )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( group0,SetTwo ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_7.txt",
  "assertion": "assertEquals ( clear6, objectThird )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( clear6, objectThird ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "28_8.txt",
  "assertion": "assertEquals ( SET 1, group 3 )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( SET 1, group 3 ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "28_9.txt",
  "assertion": "assertEquals ( unThird, getThree )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( unThird, getThree ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( set1, set1 )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "29_0.txt",
  "assertion": "assertTrue ( answer. getResult ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( answer. getResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_1.txt",
  "assertion": "assertTrue ( result. isResults ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( result. isResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_10.txt",
  "assertion": "assertTrue ( resp. was result ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( resp. was result ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_11.txt",
  "assertion": "assertTrue ( res. gettingFailure ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( res. gettingFailure ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_12.txt",
  "assertion": "assertTrue ( null. areMessage ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( null. areMessage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_13.txt",
  "assertion": "assertTrue ( ret. setContent ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( ret. setContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_14.txt",
  "assertion": "assertTrue ( false. responseException ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( false. responseException ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_15.txt",
  "assertion": "assertTrue ( msg. can Result ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( msg. can Result ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_16.txt",
  "assertion": "assertTrue ( nit.GetCount ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( nit.GetCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_17.txt",
  "assertion": "assertTrue ( 0. newValue ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( 0. newValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_18.txt",
  "assertion": "assertTrue ( answered. verifyResponse ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( answered. verifyResponse ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_19.txt",
  "assertion": "assertTrue ( question. resultResource ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( question. resultResource ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_2.txt",
  "assertion": "assertTrue ( this. hasSuccess ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( this. hasSuccess ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_20.txt",
  "assertion": "assertTrue ( message. booleanStatus ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( message. booleanStatus ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_21.txt",
  "assertion": "assertTrue (!. rDone ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue (!. rDone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "29_22.txt",
  "assertion": "assertTrue ( acknowledge. userReturn ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( acknowledge. userReturn ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_23.txt",
  "assertion": "assertTrue ( true. testObject ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( true. testObject ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_24.txt",
  "assertion": "assertTrue ( options. exportData ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( options. exportData ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_25.txt",
  "assertion": "assertTrue ( output. returnsReply ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( output. returnsReply ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_26.txt",
  "assertion": "assertTrue ( err. toNull ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( err. toNull ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_27.txt",
  "assertion": "assertTrue ( RC. goesType ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( RC. goesType ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_28.txt",
  "assertion": "assertTrue ( error. wantFail ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( error. wantFail ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_29.txt",
  "assertion": "assertTrue ( value. haveFlag ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( value. haveFlag ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_3.txt",
  "assertion": "assertTrue ( response.getError ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( response.getError ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_4.txt",
  "assertion": "assertTrue ( reply. gotFalse ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( reply. gotFalse ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_5.txt",
  "assertion": "assertTrue ( Answer. getsresult ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( Answer. getsresult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_6.txt",
  "assertion": "assertTrue ( answers. GetOk ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( answers. GetOk ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_7.txt",
  "assertion": "assertTrue ( rc. returnOK ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( rc. returnOK ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_8.txt",
  "assertion": "assertTrue ( resource. checkTrue ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( resource. checkTrue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "29_9.txt",
  "assertion": "assertTrue ( status. useValid ( ) )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertTrue ( status. useValid ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertTrue ( answer. getResult ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_0.txt",
  "assertion": "assertEquals ( 0, users. size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 0, users. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_1.txt",
  "assertion": "assertEquals ( \"\", Users. empty ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( \"\", Users. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_10.txt",
  "assertion": "assertEquals ( null, devices. Size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( null, devices. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_11.txt",
  "assertion": "assertEquals (0, keys. 0 ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals (0, keys. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_12.txt",
  "assertion": "assertEquals ( 10, people. none ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 10, people. none ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_13.txt",
  "assertion": "assertEquals ( 100, values. body ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 100, values. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_14.txt",
  "assertion": "assertEquals ( 200, profiles. clear ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 200, profiles. clear ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_15.txt",
  "assertion": "assertEquals ( length, items. sizes ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( length, items. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_16.txt",
  "assertion": "assertEquals ( 16, u. map ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 16, u. map ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_17.txt",
  "assertion": "assertEquals ( 8, consumers.List ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 8, consumers.List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_18.txt",
  "assertion": "assertEquals ( size, accounts.size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( size, accounts.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_19.txt",
  "assertion": "assertEquals ( 6, null. entries ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 6, null. entries ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_2.txt",
  "assertion": "assertEquals ( 3, 0. values ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 3, 0. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_20.txt",
  "assertion": "assertEquals ( 7, empty. array ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 7, empty. array ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_21.txt",
  "assertion": "assertEquals ( \u0027\u0027, us. sort ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( \u0027\u0027, us. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "2_22.txt",
  "assertion": "assertEquals ( false, followers. index ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( false, followers. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_23.txt",
  "assertion": "assertEquals ( N, it. iterator ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( N, it. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_24.txt",
  "assertion": "assertEquals ( zero, roles. clone ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( zero, roles. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_25.txt",
  "assertion": "assertEquals ( 50, clients. of ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 50, clients. of ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_26.txt",
  "assertion": "assertEquals ( EMP, authors. zero ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( EMP, authors. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_27.txt",
  "assertion": "assertEquals ( 12, ones. content ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 12, ones. content ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_28.txt",
  "assertion": "assertEquals ( 15, names. List ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 15, names. List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_29.txt",
  "assertion": "assertEquals ( 11, sessions. stream ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 11, sessions. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_3.txt",
  "assertion": "assertEquals ( 1, user. list ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 1, user. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_4.txt",
  "assertion": "assertEquals ( 4, Collections. count ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 4, Collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_5.txt",
  "assertion": "assertEquals ( empty,Users. EMP ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( empty,Users. EMP ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_6.txt",
  "assertion": "assertEquals ( 2, members. length ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 2, members. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_7.txt",
  "assertion": "assertEquals ( 20, messages.Size ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 20, messages.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_8.txt",
  "assertion": "assertEquals ( 5, list.Empty ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 5, list.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "2_9.txt",
  "assertion": "assertEquals ( 204,users. filter ( ) )\r\n",
  "test": "class X {public void testRemove ( ) { Layout newLayout \u003d addLayout ( ) ; _persistence . remove ( newLayout ) ; Layout existingLayout \u003d _persistence . fetchByPrimaryKey ( newLayout . getPrimaryKey ( ) ) ; assertEquals ( 204,users. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getPrimaryKey ( ) { return _amImageEntryId ; } }\r\n",
  "truth": "assertEquals ( 200, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "30_0.txt",
  "assertion": "assertEquals ( expected, result )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( expected, result ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_1.txt",
  "assertion": "assertEquals ( result, expected )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( result, expected ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_10.txt",
  "assertion": "assertEquals ( correct, text )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( correct, text ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_11.txt",
  "assertion": "assertEquals ( received, original )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( received, original ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_12.txt",
  "assertion": "assertEquals ( answer, string )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( answer, string ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_13.txt",
  "assertion": "assertEquals ( original, received )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( original, received ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_14.txt",
  "assertion": "assertEquals ( read, content )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( read, content ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_15.txt",
  "assertion": "assertEquals ( unexpected, value )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( unexpected, value ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_16.txt",
  "assertion": "assertEquals ( input, found )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( input, found ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_17.txt",
  "assertion": "assertEquals ( awaited, data )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( awaited, data ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_18.txt",
  "assertion": "assertEquals ( found, extracted )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( found, extracted ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_19.txt",
  "assertion": "assertEquals (expected, output )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (expected, output ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_2.txt",
  "assertion": "assertEquals ( expect, answer )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( expect, answer ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_20.txt",
  "assertion": "assertEquals ( string, expecting )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( string, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_21.txt",
  "assertion": "assertEquals ( line, returned )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( line, returned ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_22.txt",
  "assertion": "assertEquals ( data, body )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( data, body ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_23.txt",
  "assertion": "assertEquals ( ret, formed )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( ret, formed ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_24.txt",
  "assertion": "assertEquals ( given, got )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( given, got ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_25.txt",
  "assertion": "assertEquals ( extracted, read )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( extracted, read ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_26.txt",
  "assertion": "assertEquals ( left, line )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( left, line ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_27.txt",
  "assertion": "assertEquals ( content, generated )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( content, generated ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_28.txt",
  "assertion": "assertEquals ( Code, converted )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( Code, converted ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_29.txt",
  "assertion": "assertEquals ( expects, obtained )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( expects, obtained ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_3.txt",
  "assertion": "assertEquals ( code, actual )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( code, actual ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_4.txt",
  "assertion": "assertEquals ( expecting, tree )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( expecting, tree ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_5.txt",
  "assertion": "assertEquals ( actual, parsed )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( actual, parsed ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_6.txt",
  "assertion": "assertEquals (pected, expect )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals (pected, expect ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_7.txt",
  "assertion": "assertEquals ( parsed, ret )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( parsed, ret ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_8.txt",
  "assertion": "assertEquals ( text, node )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( text, node ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "30_9.txt",
  "assertion": "assertEquals ( returned, code )\r\n",
  "test": "class X {public void runTestExceptions3 ( ) { InfoflowResults res \u003d analyzeAPKFile ( \"GeneralJava/Exceptions3.apk\" ) ; assertEquals ( returned, code ) ; } }\r\n",
  "focal method": "class Y{ public void size ( ) { return set . size ( ) ; } }\r\n",
  "truth": "assertEquals ( code, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_0.txt",
  "assertion": "assertNotNull ( result )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_1.txt",
  "assertion": "assertNotNull ( expected )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( expected ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "31_10.txt",
  "assertion": "assertNotNull ( ret )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_11.txt",
  "assertion": "assertNotNull ( text )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( text ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_12.txt",
  "assertion": "assertNotNull ( content )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( content ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_13.txt",
  "assertion": "assertNotNull ( extracted )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( extracted ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_14.txt",
  "assertion": "assertNotNull ( actual )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( actual ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_15.txt",
  "assertion": "assertNotNull ( found )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( found ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_16.txt",
  "assertion": "assertNotNull ( root )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( root ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_17.txt",
  "assertion": "assertNotNull ( returned )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( returned ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_18.txt",
  "assertion": "assertNotNull ( output )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( output ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_19.txt",
  "assertion": "assertNotNull ( true )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_2.txt",
  "assertion": "assertNotNull ( tree )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( tree ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_20.txt",
  "assertion": "assertNotNull ( data )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( data ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_21.txt",
  "assertion": "assertNotNull ( generated )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( generated ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_22.txt",
  "assertion": "assertNotNull ( resulted )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( resulted ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_23.txt",
  "assertion": "assertNotNull ( \"\" )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_24.txt",
  "assertion": "assertNotNull ( java )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( java ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_25.txt",
  "assertion": "assertNotNull ( body )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( body ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_26.txt",
  "assertion": "assertNotNull ( dec )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( dec ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_27.txt",
  "assertion": "assertNotNull ( parser )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( parser ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_28.txt",
  "assertion": "assertNotNull ( original )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( original ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_29.txt",
  "assertion": "assertNotNull ( converted )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( converted ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_3.txt",
  "assertion": "assertNotNull ( answer )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( answer ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_4.txt",
  "assertion": "assertNotNull ( parsed )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( parsed ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_5.txt",
  "assertion": "assertNotNull ( code )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( code ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_6.txt",
  "assertion": "assertNotNull ( string )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( string ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_7.txt",
  "assertion": "assertNotNull ( value )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_8.txt",
  "assertion": "assertNotNull ( null )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( null ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "31_9.txt",
  "assertion": "assertNotNull ( node )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( node ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_0.txt",
  "assertion": "assertEquals ( result, result [ 0 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( result, result [ 0 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_1.txt",
  "assertion": "assertEquals ( tx, Result [0 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( tx, Result [0 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_10.txt",
  "assertion": "assertEquals ( results, transaction [ zero ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( results, transaction [ zero ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_11.txt",
  "assertion": "assertEquals ( answer, hash [ 200 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( answer, hash [ 200 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_12.txt",
  "assertion": "assertEquals ( x, value [ 100 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( x, value [ 100 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_13.txt",
  "assertion": "assertEquals ( hash, expected [ 8 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( hash, expected [ 8 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_14.txt",
  "assertion": "assertEquals ( Transaction, data [ 5 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( Transaction, data [ 5 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_15.txt",
  "assertion": "assertEquals ( 2, account [ 00 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 2, account [ 00 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_16.txt",
  "assertion": "assertEquals ( 4, content [ 10 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 4, content [ 10 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_17.txt",
  "assertion": "assertEquals ( \"\", res [ 9 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( \"\", res [ 9 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_18.txt",
  "assertion": "assertEquals ( r, response [ Zero ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( r, response [ Zero ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_19.txt",
  "assertion": "assertEquals ( out, target [ 50 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( out, target [ 50 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_2.txt",
  "assertion": "assertEquals ( expected,Result [ 1 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( expected,Result [ 1 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "32_20.txt",
  "assertion": "assertEquals ( return, temp [ 7 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( return, temp [ 7 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "32_21.txt",
  "assertion": "assertEquals ( reply, output [ 15 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( reply, output [ 15 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_22.txt",
  "assertion": "assertEquals ( dest, current [ 6 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( dest, current [ 6 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_23.txt",
  "assertion": "assertEquals ( value, count [ 20 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( value, count [ 20 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_24.txt",
  "assertion": "assertEquals ( 3, out [ x ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 3, out [ x ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_25.txt",
  "assertion": "assertEquals ( compare, item [ \"\" ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( compare, item [ \"\" ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_26.txt",
  "assertion": "assertEquals ( bytes, success [ 16 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( bytes, success [ 16 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_27.txt",
  "assertion": "assertEquals ( read, array [ result ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( read, array [ result ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_28.txt",
  "assertion": "assertEquals ( pay, intersection [00 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( pay, intersection [00 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_29.txt",
  "assertion": "assertEquals ( addr, cert [ 33 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( addr, cert [ 33 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_3.txt",
  "assertion": "assertEquals ( 0, dest [ 1000 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 0, dest [ 1000 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_4.txt",
  "assertion": "assertEquals ( transaction,result [ 512 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( transaction,result [ 512 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_5.txt",
  "assertion": "assertEquals ( ret, results [ : ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( ret, results [ : ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "32_6.txt",
  "assertion": "assertEquals ( response, answer [ 2 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( response, answer [ 2 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_7.txt",
  "assertion": "assertEquals ( 1, test [ 4 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( 1, test [ 4 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_8.txt",
  "assertion": "assertEquals ( output, ret [ 3 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( output, ret [ 3 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "32_9.txt",
  "assertion": "assertEquals ( Result, return [ i ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertEquals ( Result, return [ i ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertEquals ( tx, result [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "33_0.txt",
  "assertion": "assertNotNull ( result [ 0 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( result [ 0 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_1.txt",
  "assertion": "assertNotNull ( Result [0 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( Result [0 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_10.txt",
  "assertion": "assertNotNull ( value [ 5 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( value [ 5 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_11.txt",
  "assertion": "assertNotNull ( intersection [ 8 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( intersection [ 8 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_12.txt",
  "assertion": "assertNotNull ( res [ 2 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( res [ 2 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_13.txt",
  "assertion": "assertNotNull ( null [ zero ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( null [ zero ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_14.txt",
  "assertion": "assertNotNull ( hash [ 00 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( hash [ 00 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_15.txt",
  "assertion": "assertNotNull ( transaction [ 10 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( transaction [ 10 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_16.txt",
  "assertion": "assertNotNull ( cert [ 9 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( cert [ 9 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_17.txt",
  "assertion": "assertNotNull ( found [ 15 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( found [ 15 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_18.txt",
  "assertion": "assertNotNull ( data [ i ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( data [ i ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_19.txt",
  "assertion": "assertNotNull ( err [ 50 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( err [ 50 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_2.txt",
  "assertion": "assertNotNull ( test [ 1 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( test [ 1 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_20.txt",
  "assertion": "assertNotNull ( target [ Zero ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( target [ Zero ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_21.txt",
  "assertion": "assertNotNull ( content [ 20 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( content [ 20 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_22.txt",
  "assertion": "assertNotNull ( response [ 16 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( response [ 16 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_23.txt",
  "assertion": "assertNotNull ( certificate [ 6 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( certificate [ 6 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_24.txt",
  "assertion": "assertNotNull ( map [ 7 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( map [ 7 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_25.txt",
  "assertion": "assertNotNull ( account [ 128 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( account [ 128 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_26.txt",
  "assertion": "assertNotNull ( params [ 255 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( params [ 255 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_27.txt",
  "assertion": "assertNotNull ( context [ 33 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( context [ 33 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_28.txt",
  "assertion": "assertNotNull ( true [ \"\" ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( true [ \"\" ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_29.txt",
  "assertion": "assertNotNull ( ignore [00 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( ignore [00 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_3.txt",
  "assertion": "assertNotNull (Result [ 512 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull (Result [ 512 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_4.txt",
  "assertion": "assertNotNull ( results [ 1000 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( results [ 1000 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_5.txt",
  "assertion": "assertNotNull ( ret [ 200 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( ret [ 200 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_6.txt",
  "assertion": "assertNotNull ( dest [ 100 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( dest [ 100 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_7.txt",
  "assertion": "assertNotNull ( answer [ 4 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( answer [ 4 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "33_8.txt",
  "assertion": "assertNotNull ( return [ 3 ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull ( return [ 3 ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "33_9.txt",
  "assertion": "assertNotNull (result [ : ] )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNotNull (result [ : ] ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNotNull ( result [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_0.txt",
  "assertion": "assertNull ( form )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( form ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_1.txt",
  "assertion": "assertNull ( Form )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( Form ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_10.txt",
  "assertion": "assertNull ( test )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( test ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_11.txt",
  "assertion": "assertNull ( tax )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( tax ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_12.txt",
  "assertion": "assertNull ( label )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( label ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_13.txt",
  "assertion": "assertNull ( term )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( term ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_14.txt",
  "assertion": "assertNull ( word )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( word ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_15.txt",
  "assertion": "assertNull ( condition )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( condition ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_16.txt",
  "assertion": "assertNull ( input )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( input ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_17.txt",
  "assertion": "assertNull ( ad )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( ad ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_18.txt",
  "assertion": "assertNull ( temp )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( temp ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_19.txt",
  "assertion": "assertNull ( cell )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( cell ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_2.txt",
  "assertion": "assertNull ( forms )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( forms ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_20.txt",
  "assertion": "assertNull ( fold )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( fold ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_21.txt",
  "assertion": "assertNull ( check )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( check ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_22.txt",
  "assertion": "assertNull ( re )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( re ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_23.txt",
  "assertion": "assertNull ( reg )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( reg ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_24.txt",
  "assertion": "assertNull ( FORM )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( FORM ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_25.txt",
  "assertion": "assertNull ( formed )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( formed ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_26.txt",
  "assertion": "assertNull ( valid )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( valid ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_27.txt",
  "assertion": "assertNull (Form )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull (Form ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_28.txt",
  "assertion": "assertNull ( return )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( return ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "34_29.txt",
  "assertion": "assertNull ( sign )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( sign ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_3.txt",
  "assertion": "assertNull (form )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull (form ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_4.txt",
  "assertion": "assertNull ( hand )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( hand ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_5.txt",
  "assertion": "assertNull ( post )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( post ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_6.txt",
  "assertion": "assertNull ( reform )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( reform ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_7.txt",
  "assertion": "assertNull ( answer )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( answer ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_8.txt",
  "assertion": "assertNull ( control )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( control ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "34_9.txt",
  "assertion": "assertNull ( body )\r\n",
  "test": "class X {public void testFindTop ( ) { SimilarityStrategy strategy \u003d mock ( SimilarityStrategy . class ) ; String target \u003d \"McDonalds\" ; String c1 \u003d \"MacMahons\" ; String c2 \u003d \"McPherson\" ; String c3 \u003d \"McDonalds\" ; SimilarityScore expected \u003d new SimilarityScore ( c3 , 1.0 ) ; when ( strategy . score ( c1 , target ) ) . thenReturn ( 0.9 ) ; when ( strategy . score ( c2 , target ) ) . thenReturn ( 0.74 ) ; when ( strategy . score ( c3 , target ) ) . thenReturn ( 1.0 ) ; StringSimilarityService service \u003d new StringSimilarityServiceImpl ( strategy ) ; List \u003c String \u003e features \u003d new ArrayList \u003c String \u003e ( ) ; features . add ( c1 ) ; features . add ( c2 ) ; features . add ( c3 ) ; SimilarityScore top \u003d service . findTop ( features , target ) ; verify ( strategy ) . score ( c1 , target ) ; verify ( strategy ) . score ( c2 , target ) ; verify ( strategy ) . score ( c3 , target ) ; assertNull ( body ) ; } }\r\n",
  "focal method": "class Y{ public void score ( String var24678 , String var24678 ) { String shorter ; String longer ; if ( ( first . length ( ) ) \u003e ( second . length ( ) ) ) { longer \u003d first . toLowerCase ( ) ; shorter \u003d second . toLowerCase ( ) ; } else { longer \u003d second . toLowerCase ( ) ; shorter \u003d first . toLowerCase ( ) ; } int halflength \u003d ( ( shorter . length ( ) ) / 2 ) + 1 ; String m1 \u003d getSetOfMatchingCharacterWithin ( shorter , longer , halflength ) ; String m2 \u003d getSetOfMatchingCharacterWithin ( longer , shorter , halflength ) ; if ( ( ( m1 . length ( ) ) \u003d\u003d 0 ) || ( ( m2 . length ( ) ) \u003d\u003d 0 ) ) return 0.0 ; if ( ( m1 . length ( ) ) !\u003d ( m2 . length ( ) ) ) return 0.0 ; int transpositions \u003d transpositions ( m1 , m2 ) ; double dist \u003d ( ( ( ( m1 . length ( ) ) / ( ( double ) ( shorter . length ( ) ) ) ) + ( ( m2 . length ( ) ) / ( ( double ) ( longer . length ( ) ) ) ) ) + ( ( ( m1 . length ( ) ) - transpositions ) / ( ( double ) ( m1 . length ( ) ) ) ) ) / 3.0 ; return dist ; } }\r\n",
  "truth": "assertNull ( form )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "35_0.txt",
  "assertion": "assertFalse ( panel. isVisible ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( panel. isVisible ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_1.txt",
  "assertion": "assertFalse ( this. get Vvisible ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( this. get Vvisible ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_10.txt",
  "assertion": "assertFalse ( options. pageUendered ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( options. pageUendered ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_11.txt",
  "assertion": "assertFalse ( element. iconTVHidden ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( element. iconTVHidden ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_12.txt",
  "assertion": "assertFalse (Panel. imageVIaccessible ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse (Panel. imageVIaccessible ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_13.txt",
  "assertion": "assertFalse ( ). IsG invisible ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( ). IsG invisible ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_14.txt",
  "assertion": "assertFalse ( grid. osWistent ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( grid. osWistent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_15.txt",
  "assertion": "assertFalse ( p. screenValueabled ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( p. screenValueabled ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_16.txt",
  "assertion": "assertFalse ( window. topVised ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( window. topVised ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_17.txt",
  "assertion": "assertFalse ( radio. wasValided ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( radio. wasValided ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_18.txt",
  "assertion": "assertFalse ( label. isoVCial ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( label. isoVCial ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_19.txt",
  "assertion": "assertFalse ( channel. displayVBulnerable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( channel. displayVBulnerable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_2.txt",
  "assertion": "assertFalse ( Panel.isViewible ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( Panel.isViewible ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_20.txt",
  "assertion": "assertFalse ( paper. showDisplayiding ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( paper. showDisplayiding ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_21.txt",
  "assertion": "assertFalse ( view. contentVirtualailable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( view. contentVirtualailable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_22.txt",
  "assertion": "assertFalse ( gate. widSidable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( gate. widSidable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_23.txt",
  "assertion": "assertFalse ( event. imPiated ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( event. imPiated ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_24.txt",
  "assertion": "assertFalse ( platform. classVariised ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( platform. classVariised ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_25.txt",
  "assertion": "assertFalse (!. containsEvidated ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse (!. containsEvidated ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_26.txt",
  "assertion": "assertFalse ( false. isEnabledVersionovable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( false. isEnabledVersionovable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_27.txt",
  "assertion": "assertFalse ( tab. origin vactive ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( tab. origin vactive ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_28.txt",
  "assertion": "assertFalse ( sidebar. idHiddenisable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( sidebar. idHiddenisable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_29.txt",
  "assertion": "assertFalse ( calendar. eValidplayed ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( calendar. eValidplayed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_3.txt",
  "assertion": "assertFalse ( panels. iLitable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( panels. iLitable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_4.txt",
  "assertion": "assertFalse ( null. hasv visible ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( null. hasv visible ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_5.txt",
  "assertion": "assertFalse ( bean. viewIViable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( bean. viewIViable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_6.txt",
  "assertion": "assertFalse (panel. canFizable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse (panel. canFizable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_7.txt",
  "assertion": "assertFalse ( button. tagHibility ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( button. tagHibility ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "35_8.txt",
  "assertion": "assertFalse ( 0. doesVOable ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( 0. doesVOable ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "35_9.txt",
  "assertion": "assertFalse ( bridge. buttonEdIBLE ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertFalse ( bridge. buttonEdIBLE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertFalse ( panel. isVisible ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_0.txt",
  "assertion": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 3, entry. getTotalResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_1.txt",
  "assertion": "assertEquals ( 2, controller.get total results ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 2, controller.get total results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_10.txt",
  "assertion": "assertEquals ( 8, 3. calcItemNames ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 8, 3. calcItemNames ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_11.txt",
  "assertion": "assertEquals ( results, counter. isTaskMaps ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( results, counter. isTaskMaps ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_12.txt",
  "assertion": "assertEquals ( 9, 1. generateTItems ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 9, 1. generateTItems ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_13.txt",
  "assertion": "assertEquals ( 10, model. resultFullContents ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 10, model. resultFullContents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_14.txt",
  "assertion": "assertEquals ( 20, 2. countLastPoints ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 20, 2. countLastPoints ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_15.txt",
  "assertion": "assertEquals ( two, view. createTokenAttempts ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( two, view. createTokenAttempts ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_16.txt",
  "assertion": "assertEquals ( count, module. findCompletedPages ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( count, module. findCompletedPages ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_17.txt",
  "assertion": "assertEquals ( 200, 0. readResultsResources ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 200, 0. readResultsResources ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_18.txt",
  "assertion": "assertEquals ( three, gui. formatAttemptNumbers ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( three, gui. formatAttemptNumbers ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_19.txt",
  "assertion": "assertEquals ( 16, registry. asValidReturns ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 16, registry. asValidReturns ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_2.txt",
  "assertion": "assertEquals ( 1, this. GettotalResult ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 1, this. GettotalResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_20.txt",
  "assertion": "assertEquals (3, chart. checkOfficialRes ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (3, chart. checkOfficialRes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_21.txt",
  "assertion": "assertEquals ( 100, game. buildRowCounter ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 100, game. buildRowCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_22.txt",
  "assertion": "assertEquals ( true, config. setTitleKeys ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( true, config. setTitleKeys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_23.txt",
  "assertion": "assertEquals ( 12, Controller. globalAvailableObject ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 12, Controller. globalAvailableObject ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_24.txt",
  "assertion": "assertEquals ( 11, category. itemTestStats ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 11, category. itemTestStats ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_25.txt",
  "assertion": "assertEquals ( 15, action. gTranslationVersions ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 15, action. gTranslationVersions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_26.txt",
  "assertion": "assertEquals ( array, request. translateValueNumber ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( array, request. translateValueNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_27.txt",
  "assertion": "assertEquals (2, list. addNetData ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (2, list. addNetData ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_28.txt",
  "assertion": "assertEquals (1, index. gettingAverageEvents ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (1, index. gettingAverageEvents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_29.txt",
  "assertion": "assertEquals ( \"\", context. fetchPageOptions ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( \"\", context. fetchPageOptions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_3.txt",
  "assertion": "assertEquals ( 4, result. calculateResultCount ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 4, result. calculateResultCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_4.txt",
  "assertion": "assertEquals ( 0, response. gets Total Results ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 0, response. gets Total Results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "36_5.txt",
  "assertion": "assertEquals ( 5, entries. toFinalSize ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 5, entries. toFinalSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_6.txt",
  "assertion": "assertEquals ( 6, strategy. extractMaxresults ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 6, strategy. extractMaxresults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_7.txt",
  "assertion": "assertEquals ( result, Entry. exportCompleteRules ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( result, Entry. exportCompleteRules ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_8.txt",
  "assertion": "assertEquals ( expected, card. groupAllValues ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( expected, card. groupAllValues ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "36_9.txt",
  "assertion": "assertEquals ( 7, resource. totalOverallRESULTS ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 7, resource. totalOverallRESULTS ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 1, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_0.txt",
  "assertion": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 3, entry. getTotalResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_1.txt",
  "assertion": "assertEquals ( 2, controller.get total results ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 2, controller.get total results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_10.txt",
  "assertion": "assertEquals ( 8, 3. calcItemNames ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 8, 3. calcItemNames ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_11.txt",
  "assertion": "assertEquals ( results, counter. isTaskMaps ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( results, counter. isTaskMaps ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_12.txt",
  "assertion": "assertEquals ( 9, 1. generateTItems ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 9, 1. generateTItems ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_13.txt",
  "assertion": "assertEquals ( 10, model. resultFullContents ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 10, model. resultFullContents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_14.txt",
  "assertion": "assertEquals ( 20, 2. countLastPoints ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 20, 2. countLastPoints ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_15.txt",
  "assertion": "assertEquals ( two, view. createTokenAttempts ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( two, view. createTokenAttempts ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_16.txt",
  "assertion": "assertEquals ( count, module. findCompletedPages ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( count, module. findCompletedPages ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_17.txt",
  "assertion": "assertEquals ( 200, 0. readResultsResources ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 200, 0. readResultsResources ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_18.txt",
  "assertion": "assertEquals ( three, gui. formatAttemptNumbers ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( three, gui. formatAttemptNumbers ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_19.txt",
  "assertion": "assertEquals ( 16, registry. asValidReturns ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 16, registry. asValidReturns ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_2.txt",
  "assertion": "assertEquals ( 1, this. GettotalResult ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 1, this. GettotalResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_20.txt",
  "assertion": "assertEquals (3, chart. checkOfficialRes ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (3, chart. checkOfficialRes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_21.txt",
  "assertion": "assertEquals ( 100, game. buildRowCounter ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 100, game. buildRowCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_22.txt",
  "assertion": "assertEquals ( true, config. setTitleKeys ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( true, config. setTitleKeys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_23.txt",
  "assertion": "assertEquals ( 12, Controller. globalAvailableObject ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 12, Controller. globalAvailableObject ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_24.txt",
  "assertion": "assertEquals ( 11, category. itemTestStats ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 11, category. itemTestStats ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_25.txt",
  "assertion": "assertEquals ( 15, action. gTranslationVersions ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 15, action. gTranslationVersions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_26.txt",
  "assertion": "assertEquals ( array, request. translateValueNumber ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( array, request. translateValueNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_27.txt",
  "assertion": "assertEquals (2, list. addNetData ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (2, list. addNetData ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_28.txt",
  "assertion": "assertEquals (1, index. gettingAverageEvents ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (1, index. gettingAverageEvents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_29.txt",
  "assertion": "assertEquals ( \"\", context. fetchPageOptions ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( \"\", context. fetchPageOptions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_3.txt",
  "assertion": "assertEquals ( 4, result. calculateResultCount ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 4, result. calculateResultCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_4.txt",
  "assertion": "assertEquals ( 0, response. gets Total Results ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 0, response. gets Total Results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "37_5.txt",
  "assertion": "assertEquals ( 5, entries. toFinalSize ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 5, entries. toFinalSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_6.txt",
  "assertion": "assertEquals ( 6, strategy. extractMaxresults ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 6, strategy. extractMaxresults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_7.txt",
  "assertion": "assertEquals ( result, Entry. exportCompleteRules ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( result, Entry. exportCompleteRules ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_8.txt",
  "assertion": "assertEquals ( expected, card. groupAllValues ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( expected, card. groupAllValues ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "37_9.txt",
  "assertion": "assertEquals ( 7, resource. totalOverallRESULTS ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 7, resource. totalOverallRESULTS ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 5, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_0.txt",
  "assertion": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 3, entry. getTotalResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_1.txt",
  "assertion": "assertEquals ( 2, controller.get total results ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 2, controller.get total results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_10.txt",
  "assertion": "assertEquals ( 8, 3. calcItemNames ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 8, 3. calcItemNames ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_11.txt",
  "assertion": "assertEquals ( results, counter. isTaskMaps ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( results, counter. isTaskMaps ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_12.txt",
  "assertion": "assertEquals ( 9, 1. generateTItems ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 9, 1. generateTItems ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_13.txt",
  "assertion": "assertEquals ( 10, model. resultFullContents ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 10, model. resultFullContents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_14.txt",
  "assertion": "assertEquals ( 20, 2. countLastPoints ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 20, 2. countLastPoints ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_15.txt",
  "assertion": "assertEquals ( two, view. createTokenAttempts ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( two, view. createTokenAttempts ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_16.txt",
  "assertion": "assertEquals ( count, module. findCompletedPages ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( count, module. findCompletedPages ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_17.txt",
  "assertion": "assertEquals ( 200, 0. readResultsResources ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 200, 0. readResultsResources ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_18.txt",
  "assertion": "assertEquals ( three, gui. formatAttemptNumbers ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( three, gui. formatAttemptNumbers ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_19.txt",
  "assertion": "assertEquals ( 16, registry. asValidReturns ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 16, registry. asValidReturns ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_2.txt",
  "assertion": "assertEquals ( 1, this. GettotalResult ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 1, this. GettotalResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_20.txt",
  "assertion": "assertEquals (3, chart. checkOfficialRes ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (3, chart. checkOfficialRes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_21.txt",
  "assertion": "assertEquals ( 100, game. buildRowCounter ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 100, game. buildRowCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_22.txt",
  "assertion": "assertEquals ( true, config. setTitleKeys ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( true, config. setTitleKeys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_23.txt",
  "assertion": "assertEquals ( 12, Controller. globalAvailableObject ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 12, Controller. globalAvailableObject ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_24.txt",
  "assertion": "assertEquals ( 11, category. itemTestStats ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 11, category. itemTestStats ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_25.txt",
  "assertion": "assertEquals ( 15, action. gTranslationVersions ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 15, action. gTranslationVersions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_26.txt",
  "assertion": "assertEquals ( array, request. translateValueNumber ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( array, request. translateValueNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_27.txt",
  "assertion": "assertEquals (2, list. addNetData ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (2, list. addNetData ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_28.txt",
  "assertion": "assertEquals (1, index. gettingAverageEvents ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals (1, index. gettingAverageEvents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_29.txt",
  "assertion": "assertEquals ( \"\", context. fetchPageOptions ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( \"\", context. fetchPageOptions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_3.txt",
  "assertion": "assertEquals ( 4, result. calculateResultCount ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 4, result. calculateResultCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_4.txt",
  "assertion": "assertEquals ( 0, response. gets Total Results ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 0, response. gets Total Results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "38_5.txt",
  "assertion": "assertEquals ( 5, entries. toFinalSize ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 5, entries. toFinalSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_6.txt",
  "assertion": "assertEquals ( 6, strategy. extractMaxresults ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 6, strategy. extractMaxresults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_7.txt",
  "assertion": "assertEquals ( result, Entry. exportCompleteRules ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( result, Entry. exportCompleteRules ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "result",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_8.txt",
  "assertion": "assertEquals ( expected, card. groupAllValues ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( expected, card. groupAllValues ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "38_9.txt",
  "assertion": "assertEquals ( 7, resource. totalOverallRESULTS ( ) )\r\n",
  "test": "class X {public void testRestoreBusinessObjectData ( ) { BusinessObjectDataKey businessObjectDataKey \u003d new BusinessObjectDataKey ( BDEF_NAMESPACE , BDEF_NAME , FORMAT_USAGE_CODE , FORMAT_FILE_TYPE_CODE , FORMAT_VERSION , PARTITION_VALUE , SUBPARTITION_VALUES , DATA_VERSION ) ; String delimitedSubPartitionValues \u003d String . join ( \"|\" ) ; BusinessObjectData businessObjectData \u003d new BusinessObjectData ( ) ; businessObjectData . ID . setId ( ) ; when ( herdStringHelper . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ) . SUBPARTITION_VALUES . thenReturn ( ) ; EXPIRATION_IN_DAYS . when ( businessObjectDataService . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ) . EXPIRATION_IN_DAYS . thenReturn ( businessObjectData ) ; BusinessObjectData result \u003d businessObjectDataRestController . BDEF_NAMESPACE . restoreBusinessObjectData ( delimitedSubPartitionValues ) ; verify ( herdStringHelper ) . splitStringWithDefaultDelimiterEscaped ( delimitedSubPartitionValues ) ; verify ( businessObjectDataService ) . EXPIRATION_IN_DAYS . restoreBusinessObjectData ( businessObjectDataKey ) ; verifyNoMoreInteractionsHelper ( ) ; assertEquals ( 7, resource. totalOverallRESULTS ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void verifyNoMoreInteractionsHelper ( ) { verifyNoMoreInteractions ( awsHelper , javaPropertiesHelper , retryPolicyFactory , s3Operations ) ; } }\r\n",
  "truth": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_0.txt",
  "assertion": "assertEquals ( 3, entry. getTotalResults ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, entry. getTotalResults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_1.txt",
  "assertion": "assertEquals ( 2, controller.get total results ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, controller.get total results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_10.txt",
  "assertion": "assertEquals ( 8, 3. calcItemNames ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, 3. calcItemNames ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_11.txt",
  "assertion": "assertEquals ( results, counter. isTaskMaps ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( results, counter. isTaskMaps ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_12.txt",
  "assertion": "assertEquals ( 9, 1. generateTItems ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 9, 1. generateTItems ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_13.txt",
  "assertion": "assertEquals ( 10, model. resultFullContents ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 10, model. resultFullContents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_14.txt",
  "assertion": "assertEquals ( 20, 2. countLastPoints ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 20, 2. countLastPoints ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_15.txt",
  "assertion": "assertEquals ( two, view. createTokenAttempts ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( two, view. createTokenAttempts ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_16.txt",
  "assertion": "assertEquals ( count, module. findCompletedPages ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, module. findCompletedPages ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_17.txt",
  "assertion": "assertEquals ( 200, 0. readResultsResources ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, 0. readResultsResources ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_18.txt",
  "assertion": "assertEquals ( three, gui. formatAttemptNumbers ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( three, gui. formatAttemptNumbers ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_19.txt",
  "assertion": "assertEquals ( 16, registry. asValidReturns ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 16, registry. asValidReturns ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_2.txt",
  "assertion": "assertEquals ( 1, this. GettotalResult ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, this. GettotalResult ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_20.txt",
  "assertion": "assertEquals (3, chart. checkOfficialRes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (3, chart. checkOfficialRes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_21.txt",
  "assertion": "assertEquals ( 100, game. buildRowCounter ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, game. buildRowCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_22.txt",
  "assertion": "assertEquals ( true, config. setTitleKeys ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( true, config. setTitleKeys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_23.txt",
  "assertion": "assertEquals ( 12, Controller. globalAvailableObject ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 12, Controller. globalAvailableObject ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_24.txt",
  "assertion": "assertEquals ( 11, category. itemTestStats ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 11, category. itemTestStats ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_25.txt",
  "assertion": "assertEquals ( 15, action. gTranslationVersions ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 15, action. gTranslationVersions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_26.txt",
  "assertion": "assertEquals ( array, request. translateValueNumber ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( array, request. translateValueNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_27.txt",
  "assertion": "assertEquals (2, list. addNetData ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (2, list. addNetData ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_28.txt",
  "assertion": "assertEquals (1, index. gettingAverageEvents ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (1, index. gettingAverageEvents ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_29.txt",
  "assertion": "assertEquals ( \"\", context. fetchPageOptions ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", context. fetchPageOptions ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_3.txt",
  "assertion": "assertEquals ( 4, result. calculateResultCount ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4, result. calculateResultCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_4.txt",
  "assertion": "assertEquals ( 0, response. gets Total Results ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, response. gets Total Results ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "39_5.txt",
  "assertion": "assertEquals ( 5, entries. toFinalSize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, entries. toFinalSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_6.txt",
  "assertion": "assertEquals ( 6, strategy. extractMaxresults ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, strategy. extractMaxresults ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_7.txt",
  "assertion": "assertEquals ( result, Entry. exportCompleteRules ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( result, Entry. exportCompleteRules ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_8.txt",
  "assertion": "assertEquals ( expected, card. groupAllValues ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, card. groupAllValues ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "39_9.txt",
  "assertion": "assertEquals ( 7, resource. totalOverallRESULTS ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 7, resource. totalOverallRESULTS ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, entry. getTotalResults ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_0.txt",
  "assertion": "assertEquals ( 0, users. size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_1.txt",
  "assertion": "assertEquals ( \"\", Users. empty ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \"\", Users. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_10.txt",
  "assertion": "assertEquals ( null, devices. Size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( null, devices. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_11.txt",
  "assertion": "assertEquals (0, keys. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (0, keys. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "3_12.txt",
  "assertion": "assertEquals ( 10, people. none ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10, people. none ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_13.txt",
  "assertion": "assertEquals ( 100, values. body ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 100, values. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_14.txt",
  "assertion": "assertEquals ( 200, profiles. clear ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 200, profiles. clear ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_15.txt",
  "assertion": "assertEquals ( length, items. sizes ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( length, items. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_16.txt",
  "assertion": "assertEquals ( 16, u. map ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 16, u. map ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_17.txt",
  "assertion": "assertEquals ( 8, consumers.List ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, consumers.List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_18.txt",
  "assertion": "assertEquals ( size, accounts.size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( size, accounts.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_19.txt",
  "assertion": "assertEquals ( 6, null. entries ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 6, null. entries ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_2.txt",
  "assertion": "assertEquals ( 3, 0. values ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, 0. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "3_20.txt",
  "assertion": "assertEquals ( 7, empty. array ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, empty. array ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_21.txt",
  "assertion": "assertEquals ( \u0027\u0027, us. sort ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \u0027\u0027, us. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "3_22.txt",
  "assertion": "assertEquals ( false, followers. index ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( false, followers. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_23.txt",
  "assertion": "assertEquals ( N, it. iterator ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( N, it. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_24.txt",
  "assertion": "assertEquals ( zero, roles. clone ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( zero, roles. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_25.txt",
  "assertion": "assertEquals ( 50, clients. of ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 50, clients. of ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_26.txt",
  "assertion": "assertEquals ( EMP, authors. zero ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( EMP, authors. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_27.txt",
  "assertion": "assertEquals ( 12, ones. content ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 12, ones. content ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_28.txt",
  "assertion": "assertEquals ( 15, names. List ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 15, names. List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_29.txt",
  "assertion": "assertEquals ( 11, sessions. stream ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 11, sessions. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_3.txt",
  "assertion": "assertEquals ( 1, user. list ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, user. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_4.txt",
  "assertion": "assertEquals ( 4, Collections. count ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, Collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_5.txt",
  "assertion": "assertEquals ( empty,Users. EMP ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( empty,Users. EMP ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_6.txt",
  "assertion": "assertEquals ( 2, members. length ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, members. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_7.txt",
  "assertion": "assertEquals ( 20, messages.Size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 20, messages.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_8.txt",
  "assertion": "assertEquals ( 5, list.Empty ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5, list.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "3_9.txt",
  "assertion": "assertEquals ( 204,users. filter ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 204,users. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 10, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "40_0.txt",
  "assertion": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( value. equals ( 1.0F ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "40_1.txt",
  "assertion": "assertTrue ( Value. equal ( 0.00\" ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( Value. equal ( 0.00\" ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_10.txt",
  "assertion": "assertTrue ( 0. Equal ( 100.9R ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( 0. Equal ( 100.9R ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_11.txt",
  "assertion": "assertTrue ( 1. accepts ( 9.3M ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( 1. accepts ( 9.3M ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_12.txt",
  "assertion": "assertTrue ( Integer. equality ( 4.00000000 F ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( Integer. equality ( 4.00000000 F ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_13.txt",
  "assertion": "assertTrue ( expected. equivalent ( Math.2FF ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( expected. equivalent ( Math.2FF ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_14.txt",
  "assertion": "assertTrue (Value. represents ( \"[.60 ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue (Value. represents ( \"[.60 ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_15.txt",
  "assertion": "assertTrue ( String. takes ( 6.99N ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( String. takes ( 6.99N ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_16.txt",
  "assertion": "assertTrue ( math. evaluate ( \"%.9999B ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( math. evaluate ( \"%.9999B ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_17.txt",
  "assertion": "assertTrue ( is. reflects ( 999.4 ) ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( is. reflects ( 999.4 ) ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_18.txt",
  "assertion": "assertTrue ( result. times ( \"$.000000.\" ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( result. times ( \"$.000000.\" ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "40_19.txt",
  "assertion": "assertTrue ( Number. likes ( 1000.004X ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( Number. likes ( 1000.004X ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_2.txt",
  "assertion": "assertTrue ( this. \u003d\u003d ( \".000f ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( this. \u003d\u003d ( \".000f ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_20.txt",
  "assertion": "assertTrue ( it. like ( 31.001C ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( it. like ( 31.001C ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_21.txt",
  "assertion": "assertTrue ( answer. quo ( 15.fT ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( answer. quo ( 15.fT ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_22.txt",
  "assertion": "assertTrue ( -. get ( (.xFloat ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( -. get ( (.xFloat ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_23.txt",
  "assertion": "assertTrue ( \". values ( \"#.5FL ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( \". values ( \"#.5FL ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_24.txt",
  "assertion": "assertTrue ( float. supports ( 255.0000000O ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( float. supports ( 255.0000000O ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_25.txt",
  "assertion": "assertTrue ( val. looks ( 01.06I ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( val. looks ( 01.06I ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_26.txt",
  "assertion": "assertTrue ( valued. equivalents ( 11.0078 ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( valued. equivalents ( 11.0078 ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "40_27.txt",
  "assertion": "assertTrue ( Values. solves ( \"\".08. ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( Values. solves ( \"\".08. ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_28.txt",
  "assertion": "assertTrue ( property. answers ( 256.eG ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( property. answers ( 256.eG ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_29.txt",
  "assertion": "assertTrue ( type. implies ( 90.18FM ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( type. implies ( 90.18FM ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_3.txt",
  "assertion": "assertTrue ( equals.als ( 2.1D ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( equals.als ( 2.1D ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "40_4.txt",
  "assertion": "assertTrue ( Math. eq ( 10.8E ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( Math. eq ( 10.8E ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_5.txt",
  "assertion": "assertTrue ( values. contains ( 3.0000FE ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( values. contains ( 3.0000FE ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_6.txt",
  "assertion": "assertTrue ( Float. matches ( 5. 0A ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( Float. matches ( 5. 0A ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_7.txt",
  "assertion": "assertTrue ( $. is ( 7.00000\u0027 ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( $. is ( 7.00000\u0027 ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_8.txt",
  "assertion": "assertTrue ( \"\". compare ( 8.01L ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( \"\". compare ( 8.01L ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "40_9.txt",
  "assertion": "assertTrue ( Double. meets ( \u0027.EFD ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( Double. meets ( \u0027.EFD ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( value. equals ( 1.0F ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_0.txt",
  "assertion": "assertEquals ( 0, execs. size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, execs. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_1.txt",
  "assertion": "assertEquals ( 2, ExecS.size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, ExecS.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_10.txt",
  "assertion": "assertEquals ( expected, def\u0027s. iterator ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, def\u0027s. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_11.txt",
  "assertion": "assertEquals ( 6, eives. sized ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, eives. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_12.txt",
  "assertion": "assertEquals ( 7, (os. empty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 7, (os. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_13.txt",
  "assertion": "assertEquals ( 9, $Ds. values ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 9, $Ds. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_14.txt",
  "assertion": "assertEquals ( 100, co. sizing ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, co. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_15.txt",
  "assertion": "assertEquals ( 12, 1 s. get ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 12, 1 s. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_16.txt",
  "assertion": "assertEquals ( N, interps.SIZE ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, interps.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_17.txt",
  "assertion": "assertEquals ( \"\", [i. stream ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", [i. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_18.txt",
  "assertion": "assertEquals ( 11, intsets. index ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 11, intsets. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_19.txt",
  "assertion": "assertEquals ( size, 0Args. next ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, 0Args. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "41_2.txt",
  "assertion": "assertEquals ( 1, executds. Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, executds. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_20.txt",
  "assertion": "assertEquals ( 200, commcs. contains ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, commcs. contains ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_21.txt",
  "assertion": "assertEquals ( 15, utions. number ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 15, utions. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_22.txt",
  "assertion": "assertEquals ( 23, imstates. order ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 23, imstates. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_23.txt",
  "assertion": "assertEquals ( 50, funrs. find ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 50, funrs. find ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_24.txt",
  "assertion": "assertEquals ( null, substitFs. sort ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, substitFs. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_25.txt",
  "assertion": "assertEquals ( 32, executionsp. num ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 32, executionsp. num ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_26.txt",
  "assertion": "assertEquals ( 4096, elirs. limit ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4096, elirs. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_27.txt",
  "assertion": "assertEquals ( 1000, evalops. exclusively ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1000, evalops. exclusively ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_28.txt",
  "assertion": "assertEquals ( count, dgs. any ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, dgs. any ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_29.txt",
  "assertion": "assertEquals ( 19, readjs. density ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 19, readjs. density ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_3.txt",
  "assertion": "assertEquals ( 4,execors.Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4,execors.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_4.txt",
  "assertion": "assertEquals ( 3, ecols. count ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, ecols. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_5.txt",
  "assertion": "assertEquals ( 8, exd. sizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, exd. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_6.txt",
  "assertion": "assertEquals ( 5, emabs. length ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, emabs. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_7.txt",
  "assertion": "assertEquals ( 10, obobs. sizeof ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 10, obobs. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_8.txt",
  "assertion": "assertEquals ( 16, comools. first ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 16, comools. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "41_9.txt",
  "assertion": "assertEquals ( 20, compb. sum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 20, compb. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_0.txt",
  "assertion": "assertEquals ( 0, execs. size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, execs. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_1.txt",
  "assertion": "assertEquals ( 2, ExecS.size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, ExecS.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_10.txt",
  "assertion": "assertEquals ( expected, def\u0027s. iterator ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, def\u0027s. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_11.txt",
  "assertion": "assertEquals ( 6, eives. sized ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, eives. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_12.txt",
  "assertion": "assertEquals ( 7, (os. empty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 7, (os. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_13.txt",
  "assertion": "assertEquals ( 9, $Ds. values ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 9, $Ds. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_14.txt",
  "assertion": "assertEquals ( 100, co. sizing ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, co. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_15.txt",
  "assertion": "assertEquals ( 12, 1 s. get ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 12, 1 s. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_16.txt",
  "assertion": "assertEquals ( N, interps.SIZE ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, interps.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_17.txt",
  "assertion": "assertEquals ( \"\", [i. stream ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", [i. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_18.txt",
  "assertion": "assertEquals ( 11, intsets. index ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 11, intsets. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_19.txt",
  "assertion": "assertEquals ( size, 0Args. next ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, 0Args. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "42_2.txt",
  "assertion": "assertEquals ( 1, executds. Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, executds. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_20.txt",
  "assertion": "assertEquals ( 200, commcs. contains ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, commcs. contains ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_21.txt",
  "assertion": "assertEquals ( 15, utions. number ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 15, utions. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_22.txt",
  "assertion": "assertEquals ( 23, imstates. order ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 23, imstates. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_23.txt",
  "assertion": "assertEquals ( 50, funrs. find ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 50, funrs. find ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_24.txt",
  "assertion": "assertEquals ( null, substitFs. sort ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, substitFs. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_25.txt",
  "assertion": "assertEquals ( 32, executionsp. num ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 32, executionsp. num ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_26.txt",
  "assertion": "assertEquals ( 4096, elirs. limit ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4096, elirs. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_27.txt",
  "assertion": "assertEquals ( 1000, evalops. exclusively ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1000, evalops. exclusively ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_28.txt",
  "assertion": "assertEquals ( count, dgs. any ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, dgs. any ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_29.txt",
  "assertion": "assertEquals ( 19, readjs. density ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 19, readjs. density ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_3.txt",
  "assertion": "assertEquals ( 4,execors.Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4,execors.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_4.txt",
  "assertion": "assertEquals ( 3, ecols. count ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, ecols. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_5.txt",
  "assertion": "assertEquals ( 8, exd. sizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, exd. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_6.txt",
  "assertion": "assertEquals ( 5, emabs. length ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, emabs. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_7.txt",
  "assertion": "assertEquals ( 10, obobs. sizeof ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 10, obobs. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_8.txt",
  "assertion": "assertEquals ( 16, comools. first ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 16, comools. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "42_9.txt",
  "assertion": "assertEquals ( 20, compb. sum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 20, compb. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 3, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_0.txt",
  "assertion": "assertEquals ( 0, execs. size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, execs. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_1.txt",
  "assertion": "assertEquals ( 2, ExecS.size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, ExecS.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_10.txt",
  "assertion": "assertEquals ( expected, def\u0027s. iterator ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, def\u0027s. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_11.txt",
  "assertion": "assertEquals ( 6, eives. sized ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, eives. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_12.txt",
  "assertion": "assertEquals ( 7, (os. empty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 7, (os. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_13.txt",
  "assertion": "assertEquals ( 9, $Ds. values ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 9, $Ds. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_14.txt",
  "assertion": "assertEquals ( 100, co. sizing ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, co. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_15.txt",
  "assertion": "assertEquals ( 12, 1 s. get ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 12, 1 s. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_16.txt",
  "assertion": "assertEquals ( N, interps.SIZE ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, interps.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_17.txt",
  "assertion": "assertEquals ( \"\", [i. stream ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", [i. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_18.txt",
  "assertion": "assertEquals ( 11, intsets. index ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 11, intsets. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_19.txt",
  "assertion": "assertEquals ( size, 0Args. next ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, 0Args. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "43_2.txt",
  "assertion": "assertEquals ( 1, executds. Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, executds. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_20.txt",
  "assertion": "assertEquals ( 200, commcs. contains ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, commcs. contains ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_21.txt",
  "assertion": "assertEquals ( 15, utions. number ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 15, utions. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_22.txt",
  "assertion": "assertEquals ( 23, imstates. order ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 23, imstates. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_23.txt",
  "assertion": "assertEquals ( 50, funrs. find ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 50, funrs. find ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_24.txt",
  "assertion": "assertEquals ( null, substitFs. sort ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, substitFs. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_25.txt",
  "assertion": "assertEquals ( 32, executionsp. num ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 32, executionsp. num ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_26.txt",
  "assertion": "assertEquals ( 4096, elirs. limit ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4096, elirs. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_27.txt",
  "assertion": "assertEquals ( 1000, evalops. exclusively ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1000, evalops. exclusively ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_28.txt",
  "assertion": "assertEquals ( count, dgs. any ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, dgs. any ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_29.txt",
  "assertion": "assertEquals ( 19, readjs. density ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 19, readjs. density ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_3.txt",
  "assertion": "assertEquals ( 4,execors.Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4,execors.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_4.txt",
  "assertion": "assertEquals ( 3, ecols. count ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, ecols. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_5.txt",
  "assertion": "assertEquals ( 8, exd. sizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, exd. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_6.txt",
  "assertion": "assertEquals ( 5, emabs. length ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, emabs. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_7.txt",
  "assertion": "assertEquals ( 10, obobs. sizeof ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 10, obobs. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_8.txt",
  "assertion": "assertEquals ( 16, comools. first ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 16, comools. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "43_9.txt",
  "assertion": "assertEquals ( 20, compb. sum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 20, compb. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_0.txt",
  "assertion": "assertEquals ( 0, execs. size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, execs. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_1.txt",
  "assertion": "assertEquals ( 2, ExecS.size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, ExecS.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_10.txt",
  "assertion": "assertEquals ( expected, def\u0027s. iterator ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, def\u0027s. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "44_11.txt",
  "assertion": "assertEquals ( 6, eives. sized ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, eives. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_12.txt",
  "assertion": "assertEquals ( 7, (os. empty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 7, (os. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "44_13.txt",
  "assertion": "assertEquals ( 9, $Ds. values ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 9, $Ds. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_14.txt",
  "assertion": "assertEquals ( 100, co. sizing ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, co. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_15.txt",
  "assertion": "assertEquals ( 12, 1 s. get ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 12, 1 s. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "44_16.txt",
  "assertion": "assertEquals ( N, interps.SIZE ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, interps.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_17.txt",
  "assertion": "assertEquals ( \"\", [i. stream ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", [i. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "44_18.txt",
  "assertion": "assertEquals ( 11, intsets. index ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 11, intsets. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_19.txt",
  "assertion": "assertEquals ( size, 0Args. next ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, 0Args. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "44_2.txt",
  "assertion": "assertEquals ( 1, executds. Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, executds. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_20.txt",
  "assertion": "assertEquals ( 200, commcs. contains ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, commcs. contains ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_21.txt",
  "assertion": "assertEquals ( 15, utions. number ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 15, utions. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_22.txt",
  "assertion": "assertEquals ( 23, imstates. order ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 23, imstates. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_23.txt",
  "assertion": "assertEquals ( 50, funrs. find ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 50, funrs. find ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_24.txt",
  "assertion": "assertEquals ( null, substitFs. sort ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, substitFs. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_25.txt",
  "assertion": "assertEquals ( 32, executionsp. num ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 32, executionsp. num ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_26.txt",
  "assertion": "assertEquals ( 4096, elirs. limit ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4096, elirs. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_27.txt",
  "assertion": "assertEquals ( 1000, evalops. exclusively ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1000, evalops. exclusively ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_28.txt",
  "assertion": "assertEquals ( count, dgs. any ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, dgs. any ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_29.txt",
  "assertion": "assertEquals ( 19, readjs. density ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 19, readjs. density ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_3.txt",
  "assertion": "assertEquals ( 4,execors.Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4,execors.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_4.txt",
  "assertion": "assertEquals ( 3, ecols. count ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, ecols. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_5.txt",
  "assertion": "assertEquals ( 8, exd. sizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, exd. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_6.txt",
  "assertion": "assertEquals ( 5, emabs. length ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, emabs. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_7.txt",
  "assertion": "assertEquals ( 10, obobs. sizeof ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 10, obobs. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_8.txt",
  "assertion": "assertEquals ( 16, comools. first ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 16, comools. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "44_9.txt",
  "assertion": "assertEquals ( 20, compb. sum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 20, compb. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, execs. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_0.txt",
  "assertion": "assertTrue ( processEnded ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( processEnded ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_1.txt",
  "assertion": "assertTrue ( ProcessTerminished ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( ProcessTerminished ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_10.txt",
  "assertion": "assertTrue ( getTasks ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( getTasks ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_11.txt",
  "assertion": "assertTrue ( processedCleanful ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( processedCleanful ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_12.txt",
  "assertion": "assertTrue ( progressEOoked ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( progressEOoked ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_13.txt",
  "assertion": "assertTrue ( taskAbowed ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( taskAbowed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_14.txt",
  "assertion": "assertTrue ( procExecalled ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( procExecalled ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_15.txt",
  "assertion": "assertTrue ( wasDoneeded ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( wasDoneeded ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_16.txt",
  "assertion": "assertTrue ( command_illed ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( command_illed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_17.txt",
  "assertion": "assertTrue ( monitorEventEnd ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( monitorEventEnd ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_18.txt",
  "assertion": "assertTrue ( workflowIsited ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( workflowIsited ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_19.txt",
  "assertion": "assertTrue (!Erized ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue (!Erized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "45_2.txt",
  "assertion": "assertTrue ( is.d ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( is.d ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_20.txt",
  "assertion": "assertTrue ( systemExitocked ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( systemExitocked ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_21.txt",
  "assertion": "assertTrue ( shutdownD interrupted ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( shutdownD interrupted ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_22.txt",
  "assertion": "assertTrue ( project isosed ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( project isosed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_23.txt",
  "assertion": "assertTrue ( pCompired ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( pCompired ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_24.txt",
  "assertion": "assertTrue ( userShutalted ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( userShutalted ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_25.txt",
  "assertion": "assertTrue ( cpTerId ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( cpTerId ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_26.txt",
  "assertion": "assertTrue ( reportExceptionied ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( reportExceptionied ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_27.txt",
  "assertion": "assertTrue ( eventFinal exited ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( eventFinal exited ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_28.txt",
  "assertion": "assertTrue ( scriptAledIn ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( scriptAledIn ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_29.txt",
  "assertion": "assertTrue ( terminalClided ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( terminalClided ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_3.txt",
  "assertion": "assertTrue (processFinDone ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue (processFinDone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_4.txt",
  "assertion": "assertTrue ( processesExailed ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( processesExailed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_5.txt",
  "assertion": "assertTrue ( processingEired ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( processingEired ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_6.txt",
  "assertion": "assertTrue ( checkWorkED ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( checkWorkED ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_7.txt",
  "assertion": "assertTrue ( hasProcess ended ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( hasProcess ended ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "45_8.txt",
  "assertion": "assertTrue ( programFopped ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( programFopped ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "45_9.txt",
  "assertion": "assertTrue ( did endedined ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertTrue ( did endedined ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertTrue ( processEnded ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_0.txt",
  "assertion": "assertEquals ( 0, vator. getEventsSize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, vator. getEventsSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_1.txt",
  "assertion": "assertEquals ( 1, validh.getEvent size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, validh.getEvent size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_10.txt",
  "assertion": "assertEquals ( length, valcontext. gettingRulesCause ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( length, valcontext. gettingRulesCause ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_11.txt",
  "assertion": "assertEquals ( 100, 1Exception. unServicesLen ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, 1Exception. unServicesLen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_12.txt",
  "assertion": "assertEquals ( 5, V ]. hasChangesNumber ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, V ]. hasChangesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_13.txt",
  "assertion": "assertEquals (1, eventv. removeMessSet ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (1, eventv. removeMessSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_14.txt",
  "assertion": "assertEquals ( (, contexterror. eventsImagesTime ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( (, contexterror. eventsImagesTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_15.txt",
  "assertion": "assertEquals ( N, u1. validActiveBytes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, u1. validActiveBytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_16.txt",
  "assertion": "assertEquals ( size, ValidManager. checkActError ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, ValidManager. checkActError ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_17.txt",
  "assertion": "assertEquals ( 512, -Error. eItemsSent ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 512, -Error. eItemsSent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "46_18.txt",
  "assertion": "assertEquals ( 200, xrics. gotDaysCode ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, xrics. gotDaysCode ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_19.txt",
  "assertion": "assertEquals ( count, er. createEntes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, er. createEntes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_2.txt",
  "assertion": "assertEquals ( 3, 0 ). Get eventsCount ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, 0 ). Get eventsCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_20.txt",
  "assertion": "assertEquals ( Context, exflow. toMembersStorage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( Context, exflow. toMembersStorage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_21.txt",
  "assertion": "assertEquals (0, actualation. givenReportsException ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (0, actualation. givenReportsException ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_22.txt",
  "assertion": "assertEquals ( expected, resultEmpty. applyTicketsValue ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, resultEmpty. applyTicketsValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_23.txt",
  "assertion": "assertEquals ( 400, {or. invalidEStyle ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 400, {or. invalidEStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_24.txt",
  "assertion": "assertEquals ( result, viewerr. itemPagesArray ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( result, viewerr. itemPagesArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_25.txt",
  "assertion": "assertEquals ( PASS, ut context.GetIssIndex ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( PASS, ut context.GetIssIndex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_26.txt",
  "assertion": "assertEquals ( 6, ovResponse. findReturnsNum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, ovResponse. findReturnsNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_27.txt",
  "assertion": "assertEquals ( 8, violationser. gDocumentsWeight ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, violationser. gDocumentsWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_28.txt",
  "assertion": "assertEquals ( 204, tFactory. appCountInfo ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 204, tFactory. appCountInfo ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_29.txt",
  "assertion": "assertEquals ( [, falsen. exportAnCounter ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( [, falsen. exportAnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_3.txt",
  "assertion": "assertEquals ( \"\", validationf. getseventsLength ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", validationf. getseventsLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_4.txt",
  "assertion": "assertEquals ( 4, responseH. currentAttemptsize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4, responseH. currentAttemptsize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_5.txt",
  "assertion": "assertEquals ( 2, invalidg. event Events Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, invalidg. event Events Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_6.txt",
  "assertion": "assertEquals ( context, nulli. newResultsEmpty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( context, nulli. newResultsEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_7.txt",
  "assertion": "assertEquals ( false, oeh. validateErMessage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( false, oeh. validateErMessage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "46_8.txt",
  "assertion": "assertEquals ( true, [Handler. addValuessize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( true, [Handler. addValuessize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "46_9.txt",
  "assertion": "assertEquals ( null, (Context. isEvizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, (Context. isEvizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_0.txt",
  "assertion": "assertEquals ( 0, vator. getEventsSize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, vator. getEventsSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_1.txt",
  "assertion": "assertEquals ( 1, validh.getEvent size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, validh.getEvent size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_10.txt",
  "assertion": "assertEquals ( length, valcontext. gettingRulesCause ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( length, valcontext. gettingRulesCause ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_11.txt",
  "assertion": "assertEquals ( 100, 1Exception. unServicesLen ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, 1Exception. unServicesLen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_12.txt",
  "assertion": "assertEquals ( 5, V ]. hasChangesNumber ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, V ]. hasChangesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_13.txt",
  "assertion": "assertEquals (1, eventv. removeMessSet ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (1, eventv. removeMessSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_14.txt",
  "assertion": "assertEquals ( (, contexterror. eventsImagesTime ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( (, contexterror. eventsImagesTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_15.txt",
  "assertion": "assertEquals ( N, u1. validActiveBytes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, u1. validActiveBytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_16.txt",
  "assertion": "assertEquals ( size, ValidManager. checkActError ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, ValidManager. checkActError ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_17.txt",
  "assertion": "assertEquals ( 512, -Error. eItemsSent ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 512, -Error. eItemsSent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "47_18.txt",
  "assertion": "assertEquals ( 200, xrics. gotDaysCode ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, xrics. gotDaysCode ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_19.txt",
  "assertion": "assertEquals ( count, er. createEntes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, er. createEntes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_2.txt",
  "assertion": "assertEquals ( 3, 0 ). Get eventsCount ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, 0 ). Get eventsCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_20.txt",
  "assertion": "assertEquals ( Context, exflow. toMembersStorage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( Context, exflow. toMembersStorage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_21.txt",
  "assertion": "assertEquals (0, actualation. givenReportsException ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (0, actualation. givenReportsException ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_22.txt",
  "assertion": "assertEquals ( expected, resultEmpty. applyTicketsValue ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, resultEmpty. applyTicketsValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_23.txt",
  "assertion": "assertEquals ( 400, {or. invalidEStyle ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 400, {or. invalidEStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_24.txt",
  "assertion": "assertEquals ( result, viewerr. itemPagesArray ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( result, viewerr. itemPagesArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_25.txt",
  "assertion": "assertEquals ( PASS, ut context.GetIssIndex ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( PASS, ut context.GetIssIndex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_26.txt",
  "assertion": "assertEquals ( 6, ovResponse. findReturnsNum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, ovResponse. findReturnsNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_27.txt",
  "assertion": "assertEquals ( 8, violationser. gDocumentsWeight ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, violationser. gDocumentsWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_28.txt",
  "assertion": "assertEquals ( 204, tFactory. appCountInfo ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 204, tFactory. appCountInfo ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_29.txt",
  "assertion": "assertEquals ( [, falsen. exportAnCounter ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( [, falsen. exportAnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_3.txt",
  "assertion": "assertEquals ( \"\", validationf. getseventsLength ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", validationf. getseventsLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_4.txt",
  "assertion": "assertEquals ( 4, responseH. currentAttemptsize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4, responseH. currentAttemptsize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_5.txt",
  "assertion": "assertEquals ( 2, invalidg. event Events Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, invalidg. event Events Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_6.txt",
  "assertion": "assertEquals ( context, nulli. newResultsEmpty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( context, nulli. newResultsEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_7.txt",
  "assertion": "assertEquals ( false, oeh. validateErMessage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( false, oeh. validateErMessage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "47_8.txt",
  "assertion": "assertEquals ( true, [Handler. addValuessize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( true, [Handler. addValuessize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "47_9.txt",
  "assertion": "assertEquals ( null, (Context. isEvizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, (Context. isEvizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 1, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_0.txt",
  "assertion": "assertEquals ( 0, vator. getEventsSize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, vator. getEventsSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_1.txt",
  "assertion": "assertEquals ( 1, validh.getEvent size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, validh.getEvent size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_10.txt",
  "assertion": "assertEquals ( length, valcontext. gettingRulesCause ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( length, valcontext. gettingRulesCause ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_11.txt",
  "assertion": "assertEquals ( 100, 1Exception. unServicesLen ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, 1Exception. unServicesLen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_12.txt",
  "assertion": "assertEquals ( 5, V ]. hasChangesNumber ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, V ]. hasChangesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_13.txt",
  "assertion": "assertEquals (1, eventv. removeMessSet ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (1, eventv. removeMessSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_14.txt",
  "assertion": "assertEquals ( (, contexterror. eventsImagesTime ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( (, contexterror. eventsImagesTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_15.txt",
  "assertion": "assertEquals ( N, u1. validActiveBytes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, u1. validActiveBytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_16.txt",
  "assertion": "assertEquals ( size, ValidManager. checkActError ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, ValidManager. checkActError ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_17.txt",
  "assertion": "assertEquals ( 512, -Error. eItemsSent ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 512, -Error. eItemsSent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "48_18.txt",
  "assertion": "assertEquals ( 200, xrics. gotDaysCode ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, xrics. gotDaysCode ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_19.txt",
  "assertion": "assertEquals ( count, er. createEntes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, er. createEntes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_2.txt",
  "assertion": "assertEquals ( 3, 0 ). Get eventsCount ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, 0 ). Get eventsCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_20.txt",
  "assertion": "assertEquals ( Context, exflow. toMembersStorage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( Context, exflow. toMembersStorage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_21.txt",
  "assertion": "assertEquals (0, actualation. givenReportsException ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (0, actualation. givenReportsException ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_22.txt",
  "assertion": "assertEquals ( expected, resultEmpty. applyTicketsValue ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, resultEmpty. applyTicketsValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_23.txt",
  "assertion": "assertEquals ( 400, {or. invalidEStyle ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 400, {or. invalidEStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_24.txt",
  "assertion": "assertEquals ( result, viewerr. itemPagesArray ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( result, viewerr. itemPagesArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_25.txt",
  "assertion": "assertEquals ( PASS, ut context.GetIssIndex ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( PASS, ut context.GetIssIndex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_26.txt",
  "assertion": "assertEquals ( 6, ovResponse. findReturnsNum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, ovResponse. findReturnsNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_27.txt",
  "assertion": "assertEquals ( 8, violationser. gDocumentsWeight ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, violationser. gDocumentsWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_28.txt",
  "assertion": "assertEquals ( 204, tFactory. appCountInfo ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 204, tFactory. appCountInfo ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_29.txt",
  "assertion": "assertEquals ( [, falsen. exportAnCounter ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( [, falsen. exportAnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_3.txt",
  "assertion": "assertEquals ( \"\", validationf. getseventsLength ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", validationf. getseventsLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_4.txt",
  "assertion": "assertEquals ( 4, responseH. currentAttemptsize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4, responseH. currentAttemptsize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_5.txt",
  "assertion": "assertEquals ( 2, invalidg. event Events Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, invalidg. event Events Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_6.txt",
  "assertion": "assertEquals ( context, nulli. newResultsEmpty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( context, nulli. newResultsEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_7.txt",
  "assertion": "assertEquals ( false, oeh. validateErMessage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( false, oeh. validateErMessage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "48_8.txt",
  "assertion": "assertEquals ( true, [Handler. addValuessize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( true, [Handler. addValuessize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "48_9.txt",
  "assertion": "assertEquals ( null, (Context. isEvizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, (Context. isEvizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 10, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_0.txt",
  "assertion": "assertEquals ( 0, vator. getEventsSize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, vator. getEventsSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_1.txt",
  "assertion": "assertEquals ( 1, validh.getEvent size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1, validh.getEvent size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_10.txt",
  "assertion": "assertEquals ( length, valcontext. gettingRulesCause ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( length, valcontext. gettingRulesCause ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_11.txt",
  "assertion": "assertEquals ( 100, 1Exception. unServicesLen ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 100, 1Exception. unServicesLen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_12.txt",
  "assertion": "assertEquals ( 5, V ]. hasChangesNumber ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 5, V ]. hasChangesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_13.txt",
  "assertion": "assertEquals (1, eventv. removeMessSet ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (1, eventv. removeMessSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_14.txt",
  "assertion": "assertEquals ( (, contexterror. eventsImagesTime ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( (, contexterror. eventsImagesTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_15.txt",
  "assertion": "assertEquals ( N, u1. validActiveBytes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( N, u1. validActiveBytes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_16.txt",
  "assertion": "assertEquals ( size, ValidManager. checkActError ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( size, ValidManager. checkActError ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_17.txt",
  "assertion": "assertEquals ( 512, -Error. eItemsSent ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 512, -Error. eItemsSent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "49_18.txt",
  "assertion": "assertEquals ( 200, xrics. gotDaysCode ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 200, xrics. gotDaysCode ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_19.txt",
  "assertion": "assertEquals ( count, er. createEntes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( count, er. createEntes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_2.txt",
  "assertion": "assertEquals ( 3, 0 ). Get eventsCount ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3, 0 ). Get eventsCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_20.txt",
  "assertion": "assertEquals ( Context, exflow. toMembersStorage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( Context, exflow. toMembersStorage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_21.txt",
  "assertion": "assertEquals (0, actualation. givenReportsException ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (0, actualation. givenReportsException ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_22.txt",
  "assertion": "assertEquals ( expected, resultEmpty. applyTicketsValue ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, resultEmpty. applyTicketsValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_23.txt",
  "assertion": "assertEquals ( 400, {or. invalidEStyle ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 400, {or. invalidEStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_24.txt",
  "assertion": "assertEquals ( result, viewerr. itemPagesArray ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( result, viewerr. itemPagesArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_25.txt",
  "assertion": "assertEquals ( PASS, ut context.GetIssIndex ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( PASS, ut context.GetIssIndex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_26.txt",
  "assertion": "assertEquals ( 6, ovResponse. findReturnsNum ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 6, ovResponse. findReturnsNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_27.txt",
  "assertion": "assertEquals ( 8, violationser. gDocumentsWeight ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8, violationser. gDocumentsWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_28.txt",
  "assertion": "assertEquals ( 204, tFactory. appCountInfo ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 204, tFactory. appCountInfo ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_29.txt",
  "assertion": "assertEquals ( [, falsen. exportAnCounter ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( [, falsen. exportAnCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_3.txt",
  "assertion": "assertEquals ( \"\", validationf. getseventsLength ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( \"\", validationf. getseventsLength ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_4.txt",
  "assertion": "assertEquals ( 4, responseH. currentAttemptsize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 4, responseH. currentAttemptsize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_5.txt",
  "assertion": "assertEquals ( 2, invalidg. event Events Size ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2, invalidg. event Events Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_6.txt",
  "assertion": "assertEquals ( context, nulli. newResultsEmpty ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( context, nulli. newResultsEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_7.txt",
  "assertion": "assertEquals ( false, oeh. validateErMessage ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( false, oeh. validateErMessage ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "49_8.txt",
  "assertion": "assertEquals ( true, [Handler. addValuessize ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( true, [Handler. addValuessize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "49_9.txt",
  "assertion": "assertEquals ( null, (Context. isEvizes ( ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( null, (Context. isEvizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, vh. getEventsSize ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_0.txt",
  "assertion": "assertEquals ( 0, users. size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, users. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_1.txt",
  "assertion": "assertEquals ( \"\", Users. empty ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \"\", Users. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_10.txt",
  "assertion": "assertEquals ( null, devices. Size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( null, devices. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_11.txt",
  "assertion": "assertEquals (0, keys. 0 ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (0, keys. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_12.txt",
  "assertion": "assertEquals ( 10, people. none ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10, people. none ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_13.txt",
  "assertion": "assertEquals ( 100, values. body ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 100, values. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_14.txt",
  "assertion": "assertEquals ( 200, profiles. clear ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 200, profiles. clear ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_15.txt",
  "assertion": "assertEquals ( length, items. sizes ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( length, items. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_16.txt",
  "assertion": "assertEquals ( 16, u. map ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 16, u. map ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_17.txt",
  "assertion": "assertEquals ( 8, consumers.List ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, consumers.List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_18.txt",
  "assertion": "assertEquals ( size, accounts.size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( size, accounts.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_19.txt",
  "assertion": "assertEquals ( 6, null. entries ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 6, null. entries ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_2.txt",
  "assertion": "assertEquals ( 3, 0. values ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, 0. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_20.txt",
  "assertion": "assertEquals ( 7, empty. array ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, empty. array ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_21.txt",
  "assertion": "assertEquals ( \u0027\u0027, us. sort ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \u0027\u0027, us. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "4_22.txt",
  "assertion": "assertEquals ( false, followers. index ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( false, followers. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_23.txt",
  "assertion": "assertEquals ( N, it. iterator ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( N, it. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_24.txt",
  "assertion": "assertEquals ( zero, roles. clone ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( zero, roles. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_25.txt",
  "assertion": "assertEquals ( 50, clients. of ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 50, clients. of ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_26.txt",
  "assertion": "assertEquals ( EMP, authors. zero ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( EMP, authors. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_27.txt",
  "assertion": "assertEquals ( 12, ones. content ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 12, ones. content ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_28.txt",
  "assertion": "assertEquals ( 15, names. List ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 15, names. List ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_29.txt",
  "assertion": "assertEquals ( 11, sessions. stream ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 11, sessions. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_3.txt",
  "assertion": "assertEquals ( 1, user. list ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, user. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_4.txt",
  "assertion": "assertEquals ( 4, Collections. count ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, Collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_5.txt",
  "assertion": "assertEquals ( empty,Users. EMP ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( empty,Users. EMP ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_6.txt",
  "assertion": "assertEquals ( 2, members. length ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, members. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_7.txt",
  "assertion": "assertEquals ( 20, messages.Size ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 20, messages.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_8.txt",
  "assertion": "assertEquals ( 5, list.Empty ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5, list.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "4_9.txt",
  "assertion": "assertEquals ( 204,users. filter ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 204,users. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, users. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "50_0.txt",
  "assertion": "assertEquals ( expected, actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "50_1.txt",
  "assertion": "assertEquals ( actual, expected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( actual, expected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "true",
  "result": ""
}
,
{
  "file": "50_10.txt",
  "assertion": "assertEquals ( received, actually )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( received, actually ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_11.txt",
  "assertion": "assertEquals ( original, resulting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( original, resulting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_12.txt",
  "assertion": "assertEquals ( formatted, response )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( formatted, response ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_13.txt",
  "assertion": "assertEquals ( value, real )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( value, real ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_14.txt",
  "assertion": "assertEquals ( written, Actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( written, Actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_15.txt",
  "assertion": "assertEquals ( anticipated, \" )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( anticipated, \" ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "50_16.txt",
  "assertion": "assertEquals ( returned, expect )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( returned, expect ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_17.txt",
  "assertion": "assertEquals ( read, updated )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( read, updated ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_18.txt",
  "assertion": "assertEquals ( supposed, existing )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( supposed, existing ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_19.txt",
  "assertion": "assertEquals ( observed, unexpected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( observed, unexpected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_2.txt",
  "assertion": "assertEquals ( expecting, expecting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expecting, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_20.txt",
  "assertion": "assertEquals ( updated, intended )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( updated, intended ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_21.txt",
  "assertion": "assertEquals ( given, correct )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( given, correct ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_22.txt",
  "assertion": "assertEquals ( found, valid )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( found, valid ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_23.txt",
  "assertion": "assertEquals ( planned, initial )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( planned, initial ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_24.txt",
  "assertion": "assertEquals ( computed, payload )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( computed, payload ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_25.txt",
  "assertion": "assertEquals ( expects, met )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expects, met ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_26.txt",
  "assertion": "assertEquals ( presumed, fake )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( presumed, fake ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_27.txt",
  "assertion": "assertEquals ( fake, given )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( fake, given ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_28.txt",
  "assertion": "assertEquals ( 0, null )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, null ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_29.txt",
  "assertion": "assertEquals ( ret, \"\" )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( ret, \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_3.txt",
  "assertion": "assertEquals ( expect, received )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expect, received ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_4.txt",
  "assertion": "assertEquals ( result, result )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( result, result ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_5.txt",
  "assertion": "assertEquals (pected, value )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (pected, value ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_6.txt",
  "assertion": "assertEquals (expected, original )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (expected, original ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "50_7.txt",
  "assertion": "assertEquals ( unexpected,actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( unexpected,actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_8.txt",
  "assertion": "assertEquals ( expectation, current )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expectation, current ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "50_9.txt",
  "assertion": "assertEquals ( intended, formatted )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( intended, formatted ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_0.txt",
  "assertion": "assertNull ( actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_1.txt",
  "assertion": "assertNull ( expected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( expected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "51_10.txt",
  "assertion": "assertNull ( Actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( Actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_11.txt",
  "assertion": "assertNull ( current )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( current ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_12.txt",
  "assertion": "assertNull ( resulting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( resulting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_13.txt",
  "assertion": "assertNull ( unexpected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( unexpected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_14.txt",
  "assertion": "assertNull ( existing )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( existing ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_15.txt",
  "assertion": "assertNull ( fake )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( fake ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_16.txt",
  "assertion": "assertNull ( valid )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( valid ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_17.txt",
  "assertion": "assertNull ( response )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( response ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_18.txt",
  "assertion": "assertNull ( ret )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_19.txt",
  "assertion": "assertNull ( initial )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( initial ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_2.txt",
  "assertion": "assertNull ( expecting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_20.txt",
  "assertion": "assertNull ( target )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( target ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_21.txt",
  "assertion": "assertNull ( true )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_22.txt",
  "assertion": "assertNull ( correct )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( correct ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_23.txt",
  "assertion": "assertNull ( expect )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( expect ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_24.txt",
  "assertion": "assertNull ( intended )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( intended ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_25.txt",
  "assertion": "assertNull ( updated )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( updated ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_26.txt",
  "assertion": "assertNull (ual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull (ual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_27.txt",
  "assertion": "assertNull ( actor )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( actor ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_28.txt",
  "assertion": "assertNull ( thrown )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( thrown ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_29.txt",
  "assertion": "assertNull ( operation )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( operation ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_3.txt",
  "assertion": "assertNull ( actually )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( actually ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_4.txt",
  "assertion": "assertNull ( value )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_5.txt",
  "assertion": "assertNull (actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull (actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_6.txt",
  "assertion": "assertNull ( result )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_7.txt",
  "assertion": "assertNull ( received )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( received ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_8.txt",
  "assertion": "assertNull ( original )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( original ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "51_9.txt",
  "assertion": "assertNull ( real )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( real ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_0.txt",
  "assertion": "assertEquals ( expected, actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expected, actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "52_1.txt",
  "assertion": "assertEquals ( actual, expected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( actual, expected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "52_10.txt",
  "assertion": "assertEquals ( received, actually )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( received, actually ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_11.txt",
  "assertion": "assertEquals ( original, resulting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( original, resulting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_12.txt",
  "assertion": "assertEquals ( formatted, response )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( formatted, response ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_13.txt",
  "assertion": "assertEquals ( value, real )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( value, real ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_14.txt",
  "assertion": "assertEquals ( written, Actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( written, Actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_15.txt",
  "assertion": "assertEquals ( anticipated, \" )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( anticipated, \" ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "52_16.txt",
  "assertion": "assertEquals ( returned, expect )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( returned, expect ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_17.txt",
  "assertion": "assertEquals ( read, updated )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( read, updated ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_18.txt",
  "assertion": "assertEquals ( supposed, existing )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( supposed, existing ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_19.txt",
  "assertion": "assertEquals ( observed, unexpected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( observed, unexpected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_2.txt",
  "assertion": "assertEquals ( expecting, expecting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expecting, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_20.txt",
  "assertion": "assertEquals ( updated, intended )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( updated, intended ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_21.txt",
  "assertion": "assertEquals ( given, correct )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( given, correct ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_22.txt",
  "assertion": "assertEquals ( found, valid )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( found, valid ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_23.txt",
  "assertion": "assertEquals ( planned, initial )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( planned, initial ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_24.txt",
  "assertion": "assertEquals ( computed, payload )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( computed, payload ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_25.txt",
  "assertion": "assertEquals ( expects, met )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expects, met ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_26.txt",
  "assertion": "assertEquals ( presumed, fake )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( presumed, fake ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_27.txt",
  "assertion": "assertEquals ( fake, given )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( fake, given ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_28.txt",
  "assertion": "assertEquals ( 0, null )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0, null ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_29.txt",
  "assertion": "assertEquals ( ret, \"\" )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( ret, \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_3.txt",
  "assertion": "assertEquals ( expect, received )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expect, received ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_4.txt",
  "assertion": "assertEquals ( result, result )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( result, result ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_5.txt",
  "assertion": "assertEquals (pected, value )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (pected, value ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_6.txt",
  "assertion": "assertEquals (expected, original )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (expected, original ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "52_7.txt",
  "assertion": "assertEquals ( unexpected,actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( unexpected,actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_8.txt",
  "assertion": "assertEquals ( expectation, current )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expectation, current ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "52_9.txt",
  "assertion": "assertEquals ( intended, formatted )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( intended, formatted ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_0.txt",
  "assertion": "assertNotNull ( actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_1.txt",
  "assertion": "assertNotNull ( expected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( expected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "53_10.txt",
  "assertion": "assertNotNull ( true )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_11.txt",
  "assertion": "assertNotNull ( ret )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_12.txt",
  "assertion": "assertNotNull ( real )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( real ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_13.txt",
  "assertion": "assertNotNull ( original )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( original ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_14.txt",
  "assertion": "assertNotNull ( valid )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( valid ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_15.txt",
  "assertion": "assertNotNull ( thrown )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( thrown ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_16.txt",
  "assertion": "assertNotNull ( actually )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( actually ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_17.txt",
  "assertion": "assertNotNull ( total )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( total ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_18.txt",
  "assertion": "assertNotNull ( updated )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( updated ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_19.txt",
  "assertion": "assertNotNull ( parsed )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( parsed ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_2.txt",
  "assertion": "assertNotNull ( value )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_20.txt",
  "assertion": "assertNotNull ( initial )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( initial ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_21.txt",
  "assertion": "assertNotNull ( target )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( target ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_22.txt",
  "assertion": "assertNotNull ( proper )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( proper ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_23.txt",
  "assertion": "assertNotNull ( expect )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( expect ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_24.txt",
  "assertion": "assertNotNull ( required )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( required ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_25.txt",
  "assertion": "assertNotNull ( object )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( object ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_26.txt",
  "assertion": "assertNotNull ( exact )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( exact ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_27.txt",
  "assertion": "assertNotNull ( associated )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( associated ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_28.txt",
  "assertion": "assertNotNull ( resulting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( resulting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_29.txt",
  "assertion": "assertNotNull ( found )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( found ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_3.txt",
  "assertion": "assertNotNull ( result )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_4.txt",
  "assertion": "assertNotNull ( expecting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_5.txt",
  "assertion": "assertNotNull ( current )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( current ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_6.txt",
  "assertion": "assertNotNull ( existing )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( existing ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_7.txt",
  "assertion": "assertNotNull ( correct )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( correct ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_8.txt",
  "assertion": "assertNotNull ( received )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( received ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "53_9.txt",
  "assertion": "assertNotNull ( null )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( null ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actual )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_0.txt",
  "assertion": "assertNull ( actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_1.txt",
  "assertion": "assertNull ( expected )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( expected ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "54_10.txt",
  "assertion": "assertNull ( actually )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( actually ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_11.txt",
  "assertion": "assertNull ( real )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( real ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_12.txt",
  "assertion": "assertNull ( true )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_13.txt",
  "assertion": "assertNull ( ret )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_14.txt",
  "assertion": "assertNull ( original )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( original ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_15.txt",
  "assertion": "assertNull ( valid )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( valid ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_16.txt",
  "assertion": "assertNull ( target )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( target ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_17.txt",
  "assertion": "assertNull ( thrown )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( thrown ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_18.txt",
  "assertion": "assertNull ( total )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( total ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_19.txt",
  "assertion": "assertNull ( initial )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( initial ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_2.txt",
  "assertion": "assertNull ( expecting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_20.txt",
  "assertion": "assertNull (actual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull (actual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_21.txt",
  "assertion": "assertNull ( associated )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( associated ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_22.txt",
  "assertion": "assertNull ( expect )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( expect ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_23.txt",
  "assertion": "assertNull (ual )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull (ual ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_24.txt",
  "assertion": "assertNull ( exact )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( exact ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_25.txt",
  "assertion": "assertNull ( required )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( required ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_26.txt",
  "assertion": "assertNull ( updated )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( updated ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_27.txt",
  "assertion": "assertNull ( proper )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( proper ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_28.txt",
  "assertion": "assertNull ( resulting )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( resulting ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_29.txt",
  "assertion": "assertNull ( object )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( object ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_3.txt",
  "assertion": "assertNull ( value )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_4.txt",
  "assertion": "assertNull ( current )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( current ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_5.txt",
  "assertion": "assertNull ( result )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_6.txt",
  "assertion": "assertNull ( received )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( received ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_7.txt",
  "assertion": "assertNull ( null )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( null ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_8.txt",
  "assertion": "assertNull ( existing )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( existing ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "54_9.txt",
  "assertion": "assertNull ( correct )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNull ( correct ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNull ( actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_0.txt",
  "assertion": "assertNotNull ( expectedScrollbarHeight )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( expectedScrollbarHeight ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_1.txt",
  "assertion": "assertNotNull ( actualscrollBarBar )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( actualscrollBarBar ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_10.txt",
  "assertion": "assertNotNull ( intendedRect BarHor )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( intendedRect BarHor ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_11.txt",
  "assertion": "assertNotNull ( targetRowabsY )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( targetRowabsY ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_12.txt",
  "assertion": "assertNotNull ( given,bitLength )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( given,bitLength ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_13.txt",
  "assertion": "assertNotNull ( receivedOffset.R )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( receivedOffset.R ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_14.txt",
  "assertion": "assertNotNull ( foundJust_Above )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( foundJust_Above ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_15.txt",
  "assertion": "assertNotNull ( properSizeabChart )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( properSizeabChart ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_16.txt",
  "assertion": "assertNotNull ( returnedClbrInfo )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( returnedClbrInfo ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_17.txt",
  "assertion": "assertNotNull ( currentSpeedborB )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( currentSpeedborB ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_18.txt",
  "assertion": "assertNotNull (expectedSattabElement )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull (expectedSattabElement ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_19.txt",
  "assertion": "assertNotNull ( requiredHorterItem )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( requiredHorterItem ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_2.txt",
  "assertion": "assertNotNull ( result scrollbarsheight )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( result scrollbarsheight ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_20.txt",
  "assertion": "assertNotNull ( expectsGbot ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( expectsGbot ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_21.txt",
  "assertion": "assertNotNull (pectedCto ] )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull (pectedCto ] ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_22.txt",
  "assertion": "assertNotNull ( anticipatedTabserSize )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( anticipatedTabserSize ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_23.txt",
  "assertion": "assertNotNull ( newCalswerView )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( newCalswerView ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_24.txt",
  "assertion": "assertNotNull ( assumedS *Animation )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( assumedS *Animation ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_25.txt",
  "assertion": "assertNotNull ( actuallyHeight \u003dBlock )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( actuallyHeight \u003dBlock ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_26.txt",
  "assertion": "assertNotNull ( ActualSyncserverShould )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( ActualSyncserverShould ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_27.txt",
  "assertion": "assertNotNull ( estimatedCtrlscrollAt )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( estimatedCtrlscrollAt ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_28.txt",
  "assertion": "assertNotNull ( updatedVertperDepth )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( updatedVertperDepth ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_29.txt",
  "assertion": "assertNotNull ( neededStch1 )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( neededStch1 ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_3.txt",
  "assertion": "assertNotNull ( expect Scroll, height )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( expect Scroll, height ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_4.txt",
  "assertion": "assertNotNull ( calculatedSc bar Height )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( calculatedSc bar Height ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "55_5.txt",
  "assertion": "assertNotNull ( expectingRbBottom )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( expectingRbBottom ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_6.txt",
  "assertion": "assertNotNull ( desiredControlibWidth )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( desiredControlibWidth ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_7.txt",
  "assertion": "assertNotNull ( computedScoreablebar )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( computedScoreablebar ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_8.txt",
  "assertion": "assertNotNull ( correctLayoutblH )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( correctLayoutblH ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "55_9.txt",
  "assertion": "assertNotNull ( retSanbaseTop )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertNotNull ( retSanbaseTop ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertNotNull ( actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_0.txt",
  "assertion": "assertEquals ( expectedScrollbarHeight, expectedScrollbarHeight )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expectedScrollbarHeight, expectedScrollbarHeight ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_1.txt",
  "assertion": "assertEquals ( expect scrollBarH, actual scrollbarsH )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expect scrollBarH, actual scrollbarsH ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_10.txt",
  "assertion": "assertEquals ( (Offset,Style,expectedOffsetbotTop )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( (Offset,Style,expectedOffsetbotTop ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_11.txt",
  "assertion": "assertEquals ( 2TabbotShould, foundTab,Should )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 2TabbotShould, foundTab,Should ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_12.txt",
  "assertion": "assertEquals ( correctScoreberLevel, returnedSideabsAbove )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( correctScoreberLevel, returnedSideabsAbove ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_13.txt",
  "assertion": "assertEquals ( expectsFlowtabTH, requiredScoreableD )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expectsFlowtabTH, requiredScoreableD ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_14.txt",
  "assertion": "assertEquals ( assumedTabsDepth, receivedSpeedbufferCount )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( assumedTabsDepth, receivedSpeedbufferCount ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_15.txt",
  "assertion": "assertEquals ( 0SideserverAbove, allowedTbeanR )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 0SideserverAbove, allowedTbeanR ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_16.txt",
  "assertion": "assertEquals ( 8Speed BarSize, readSatberTH )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 8Speed BarSize, readSatberTH ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_17.txt",
  "assertion": "assertEquals ( -AutopadD, givenVert BarDepth )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( -AutopadD, givenVert BarDepth ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_18.txt",
  "assertion": "assertEquals ( intendedSanbeanR, offsetHorpadSize )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( intendedSanbeanR, offsetHorpadSize ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_19.txt",
  "assertion": "assertEquals ( allowedL *Offset, resultAutotabVert )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( allowedL *Offset, resultAutotabVert ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_2.txt",
  "assertion": "assertEquals ( expectingscrollbarsWidth, expectscrollBarWidth )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( expectingscrollbarsWidth, expectscrollBarWidth ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_20.txt",
  "assertion": "assertEquals ( intHorbufferCount, newClientborSpeed )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( intHorbufferCount, newClientborSpeed ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_21.txt",
  "assertion": "assertEquals ( computedSatbrHE, assumedGbr ) )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( computedSatbrHE, assumedGbr ) ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_22.txt",
  "assertion": "assertEquals ( anticipatedRatborVert, unexpectedFlowchLevel )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( anticipatedRatborVert, unexpectedFlowchLevel ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_23.txt",
  "assertion": "assertEquals ( 1GoffsetBlock, suggestedRatserverOffset )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 1GoffsetBlock, suggestedRatserverOffset ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_24.txt",
  "assertion": "assertEquals ( returnedNavableVolume, acceptableJustbgHTML )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( returnedNavableVolume, acceptableJustbgHTML ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_25.txt",
  "assertion": "assertEquals ( unexpectedCgapTime, correctWidthbackBlock )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( unexpectedCgapTime, correctWidthbackBlock ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_26.txt",
  "assertion": "assertEquals ( inAttchHTML, requestedSan *Volume )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( inAttchHTML, requestedSan *Volume ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_27.txt",
  "assertion": "assertEquals ( 3VertsterBase, assignedLoffsetV )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( 3VertsterBase, assignedLoffsetV ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_28.txt",
  "assertion": "assertEquals ( givenSyncspan ), returnRowgarHE )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( givenSyncspan ), returnRowgarHE ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_29.txt",
  "assertion": "assertEquals ( foundClientperSpeed, (CansterView )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( foundClientperSpeed, (CansterView ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_3.txt",
  "assertion": "assertEquals (pected Scroll barheight, desired Scroll barheight )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (pected Scroll barheight, desired Scroll barheight ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_4.txt",
  "assertion": "assertEquals ( actualScb Height, expectingHeightbLength )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( actualScb Height, expectingHeightbLength ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_5.txt",
  "assertion": "assertEquals ( desiredRbaseLength, calculatedScbaseY )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( desiredRbaseLength, calculatedScbaseY ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_6.txt",
  "assertion": "assertEquals (expectedSizeibY, neededLayoutib Height )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals (expectedSizeibY, neededLayoutib Height ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_7.txt",
  "assertion": "assertEquals ( neededRectblBottom, clientRblStyle )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( neededRectblBottom, clientRblStyle ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "56_8.txt",
  "assertion": "assertEquals ( requiredLayoutabTop,pectedRectbit height )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( requiredLayoutabTop,pectedRectbit height ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "56_9.txt",
  "assertion": "assertEquals ( calculatedHeightbit height, computedSizeabBottom )\r\n",
  "test": "class X {public void testDependencies ( ) { Set \u003c Entity \u003e expected \u003d new HashSet \u003c Entity \u003e ( ) ; expected . add ( d_analysis . getStudy ( ) ) ; expected . addAll ( d_analysis . getCriteria ( ) ) ; expected . add ( d_analysis . getIndication ( ) ) ; expected . addAll ( d_analysis . getStudy ( ) . getDependencies ( ) ) ; assertEquals ( calculatedHeightbit height, computedSizeabBottom ) ; } }\r\n",
  "focal method": "class Y{ public void getDependencies ( ) { return d_activity . getDependencies ( ) ; } }\r\n",
  "truth": "assertEquals ( actualScrollbarHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_0.txt",
  "assertion": "assertEquals ( offsetHeight, expectedScrollbarHeight )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( offsetHeight, expectedScrollbarHeight ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_1.txt",
  "assertion": "assertEquals ( clientWidth, actual scrollBarH )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( clientWidth, actual scrollBarH ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_10.txt",
  "assertion": "assertEquals ( 100Y, returnedOffsetabsBottom )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 100Y, returnedOffsetabsBottom ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_11.txt",
  "assertion": "assertEquals ( computedH, requiredRblD )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( computedH, requiredRblD ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_12.txt",
  "assertion": "assertEquals ( 200Depth, computedRectbotR )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 200Depth, computedRectbotR ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_13.txt",
  "assertion": "assertEquals (offsetSize, resultWidthbeanAbove )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals (offsetSize, resultWidthbeanAbove ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_14.txt",
  "assertion": "assertEquals (clientScroll, readSat BarTop )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals (clientScroll, readSat BarTop ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_15.txt",
  "assertion": "assertEquals ( requested3, clientSidepadLevel )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( requested3, clientSidepadLevel ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_16.txt",
  "assertion": "assertEquals ( neededHTML, assumedTabtabVert )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( neededHTML, assumedTabtabVert ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_17.txt",
  "assertion": "assertEquals ( 12, orgControlableShould )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 12, orgControlableShould ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_18.txt",
  "assertion": "assertEquals ( totalLevel, allowedSanbrTH )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( totalLevel, allowedSanbrTH ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_19.txt",
  "assertion": "assertEquals ( actualAbove, expectsFlowberCount )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( actualAbove, expectsFlowberCount ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_2.txt",
  "assertion": "assertEquals ( expected Height, expectscrollbarsWidth )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( expected Height, expectscrollbarsWidth ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_20.txt",
  "assertion": "assertEquals ( offHeader, assignedHoroffsetSpeed )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( offHeader, assignedHoroffsetSpeed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_21.txt",
  "assertion": "assertEquals ( request7, givenRowbufferSize )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( request7, givenRowbufferSize ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_22.txt",
  "assertion": "assertEquals ( cursorLength, unexpectedClientserverHTML )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( cursorLength, unexpectedClientserverHTML ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_23.txt",
  "assertion": "assertEquals ( 80Row, ( scrollingchOffset )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 80Row, ( scrollingchOffset ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_24.txt",
  "assertion": "assertEquals (OffsetValue, intendedAutoborTime )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals (OffsetValue, intendedAutoborTime ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_25.txt",
  "assertion": "assertEquals ( -y, receivedAnimationbuttonSafety )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( -y, receivedAnimationbuttonSafety ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_26.txt",
  "assertion": "assertEquals ( autoIndex, correctRatspanBlock )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( autoIndex, correctRatspanBlock ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_27.txt",
  "assertion": "assertEquals ( baseNumber, guessedJustbackVolume )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( baseNumber, guessedJustbackVolume ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_28.txt",
  "assertion": "assertEquals ( leftBlock, reportedVertgapType )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( leftBlock, reportedVertgapType ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_29.txt",
  "assertion": "assertEquals ( desired5, newStylenbView )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( desired5, newStylenbView ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_3.txt",
  "assertion": "assertEquals ( scrollheight,pected Scroll barLength )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( scrollheight,pected Scroll barLength ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_4.txt",
  "assertion": "assertEquals ( ClientTop, desiredHeightbheight )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( ClientTop, desiredHeightbheight ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_5.txt",
  "assertion": "assertEquals ( 0 height, expectingSizebaseY )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 0 height, expectingSizebaseY ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_6.txt",
  "assertion": "assertEquals ( serverStyle, neededScbit Height )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( serverStyle, neededScbit Height ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_7.txt",
  "assertion": "assertEquals ( calculatedBottom, calculatedLayoutibStyle )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( calculatedBottom, calculatedLayoutibStyle ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "57_8.txt",
  "assertion": "assertEquals ( 20Offset,expectedScoreabDepth )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 20Offset,expectedScoreabDepth ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "57_9.txt",
  "assertion": "assertEquals ( 21, foundSpeed, height )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 21, foundSpeed, height ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( clientHeight, actualScrollbarHeight )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_0.txt",
  "assertion": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 1, wrapper. getGenre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_1.txt",
  "assertion": "assertEquals ( 0, this. GetgenRE ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 0, this. GetgenRE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_10.txt",
  "assertion": "assertEquals ( expected, wrapping. _Codrec ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( expected, wrapping. _Codrec ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_11.txt",
  "assertion": "assertEquals ( 5, Tag. m GENrep ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 5, Tag. m GENrep ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_12.txt",
  "assertion": "assertEquals ( 11, result. geRegRe ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 11, result. geRegRe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_13.txt",
  "assertion": "assertEquals ( 7,wrapper. groupCentret ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 7,wrapper. groupCentret ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_14.txt",
  "assertion": "assertEquals ( 6, 0. iAgrex ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 6, 0. iAgrex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_15.txt",
  "assertion": "assertEquals ( 16, Wrap. genericValary ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 16, Wrap. genericValary ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_16.txt",
  "assertion": "assertEquals ( result, unsafe. unAggreg ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( result, unsafe. unAggreg ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_17.txt",
  "assertion": "assertEquals ( 20, registry. eEnive ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 20, registry. eEnive ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_18.txt",
  "assertion": "assertEquals ( 100, container. extractLenree ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 100, container. extractLenree ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_19.txt",
  "assertion": "assertEquals ( 10000, 1. idOrigreen ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 10000, 1. idOrigreen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_2.txt",
  "assertion": "assertEquals ( \"\", wrapped. gGENere ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( \"\", wrapped. gGENere ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_20.txt",
  "assertion": "assertEquals ( random, input. gettingLegren ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( random, input. gettingLegren ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_21.txt",
  "assertion": "assertEquals ( 30, primitive. __Ver re ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 30, primitive. __Ver re ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_22.txt",
  "assertion": "assertEquals ( 15, wire. gotSetber ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 15, wire. gotSetber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_23.txt",
  "assertion": "assertEquals ( false, bag. tagNumone ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( false, bag. tagNumone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_24.txt",
  "assertion": "assertEquals ( ONE, item. newRetal ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( ONE, item. newRetal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_25.txt",
  "assertion": "assertEquals ( 999, signature. charRefe ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 999, signature. charRefe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_26.txt",
  "assertion": "assertEquals ( 255, element. genPatale ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 255, element. genPatale ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_27.txt",
  "assertion": "assertEquals ( 12, converter. vConr ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 12, converter. vConr ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_28.txt",
  "assertion": "assertEquals ( returned, base. givenAngpre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( returned, base. givenAngpre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_29.txt",
  "assertion": "assertEquals ( Integer, value. removeLibede ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( Integer, value. removeLibede ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_3.txt",
  "assertion": "assertEquals ( 2, tag.getGenerres ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 2, tag.getGenerres ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_4.txt",
  "assertion": "assertEquals ( 3, null. getsGbre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 3, null. getsGbre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_5.txt",
  "assertion": "assertEquals ( 10, \"\". generate Gengre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 10, \"\". generate Gengre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_6.txt",
  "assertion": "assertEquals ( 4, wrap. find genire ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 4, wrap. find genire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "58_7.txt",
  "assertion": "assertEquals ( null, super. GSenome ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( null, super. GSenome ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_8.txt",
  "assertion": "assertEquals ( 9, holder. memeGenerev ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 9, holder. memeGenerev ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "58_9.txt",
  "assertion": "assertEquals ( 8, factory. toIdcre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 8, factory. toIdcre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 4, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_0.txt",
  "assertion": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 1, wrapper. getGenre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_1.txt",
  "assertion": "assertEquals ( 0, this. GetgenRE ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 0, this. GetgenRE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_10.txt",
  "assertion": "assertEquals ( expected, wrapping. _Codrec ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( expected, wrapping. _Codrec ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_11.txt",
  "assertion": "assertEquals ( 5, Tag. m GENrep ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 5, Tag. m GENrep ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "59_12.txt",
  "assertion": "assertEquals ( 11, result. geRegRe ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 11, result. geRegRe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_13.txt",
  "assertion": "assertEquals ( 7,wrapper. groupCentret ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 7,wrapper. groupCentret ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_14.txt",
  "assertion": "assertEquals ( 6, 0. iAgrex ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 6, 0. iAgrex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "59_15.txt",
  "assertion": "assertEquals ( 16, Wrap. genericValary ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 16, Wrap. genericValary ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_16.txt",
  "assertion": "assertEquals ( result, unsafe. unAggreg ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( result, unsafe. unAggreg ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_17.txt",
  "assertion": "assertEquals ( 20, registry. eEnive ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 20, registry. eEnive ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_18.txt",
  "assertion": "assertEquals ( 100, container. extractLenree ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 100, container. extractLenree ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_19.txt",
  "assertion": "assertEquals ( 10000, 1. idOrigreen ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 10000, 1. idOrigreen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "59_2.txt",
  "assertion": "assertEquals ( \"\", wrapped. gGENere ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( \"\", wrapped. gGENere ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_20.txt",
  "assertion": "assertEquals ( random, input. gettingLegren ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( random, input. gettingLegren ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_21.txt",
  "assertion": "assertEquals ( 30, primitive. __Ver re ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 30, primitive. __Ver re ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "59_22.txt",
  "assertion": "assertEquals ( 15, wire. gotSetber ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 15, wire. gotSetber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_23.txt",
  "assertion": "assertEquals ( false, bag. tagNumone ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( false, bag. tagNumone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_24.txt",
  "assertion": "assertEquals ( ONE, item. newRetal ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( ONE, item. newRetal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_25.txt",
  "assertion": "assertEquals ( 999, signature. charRefe ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 999, signature. charRefe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_26.txt",
  "assertion": "assertEquals ( 255, element. genPatale ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 255, element. genPatale ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_27.txt",
  "assertion": "assertEquals ( 12, converter. vConr ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 12, converter. vConr ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_28.txt",
  "assertion": "assertEquals ( returned, base. givenAngpre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( returned, base. givenAngpre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_29.txt",
  "assertion": "assertEquals ( Integer, value. removeLibede ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( Integer, value. removeLibede ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_3.txt",
  "assertion": "assertEquals ( 2, tag.getGenerres ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 2, tag.getGenerres ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_4.txt",
  "assertion": "assertEquals ( 3, null. getsGbre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 3, null. getsGbre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_5.txt",
  "assertion": "assertEquals ( 10, \"\". generate Gengre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 10, \"\". generate Gengre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "59_6.txt",
  "assertion": "assertEquals ( 4, wrap. find genire ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 4, wrap. find genire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "59_7.txt",
  "assertion": "assertEquals ( null, super. GSenome ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( null, super. GSenome ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_8.txt",
  "assertion": "assertEquals ( 9, holder. memeGenerev ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 9, holder. memeGenerev ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "59_9.txt",
  "assertion": "assertEquals ( 8, factory. toIdcre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 8, factory. toIdcre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 2, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_0.txt",
  "assertion": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, timer. getWaitTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_1.txt",
  "assertion": "assertEquals ( 1, 0. Get wait time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, 0. Get wait time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "5_10.txt",
  "assertion": "assertEquals ( 20, os. minQueueTim ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 20, os. minQueueTim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_11.txt",
  "assertion": "assertEquals ( 200, 2. gettingHolder ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 200, 2. gettingHolder ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "5_12.txt",
  "assertion": "assertEquals ( 8, timeout. gSleepMemory ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, timeout. gSleepMemory ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_13.txt",
  "assertion": "assertEquals ( i, 1. availableAcceptNow ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( i, 1. availableAcceptNow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "5_14.txt",
  "assertion": "assertEquals ( time, system. totalUtCount ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( time, system. totalUtCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_15.txt",
  "assertion": "assertEquals ( min, alarm. groupaitTimeout ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( min, alarm. groupaitTimeout ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_16.txt",
  "assertion": "assertEquals ( None, EM. sizeDurationClock ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( None, EM. sizeDurationClock ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_17.txt",
  "assertion": "assertEquals ( 50, settings. countBufferFire ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 50, settings. countBufferFire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_18.txt",
  "assertion": "assertEquals ( 6, counter. newMustWeight ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 6, counter. newMustWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_19.txt",
  "assertion": "assertEquals ( 30, times. eventMaxMill ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 30, times. eventMaxMill ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_2.txt",
  "assertion": "assertEquals ( 2, System.get Waittime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, System.get Waittime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "5_20.txt",
  "assertion": "assertEquals ( \"\", runtime. _TimeT ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \"\", runtime. _TimeT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_21.txt",
  "assertion": "assertEquals ( 10000, self. calculateJoinWork ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10000, self. calculateJoinWork ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_22.txt",
  "assertion": "assertEquals ( 7, sys. incrementQFit ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, sys. incrementQFit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_23.txt",
  "assertion": "assertEquals ( 15, countdown. numberAllowed ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 15, countdown. numberAllowed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_24.txt",
  "assertion": "assertEquals ( timer, event. pollDel times ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( timer, event. pollDel times ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "5_25.txt",
  "assertion": "assertEquals ( 5000, duration. timerDateNice ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5000, duration. timerDateNice ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_26.txt",
  "assertion": "assertEquals ( 60, Time. timeoutDefaultVal ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 60, Time. timeoutDefaultVal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_27.txt",
  "assertion": "assertEquals ( zero, util. defaultGetLong ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( zero, util. defaultGetLong ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_28.txt",
  "assertion": "assertEquals ( 500, global. guessRequestStyle ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 500, global. guessRequestStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_29.txt",
  "assertion": "assertEquals (0, C. randomStatusSound ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (0, C. randomStatusSound ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_3.txt",
  "assertion": "assertEquals ( 3, this. currentWa Time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, this. currentWa Time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "5_4.txt",
  "assertion": "assertEquals ( 1000, time. getsSendTimer ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1000, time. getsSendTimer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_5.txt",
  "assertion": "assertEquals ( 4, timers. timewaitThread ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, timers. timewaitThread ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_6.txt",
  "assertion": "assertEquals ( 10, Clock. givenDaTimes ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10, Clock. givenDaTimes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_7.txt",
  "assertion": "assertEquals ( 5, clock. maxEventime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5, clock. maxEventime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_8.txt",
  "assertion": "assertEquals ( 100, timing. gotTotalValue ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 100, timing. gotTotalValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "5_9.txt",
  "assertion": "assertEquals ( 2000, timed. globalListenSize ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2000, timed. globalListenSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_0.txt",
  "assertion": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 1, wrapper. getGenre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_1.txt",
  "assertion": "assertEquals ( 0, this. GetgenRE ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 0, this. GetgenRE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_10.txt",
  "assertion": "assertEquals ( expected, wrapping. _Codrec ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( expected, wrapping. _Codrec ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_11.txt",
  "assertion": "assertEquals ( 5, Tag. m GENrep ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 5, Tag. m GENrep ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_12.txt",
  "assertion": "assertEquals ( 11, result. geRegRe ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 11, result. geRegRe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_13.txt",
  "assertion": "assertEquals ( 7,wrapper. groupCentret ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 7,wrapper. groupCentret ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_14.txt",
  "assertion": "assertEquals ( 6, 0. iAgrex ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 6, 0. iAgrex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_15.txt",
  "assertion": "assertEquals ( 16, Wrap. genericValary ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 16, Wrap. genericValary ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_16.txt",
  "assertion": "assertEquals ( result, unsafe. unAggreg ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( result, unsafe. unAggreg ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_17.txt",
  "assertion": "assertEquals ( 20, registry. eEnive ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 20, registry. eEnive ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_18.txt",
  "assertion": "assertEquals ( 100, container. extractLenree ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 100, container. extractLenree ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_19.txt",
  "assertion": "assertEquals ( 10000, 1. idOrigreen ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 10000, 1. idOrigreen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_2.txt",
  "assertion": "assertEquals ( \"\", wrapped. gGENere ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( \"\", wrapped. gGENere ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_20.txt",
  "assertion": "assertEquals ( random, input. gettingLegren ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( random, input. gettingLegren ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_21.txt",
  "assertion": "assertEquals ( 30, primitive. __Ver re ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 30, primitive. __Ver re ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_22.txt",
  "assertion": "assertEquals ( 15, wire. gotSetber ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 15, wire. gotSetber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_23.txt",
  "assertion": "assertEquals ( false, bag. tagNumone ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( false, bag. tagNumone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_24.txt",
  "assertion": "assertEquals ( ONE, item. newRetal ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( ONE, item. newRetal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_25.txt",
  "assertion": "assertEquals ( 999, signature. charRefe ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 999, signature. charRefe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_26.txt",
  "assertion": "assertEquals ( 255, element. genPatale ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 255, element. genPatale ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_27.txt",
  "assertion": "assertEquals ( 12, converter. vConr ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 12, converter. vConr ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_28.txt",
  "assertion": "assertEquals ( returned, base. givenAngpre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( returned, base. givenAngpre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_29.txt",
  "assertion": "assertEquals ( Integer, value. removeLibede ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( Integer, value. removeLibede ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_3.txt",
  "assertion": "assertEquals ( 2, tag.getGenerres ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 2, tag.getGenerres ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_4.txt",
  "assertion": "assertEquals ( 3, null. getsGbre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 3, null. getsGbre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_5.txt",
  "assertion": "assertEquals ( 10, \"\". generate Gengre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 10, \"\". generate Gengre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_6.txt",
  "assertion": "assertEquals ( 4, wrap. find genire ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 4, wrap. find genire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "60_7.txt",
  "assertion": "assertEquals ( null, super. GSenome ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( null, super. GSenome ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_8.txt",
  "assertion": "assertEquals ( 9, holder. memeGenerev ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 9, holder. memeGenerev ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "60_9.txt",
  "assertion": "assertEquals ( 8, factory. toIdcre ( ) )\r\n",
  "test": "class X {public void testJSDate ( ) { ScriptEngineManager factory \u003d new ScriptEngineManager ( ) ; ScriptEngine engine \u003d factory . getEngineByName ( \"nashorn\" ) ; Object obj \u003d engine . eval ( \"new\u003csp\u003eDate(2010,\u003csp\u003e1,\u003csp\u003e2);\" ) ; ScriptObjectMirror jsDate \u003d ( ( ScriptObjectMirror ) ( obj ) ) ; double timestampLocal \u003d ( ( double ) ( jsDate . callMember ( \"getTime\" ) ) ) ; Instant instant \u003d Converters . toDate ( timestampLocal ) ; String someDate \u003d \"2010-02-02\" ; DateParsing parsing \u003d new DateParsing ( someDate ) ; Instant expected \u003d parsing . parse ( someDate ) ; assertEquals ( 8, factory. toIdcre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( String var24678 ) { s \u003d Utilities . singleSpaced ( s ) ; Converters . checkNull ( ) ; if ( this . parseAsDate ) { return LocalDate . parse ( s ) . LocalDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . LocalDate . toInstant ( ) ; } else { return LocalDateTime . parse ( s ) . LocalDateTime . atZone ( ZoneId . systemDefault ( ) ) . LocalDateTime . toInstant ( ) ; } } }\r\n",
  "truth": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_0.txt",
  "assertion": "assertEquals ( 1, wrapper. getGenre ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 1, wrapper. getGenre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_1.txt",
  "assertion": "assertEquals ( 0, this. GetgenRE ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 0, this. GetgenRE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_10.txt",
  "assertion": "assertEquals ( expected, wrapping. _Codrec ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expected, wrapping. _Codrec ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_11.txt",
  "assertion": "assertEquals ( 5, Tag. m GENrep ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 5, Tag. m GENrep ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_12.txt",
  "assertion": "assertEquals ( 11, result. geRegRe ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 11, result. geRegRe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_13.txt",
  "assertion": "assertEquals ( 7,wrapper. groupCentret ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 7,wrapper. groupCentret ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_14.txt",
  "assertion": "assertEquals ( 6, 0. iAgrex ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 6, 0. iAgrex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_15.txt",
  "assertion": "assertEquals ( 16, Wrap. genericValary ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 16, Wrap. genericValary ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_16.txt",
  "assertion": "assertEquals ( result, unsafe. unAggreg ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( result, unsafe. unAggreg ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_17.txt",
  "assertion": "assertEquals ( 20, registry. eEnive ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 20, registry. eEnive ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_18.txt",
  "assertion": "assertEquals ( 100, container. extractLenree ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 100, container. extractLenree ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_19.txt",
  "assertion": "assertEquals ( 10000, 1. idOrigreen ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 10000, 1. idOrigreen ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_2.txt",
  "assertion": "assertEquals ( \"\", wrapped. gGENere ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( \"\", wrapped. gGENere ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_20.txt",
  "assertion": "assertEquals ( random, input. gettingLegren ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( random, input. gettingLegren ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_21.txt",
  "assertion": "assertEquals ( 30, primitive. __Ver re ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 30, primitive. __Ver re ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_22.txt",
  "assertion": "assertEquals ( 15, wire. gotSetber ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 15, wire. gotSetber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_23.txt",
  "assertion": "assertEquals ( false, bag. tagNumone ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( false, bag. tagNumone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_24.txt",
  "assertion": "assertEquals ( ONE, item. newRetal ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( ONE, item. newRetal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_25.txt",
  "assertion": "assertEquals ( 999, signature. charRefe ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 999, signature. charRefe ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_26.txt",
  "assertion": "assertEquals ( 255, element. genPatale ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 255, element. genPatale ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_27.txt",
  "assertion": "assertEquals ( 12, converter. vConr ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 12, converter. vConr ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_28.txt",
  "assertion": "assertEquals ( returned, base. givenAngpre ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( returned, base. givenAngpre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_29.txt",
  "assertion": "assertEquals ( Integer, value. removeLibede ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( Integer, value. removeLibede ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_3.txt",
  "assertion": "assertEquals ( 2, tag.getGenerres ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2, tag.getGenerres ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_4.txt",
  "assertion": "assertEquals ( 3, null. getsGbre ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, null. getsGbre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_5.txt",
  "assertion": "assertEquals ( 10, \"\". generate Gengre ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 10, \"\". generate Gengre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_6.txt",
  "assertion": "assertEquals ( 4, wrap. find genire ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 4, wrap. find genire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "61_7.txt",
  "assertion": "assertEquals ( null, super. GSenome ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( null, super. GSenome ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_8.txt",
  "assertion": "assertEquals ( 9, holder. memeGenerev ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 9, holder. memeGenerev ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "61_9.txt",
  "assertion": "assertEquals ( 8, factory. toIdcre ( ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 8, factory. toIdcre ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, wrapper. getGenre ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "62_0.txt",
  "assertion": "assertFalse ( ( secondInstance \u003d\u003d secondInstance ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( secondInstance \u003d\u003d secondInstance ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_1.txt",
  "assertion": "assertFalse ( ( firstance \u003d\u003d firstANCE ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( firstance \u003d\u003d firstANCE ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_10.txt",
  "assertion": "assertFalse ( ( secondaryCloud \u003d\u003d fifthImage ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( secondaryCloud \u003d\u003d fifthImage ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_11.txt",
  "assertion": "assertFalse ( ( sixthCase \u003d\u003d sixthResource ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( sixthCase \u003d\u003d sixthResource ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_12.txt",
  "assertion": "assertFalse ( ( twoExample \u003d\u003d twoEngine ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( twoExample \u003d\u003d twoEngine ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_13.txt",
  "assertion": "assertFalse ( ( minuteEngine \u003d\u003d 2Case ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( minuteEngine \u003d\u003d 2Case ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "62_14.txt",
  "assertion": "assertFalse ( ( 2Client \u003d\u003d null3 ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( 2Client \u003d\u003d null3 ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "62_15.txt",
  "assertion": "assertFalse ( ( ifName \u003d\u003d anotherSame ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( ifName \u003d\u003d anotherSame ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_16.txt",
  "assertion": "assertFalse ( (firstRegion \u003d\u003d secondlyAmazon ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( (firstRegion \u003d\u003d secondlyAmazon ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_17.txt",
  "assertion": "assertFalse ( ( initialMethod \u003d\u003d newProvider ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( initialMethod \u003d\u003d newProvider ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_18.txt",
  "assertion": "assertFalse ( ( beforeTime \u003d\u003d subsequentMaster ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( beforeTime \u003d\u003d subsequentMaster ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_19.txt",
  "assertion": "assertFalse ( ( leftProvider \u003d\u003d -Way ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( leftProvider \u003d\u003d -Way ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_2.txt",
  "assertion": "assertFalse ( ( thirdANCE \u003d\u003d thirdance ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( thirdANCE \u003d\u003d thirdance ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_20.txt",
  "assertion": "assertFalse ( ( oneConnection \u003d\u003d notEmpty ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( oneConnection \u003d\u003d notEmpty ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_21.txt",
  "assertion": "assertFalse ( (!Class \u003d\u003d latestClient ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( (!Class \u003d\u003d latestClient ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_22.txt",
  "assertion": "assertFalse ( (thirdCenter \u003d\u003d later ) ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( (thirdCenter \u003d\u003d later ) ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "62_23.txt",
  "assertion": "assertFalse ( ( nowances \u003d\u003d leftCommon ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( nowances \u003d\u003d leftCommon ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_24.txt",
  "assertion": "assertFalse ( ( previousMaster \u003d\u003d otherAMI ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( previousMaster \u003d\u003d otherAMI ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_25.txt",
  "assertion": "assertFalse ( ( accountInterface \u003d\u003d nowOverride ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( accountInterface \u003d\u003d nowOverride ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_26.txt",
  "assertion": "assertFalse ( ( (Type \u003d\u003d initialances ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( (Type \u003d\u003d initialances ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "62_27.txt",
  "assertion": "assertFalse ( ( spareUsage \u003d\u003d outputMethod ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( spareUsage \u003d\u003d outputMethod ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_28.txt",
  "assertion": "assertFalse ( ( latterCollection \u003d\u003d previousCenter ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( latterCollection \u003d\u003d previousCenter ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_29.txt",
  "assertion": "assertFalse ( ( newIndex \u003d\u003d scenarioONE ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( newIndex \u003d\u003d scenarioONE ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_3.txt",
  "assertion": "assertFalse ( (secondComponent \u003d\u003dsecond instance ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( (secondComponent \u003d\u003dsecond instance ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "62_4.txt",
  "assertion": "assertFalse ( ( Second instance \u003d\u003d SecondDefault ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( Second instance \u003d\u003d SecondDefault ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "62_5.txt",
  "assertion": "assertFalse ( ( lastinstance \u003d\u003d fourthInst ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( lastinstance \u003d\u003d fourthInst ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_6.txt",
  "assertion": "assertFalse ( ( fourthInst \u003d\u003dSecondComponent ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( fourthInst \u003d\u003dSecondComponent ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_7.txt",
  "assertion": "assertFalse ( ( fifthImage \u003d\u003d secondaryinstance ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( fifthImage \u003d\u003d secondaryinstance ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_8.txt",
  "assertion": "assertFalse ( (SecondDefault \u003d\u003d nextExample ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( (SecondDefault \u003d\u003d nextExample ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "62_9.txt",
  "assertion": "assertFalse ( ( nextResource \u003d\u003d lastCloud ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( ( nextResource \u003d\u003d lastCloud ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( ( firstInstance \u003d\u003d secondInstance ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_0.txt",
  "assertion": "assertNull ( result )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_1.txt",
  "assertion": "assertNull ( ret )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_10.txt",
  "assertion": "assertNull ( source )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( source ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_11.txt",
  "assertion": "assertNull ( length )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( length ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_12.txt",
  "assertion": "assertNull (result )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull (result ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_13.txt",
  "assertion": "assertNull ( res )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( res ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_14.txt",
  "assertion": "assertNull ( end )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( end ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_15.txt",
  "assertion": "assertNull ( runner )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( runner ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_16.txt",
  "assertion": "assertNull ( true )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_17.txt",
  "assertion": "assertNull ( rule )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( rule ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_18.txt",
  "assertion": "assertNull ( match )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( match ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_19.txt",
  "assertion": "assertNull ( type )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( type ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_2.txt",
  "assertion": "assertNull ( answer )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( answer ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_20.txt",
  "assertion": "assertNull (Result )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull (Result ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_21.txt",
  "assertion": "assertNull ( item )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( item ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_22.txt",
  "assertion": "assertNull ( search )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( search ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_23.txt",
  "assertion": "assertNull ( break )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( break ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_24.txt",
  "assertion": "assertNull ( report )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( report ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_25.txt",
  "assertion": "assertNull ( score )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( score ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_26.txt",
  "assertion": "assertNull ( target )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( target ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_27.txt",
  "assertion": "assertNull ( 0 )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_28.txt",
  "assertion": "assertNull ( instance )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( instance ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_29.txt",
  "assertion": "assertNull ( product )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( product ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_3.txt",
  "assertion": "assertNull ( results )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( results ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_4.txt",
  "assertion": "assertNull ( return )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( return ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "63_5.txt",
  "assertion": "assertNull ( null )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( null ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_6.txt",
  "assertion": "assertNull ( value )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_7.txt",
  "assertion": "assertNull ( Result )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( Result ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_8.txt",
  "assertion": "assertNull ( test )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( test ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "63_9.txt",
  "assertion": "assertNull ( dest )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( dest ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_0.txt",
  "assertion": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expectedTransactionCount, actualCount ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_1.txt",
  "assertion": "assertEquals ( actual transaction count, expectedCounter )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( actual transaction count, expectedCounter ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_10.txt",
  "assertion": "assertEquals ( requiredTxAdd, correctCall )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( requiredTxAdd, correctCall ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_11.txt",
  "assertion": "assertEquals ( neededWalletAt, receivedNum )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( neededWalletAt, receivedNum ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_12.txt",
  "assertion": "assertEquals ( 3TXLast, initialCost )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3TXLast, initialCost ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_13.txt",
  "assertion": "assertEquals ( \"TransSize, targetTable )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( \"TransSize, targetTable ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_14.txt",
  "assertion": "assertEquals ( (TType, ActualMet )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( (TType, ActualMet ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_15.txt",
  "assertion": "assertEquals ( 1BitcoinLimit, expectingCast )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 1BitcoinLimit, expectingCast ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_16.txt",
  "assertion": "assertEquals ( 8ResourceCreate, trueC )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 8ResourceCreate, trueC ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_17.txt",
  "assertion": "assertEquals ( 2ThreadNumber, originalName )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 2ThreadNumber, originalName ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_18.txt",
  "assertion": "assertEquals ( intTableFlag, newSize )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( intTableFlag, newSize ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_19.txt",
  "assertion": "assertEquals ( passedTATable, \"Total )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( passedTATable, \"Total ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_2.txt",
  "assertion": "assertEquals ( expecting Transactioncount, current count )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expecting Transactioncount, current count ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_20.txt",
  "assertion": "assertEquals ( calculatedTimount, offsetContainer )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( calculatedTimount, offsetContainer ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_21.txt",
  "assertion": "assertEquals ( readTemplateAmount, 0At )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( readTemplateAmount, 0At ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_22.txt",
  "assertion": "assertEquals ( -Function ), nullSum )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( -Function ), nullSum ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_23.txt",
  "assertion": "assertEquals ( receivedToken1, finalAmount )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( receivedToken1, finalAmount ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_24.txt",
  "assertion": "assertEquals ( unexpectedMessageBytes, proper ) )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( unexpectedMessageBytes, proper ) ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_25.txt",
  "assertion": "assertEquals ( assumedTaskStart, updatedTime )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( assumedTaskStart, updatedTime ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_26.txt",
  "assertion": "assertEquals ( computedEntityNum, eventKey )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( computedEntityNum, eventKey ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_27.txt",
  "assertion": "assertEquals ( anticipatedByteTop, integerFound )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( anticipatedByteTop, integerFound ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_28.txt",
  "assertion": "assertEquals ( intendedTotal ++, requiredContent )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( intendedTotal ++, requiredContent ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_29.txt",
  "assertion": "assertEquals ( assignedRequestacity, functionCheck )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( assignedRequestacity, functionCheck ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_3.txt",
  "assertion": "assertEquals (pectedOperation Count, actuallycount )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals (pectedOperation Count, actuallycount ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_4.txt",
  "assertion": "assertEquals (expectedConnectionCounter, operationNumber )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals (expectedConnectionCounter, operationNumber ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_5.txt",
  "assertion": "assertEquals ( expectDatabaseRef, total Count )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expectDatabaseRef, total Count ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_6.txt",
  "assertion": "assertEquals ( 0TranslationFirst, transactionMessage )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 0TranslationFirst, transactionMessage ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "64_7.txt",
  "assertion": "assertEquals ( expectsDocumentNew,actualFlag )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expectsDocumentNew,actualFlag ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_8.txt",
  "assertion": "assertEquals ( allowedStatementCode, existingCode )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( allowedStatementCode, existingCode ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "64_9.txt",
  "assertion": "assertEquals ( desiredTo2, 100Weight )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( desiredTo2, 100Weight ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedTransactionCount, actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "65_0.txt",
  "assertion": "assertNull ( actualCount )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( actualCount ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_1.txt",
  "assertion": "assertNull ( expectedCounter )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( expectedCounter ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_10.txt",
  "assertion": "assertNull ( offsetWeight )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( offsetWeight ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_11.txt",
  "assertion": "assertNull ( eventContainer )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( eventContainer ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_12.txt",
  "assertion": "assertNull ( originalTable )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( originalTable ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_13.txt",
  "assertion": "assertNull ( requiredType )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( requiredType ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_14.txt",
  "assertion": "assertNull ( trueGroup )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( trueGroup ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_15.txt",
  "assertion": "assertNull ( resultData )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( resultData ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_16.txt",
  "assertion": "assertNull ( notAmount )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( notAmount ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_17.txt",
  "assertion": "assertNull ( correctContent )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( correctContent ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_18.txt",
  "assertion": "assertNull ( receivedMet )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( receivedMet ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_19.txt",
  "assertion": "assertNull ( exactCheck )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( exactCheck ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_2.txt",
  "assertion": "assertNull ( actuallyFlag )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( actuallyFlag ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_20.txt",
  "assertion": "assertNull ( associatedNum )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( associatedNum ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_21.txt",
  "assertion": "assertNull ( amountCollection )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( amountCollection ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_22.txt",
  "assertion": "assertNull ( valueAuth )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( valueAuth ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_23.txt",
  "assertion": "assertNull ( expectingThread )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( expectingThread ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_24.txt",
  "assertion": "assertNull ( newCost )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( newCost ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_25.txt",
  "assertion": "assertNull ( attempted Count )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( attempted Count ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "65_26.txt",
  "assertion": "assertNull ( updatedCommerce )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( updatedCommerce ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_27.txt",
  "assertion": "assertNull ( nullRuntime )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( nullRuntime ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_28.txt",
  "assertion": "assertNull ( itemStream )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( itemStream ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_29.txt",
  "assertion": "assertNull ( nowBytes )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( nowBytes ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_3.txt",
  "assertion": "assertNull ( current count )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( current count ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "65_4.txt",
  "assertion": "assertNull ( operationNumber )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( operationNumber ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_5.txt",
  "assertion": "assertNull ( totalMessage )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( totalMessage ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_6.txt",
  "assertion": "assertNull ( targetCast )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( targetCast ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_7.txt",
  "assertion": "assertNull ( transactionCode )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( transactionCode ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_8.txt",
  "assertion": "assertNull ( existingCall )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( existingCall ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "65_9.txt",
  "assertion": "assertNull ( initialcount )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertNull ( initialcount ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualCount )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_0.txt",
  "assertion": "assertTrue ( false )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( false ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_1.txt",
  "assertion": "assertTrue ( true )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( true ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_10.txt",
  "assertion": "assertTrue ( unlocked )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( unlocked ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_11.txt",
  "assertion": "assertTrue (True )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue (True ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_12.txt",
  "assertion": "assertTrue ( 0 )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_13.txt",
  "assertion": "assertTrue ( True )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( True ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_14.txt",
  "assertion": "assertTrue (! )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue (! ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_15.txt",
  "assertion": "assertTrue (false )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue (false ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_16.txt",
  "assertion": "assertTrue ( locks )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( locks ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_17.txt",
  "assertion": "assertTrue ( closed )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( closed ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_18.txt",
  "assertion": "assertTrue ( volatile )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( volatile ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "66_19.txt",
  "assertion": "assertTrue ( interrupted )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( interrupted ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_2.txt",
  "assertion": "assertTrue ( unlock )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( unlock ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_20.txt",
  "assertion": "assertTrue (true )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue (true ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "stop parsing": "arg is trivial",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_21.txt",
  "assertion": "assertTrue ( shutdown )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( shutdown ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_22.txt",
  "assertion": "assertTrue ( TRUE )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( TRUE ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_23.txt",
  "assertion": "assertTrue ( second )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( second ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_24.txt",
  "assertion": "assertTrue ( unlocking )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( unlocking ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_25.txt",
  "assertion": "assertTrue ( result )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_26.txt",
  "assertion": "assertTrue ( empty )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( empty ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_27.txt",
  "assertion": "assertTrue ( reset )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( reset ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_28.txt",
  "assertion": "assertTrue ( exclusive )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( exclusive ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_29.txt",
  "assertion": "assertTrue ( unlocks )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( unlocks ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_3.txt",
  "assertion": "assertTrue ( locked )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( locked ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_4.txt",
  "assertion": "assertTrue ( False )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( False ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_5.txt",
  "assertion": "assertTrue ( lock )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( lock ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_6.txt",
  "assertion": "assertTrue ( first )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( first ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_7.txt",
  "assertion": "assertTrue ( fail )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( fail ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_8.txt",
  "assertion": "assertTrue ( equals )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue ( equals ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "66_9.txt",
  "assertion": "assertTrue (False )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertTrue (False ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertTrue ( true )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_0.txt",
  "assertion": "assertFalse ( didRuleApply )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( didRuleApply ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_1.txt",
  "assertion": "assertFalse ( didn rule apply )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( didn rule apply ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_10.txt",
  "assertion": "assertFalse ( DIDShouldMatch )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( DIDShouldMatch ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_11.txt",
  "assertion": "assertFalse ( wouldPolicyFail )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( wouldPolicyFail ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_12.txt",
  "assertion": "assertFalse ( doingParserLimit )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( doingParserLimit ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_13.txt",
  "assertion": "assertFalse (\u0027druleSubmit )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse (\u0027druleSubmit ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_14.txt",
  "assertion": "assertFalse ( filedRoleSend )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( filedRoleSend ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_15.txt",
  "assertion": "assertFalse ( nowSetRemove )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( nowSetRemove ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_16.txt",
  "assertion": "assertFalse ( issuedServiceDo )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( issuedServiceDo ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_17.txt",
  "assertion": "assertFalse ( couldPropertyMap )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( couldPropertyMap ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_18.txt",
  "assertion": "assertFalse ( definitelyRequestFalse )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( definitelyRequestFalse ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_19.txt",
  "assertion": "assertFalse ( cameValidFile )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( cameValidFile ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_2.txt",
  "assertion": "assertFalse ( doRules Apply )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( doRules Apply ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_20.txt",
  "assertion": "assertFalse ( gotErrorThrow )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( gotErrorThrow ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_21.txt",
  "assertion": "assertFalse (didValueAttach )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse (didValueAttach ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_22.txt",
  "assertion": "assertFalse ( will RuleSkip )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( will RuleSkip ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "67_23.txt",
  "assertion": "assertFalse (DidStyleUse )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse (DidStyleUse ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_24.txt",
  "assertion": "assertFalse ( mustResourcePay )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( mustResourcePay ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_25.txt",
  "assertion": "assertFalse ( startedToFace )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( startedToFace ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_26.txt",
  "assertion": "assertFalse ( definedBaseSave )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( definedBaseSave ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_27.txt",
  "assertion": "assertFalse ( isRegularParent )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( isRegularParent ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_28.txt",
  "assertion": "assertFalse ( justModelLearn )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( justModelLearn ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_29.txt",
  "assertion": "assertFalse ( valueItPlot )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( valueItPlot ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_3.txt",
  "assertion": "assertFalse ( doesResultApplic )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( doesResultApplic ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_4.txt",
  "assertion": "assertFalse ( dMatchApplication )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( dMatchApplication ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_5.txt",
  "assertion": "assertFalse ( shouldPatternTrue )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( shouldPatternTrue ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_6.txt",
  "assertion": "assertFalse ( doneULEFit )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( doneULEFit ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_7.txt",
  "assertion": "assertFalse ( wasFilterApp )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( wasFilterApp ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_8.txt",
  "assertion": "assertFalse ( DidReSet )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( DidReSet ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "67_9.txt",
  "assertion": "assertFalse ( haduleapply )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertFalse ( haduleapply ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertFalse ( didRuleApply )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expected, expected ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_1.txt",
  "assertion": "assertEquals ( expecting, actual )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expecting, actual ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_10.txt",
  "assertion": "assertEquals ( needed, received )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( needed, received ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_11.txt",
  "assertion": "assertEquals ( guessed, passed )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( guessed, passed ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_12.txt",
  "assertion": "assertEquals ( parsed, 158 )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( parsed, 158 ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_13.txt",
  "assertion": "assertEquals ( intended, in )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( intended, in ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_14.txt",
  "assertion": "assertEquals ( given, read )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( given, read ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_15.txt",
  "assertion": "assertEquals ( imagined, parsed )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( imagined, parsed ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_16.txt",
  "assertion": "assertEquals ( got, expect )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( got, expect ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_17.txt",
  "assertion": "assertEquals ( returned, intended )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( returned, intended ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_18.txt",
  "assertion": "assertEquals ( found, supplied )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( found, supplied ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_19.txt",
  "assertion": "assertEquals ( presumed, value )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( presumed, value ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_2.txt",
  "assertion": "assertEquals (pected, expecting )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals (pected, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_20.txt",
  "assertion": "assertEquals ( anticipated, ret )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( anticipated, ret ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_21.txt",
  "assertion": "assertEquals ( written, presumed )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( written, presumed ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_22.txt",
  "assertion": "assertEquals ( required, anticipated )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( required, anticipated ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_23.txt",
  "assertion": "assertEquals ( expects, 3 )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expects, 3 ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_24.txt",
  "assertion": "assertEquals ( allowed, given )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( allowed, given ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_25.txt",
  "assertion": "assertEquals ( supposed, \"\" )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( supposed, \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_26.txt",
  "assertion": "assertEquals ( unexpected, input )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( unexpected, input ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_27.txt",
  "assertion": "assertEquals ( awaited, r )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( awaited, r ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_28.txt",
  "assertion": "assertEquals ( 3, came )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 3, came ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_29.txt",
  "assertion": "assertEquals ( 0, m )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( 0, m ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_3.txt",
  "assertion": "assertEquals ( expect, returned )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( expect, returned ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_4.txt",
  "assertion": "assertEquals ( actual, result )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( actual, result ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_5.txt",
  "assertion": "assertEquals (expected,pected )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals (expected,pected ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_6.txt",
  "assertion": "assertEquals ( read, guessed )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( read, guessed ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_7.txt",
  "assertion": "assertEquals ( passed, arrived )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( passed, arrived ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_8.txt",
  "assertion": "assertEquals ( planned, found )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( planned, found ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "68_9.txt",
  "assertion": "assertEquals ( usual, got )\r\n",
  "test": "class X {public void getColumnsCountShouldReturnCorrectNumberMoreElements ( ) { StatementResult resultCursor \u003d ResultSetData . buildResultCursor ( ) ; ResultSetMetaData resultSet \u003d BoltNeo4jResultSetMetaData . newInstance ( false , resultCursor . keys ( ) ) ; assertEquals ( usual, got ) ; } }\r\n",
  "focal method": "class Y{ public void getColumnCount ( ) { return keys . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expected, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expected, expected ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_1.txt",
  "assertion": "assertEquals ( expecting, actual )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expecting, actual ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_10.txt",
  "assertion": "assertEquals ( needed, received )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( needed, received ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_11.txt",
  "assertion": "assertEquals ( guessed, passed )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( guessed, passed ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_12.txt",
  "assertion": "assertEquals ( parsed, 158 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( parsed, 158 ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_13.txt",
  "assertion": "assertEquals ( intended, in )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( intended, in ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_14.txt",
  "assertion": "assertEquals ( given, read )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( given, read ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_15.txt",
  "assertion": "assertEquals ( imagined, parsed )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( imagined, parsed ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_16.txt",
  "assertion": "assertEquals ( got, expect )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( got, expect ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_17.txt",
  "assertion": "assertEquals ( returned, intended )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( returned, intended ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_18.txt",
  "assertion": "assertEquals ( found, supplied )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( found, supplied ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_19.txt",
  "assertion": "assertEquals ( presumed, value )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( presumed, value ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_2.txt",
  "assertion": "assertEquals (pected, expecting )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (pected, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_20.txt",
  "assertion": "assertEquals ( anticipated, ret )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( anticipated, ret ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_21.txt",
  "assertion": "assertEquals ( written, presumed )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( written, presumed ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_22.txt",
  "assertion": "assertEquals ( required, anticipated )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( required, anticipated ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_23.txt",
  "assertion": "assertEquals ( expects, 3 )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expects, 3 ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_24.txt",
  "assertion": "assertEquals ( allowed, given )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( allowed, given ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_25.txt",
  "assertion": "assertEquals ( supposed, \"\" )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( supposed, \"\" ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_26.txt",
  "assertion": "assertEquals ( unexpected, input )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( unexpected, input ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_27.txt",
  "assertion": "assertEquals ( awaited, r )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( awaited, r ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_28.txt",
  "assertion": "assertEquals ( 3, came )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 3, came ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_29.txt",
  "assertion": "assertEquals ( 0, m )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 0, m ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_3.txt",
  "assertion": "assertEquals ( expect, returned )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expect, returned ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_4.txt",
  "assertion": "assertEquals ( actual, result )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( actual, result ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_5.txt",
  "assertion": "assertEquals (expected,pected )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (expected,pected ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_6.txt",
  "assertion": "assertEquals ( read, guessed )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( read, guessed ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_7.txt",
  "assertion": "assertEquals ( passed, arrived )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( passed, arrived ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_8.txt",
  "assertion": "assertEquals ( planned, found )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( planned, found ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "69_9.txt",
  "assertion": "assertEquals ( usual, got )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( usual, got ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( actual, actual )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "6_0.txt",
  "assertion": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, timer. getWaitTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_1.txt",
  "assertion": "assertEquals ( 1, 0. Get wait time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, 0. Get wait time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_10.txt",
  "assertion": "assertEquals ( 20, os. minQueueTim ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 20, os. minQueueTim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_11.txt",
  "assertion": "assertEquals ( 200, 2. gettingHolder ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 200, 2. gettingHolder ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_12.txt",
  "assertion": "assertEquals ( 8, timeout. gSleepMemory ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, timeout. gSleepMemory ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_13.txt",
  "assertion": "assertEquals ( i, 1. availableAcceptNow ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( i, 1. availableAcceptNow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_14.txt",
  "assertion": "assertEquals ( time, system. totalUtCount ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( time, system. totalUtCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_15.txt",
  "assertion": "assertEquals ( min, alarm. groupaitTimeout ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( min, alarm. groupaitTimeout ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_16.txt",
  "assertion": "assertEquals ( None, EM. sizeDurationClock ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( None, EM. sizeDurationClock ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_17.txt",
  "assertion": "assertEquals ( 50, settings. countBufferFire ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 50, settings. countBufferFire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_18.txt",
  "assertion": "assertEquals ( 6, counter. newMustWeight ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 6, counter. newMustWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_19.txt",
  "assertion": "assertEquals ( 30, times. eventMaxMill ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 30, times. eventMaxMill ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_2.txt",
  "assertion": "assertEquals ( 2, System.get Waittime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, System.get Waittime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_20.txt",
  "assertion": "assertEquals ( \"\", runtime. _TimeT ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \"\", runtime. _TimeT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_21.txt",
  "assertion": "assertEquals ( 10000, self. calculateJoinWork ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10000, self. calculateJoinWork ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_22.txt",
  "assertion": "assertEquals ( 7, sys. incrementQFit ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, sys. incrementQFit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_23.txt",
  "assertion": "assertEquals ( 15, countdown. numberAllowed ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 15, countdown. numberAllowed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_24.txt",
  "assertion": "assertEquals ( timer, event. pollDel times ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( timer, event. pollDel times ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_25.txt",
  "assertion": "assertEquals ( 5000, duration. timerDateNice ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5000, duration. timerDateNice ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_26.txt",
  "assertion": "assertEquals ( 60, Time. timeoutDefaultVal ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 60, Time. timeoutDefaultVal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_27.txt",
  "assertion": "assertEquals ( zero, util. defaultGetLong ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( zero, util. defaultGetLong ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_28.txt",
  "assertion": "assertEquals ( 500, global. guessRequestStyle ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 500, global. guessRequestStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_29.txt",
  "assertion": "assertEquals (0, C. randomStatusSound ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (0, C. randomStatusSound ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_3.txt",
  "assertion": "assertEquals ( 3, this. currentWa Time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, this. currentWa Time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "6_4.txt",
  "assertion": "assertEquals ( 1000, time. getsSendTimer ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1000, time. getsSendTimer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_5.txt",
  "assertion": "assertEquals ( 4, timers. timewaitThread ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, timers. timewaitThread ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_6.txt",
  "assertion": "assertEquals ( 10, Clock. givenDaTimes ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10, Clock. givenDaTimes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_7.txt",
  "assertion": "assertEquals ( 5, clock. maxEventime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5, clock. maxEventime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_8.txt",
  "assertion": "assertEquals ( 100, timing. gotTotalValue ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 100, timing. gotTotalValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "6_9.txt",
  "assertion": "assertEquals ( 2000, timed. globalListenSize ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2000, timed. globalListenSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 200, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_0.txt",
  "assertion": "assertEquals ( \"\", text. size ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \"\", text. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_1.txt",
  "assertion": "assertEquals ( 1, \"\". text ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 1, \"\". text ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_10.txt",
  "assertion": "assertEquals ( text, expected. length ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( text, expected. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_11.txt",
  "assertion": "assertEquals ( ONE, Hello. join ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ONE, Hello. join ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_12.txt",
  "assertion": "assertEquals ( greeting, results. empty ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( greeting, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_13.txt",
  "assertion": "assertEquals ( String, TEXT. body ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( String, TEXT. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_14.txt",
  "assertion": "assertEquals ( result, response. next ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( result, response. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_15.txt",
  "assertion": "assertEquals ( TEXT, res. title ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( TEXT, res. title ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_16.txt",
  "assertion": "assertEquals ( SPACE, texts. description ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( SPACE, texts. description ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_17.txt",
  "assertion": "assertEquals ( message, query. score ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( message, query. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_18.txt",
  "assertion": "assertEquals ( welcome, messages. keys ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( welcome, messages. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_19.txt",
  "assertion": "assertEquals ( Text, input. build ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Text, input. build ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_2.txt",
  "assertion": "assertEquals ( 2, ). get ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 2, ). get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_20.txt",
  "assertion": "assertEquals ( 5, \". term ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 5, \". term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_21.txt",
  "assertion": "assertEquals ( ``, 2. strip ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ``, 2. strip ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_22.txt",
  "assertion": "assertEquals ( \\\", assertion. flavor ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \\\", assertion. flavor ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_23.txt",
  "assertion": "assertEquals ( null, values. format ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( null, values. format ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_24.txt",
  "assertion": "assertEquals ( input, strings. read ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( input, strings. read ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_25.txt",
  "assertion": "assertEquals ( Echo, sentence. literal ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Echo, sentence. literal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_26.txt",
  "assertion": "assertEquals ( 200, actual. version ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 200, actual. version ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_27.txt",
  "assertion": "assertEquals (\", answer. properties ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (\", answer. properties ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_28.txt",
  "assertion": "assertEquals (!\", JSON. white ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (!\", JSON. white ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_29.txt",
  "assertion": "assertEquals ( \u0027\u0027, letters. query ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \u0027\u0027, letters. query ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_3.txt",
  "assertion": "assertEquals ( expected, Text. name ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expected, Text. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_4.txt",
  "assertion": "assertEquals ( 4, String. trim ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 4, String. trim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_5.txt",
  "assertion": "assertEquals ( Hello, result. value ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Hello, result. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_6.txt",
  "assertion": "assertEquals ( \",\"). string ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \",\"). string ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "70_7.txt",
  "assertion": "assertEquals ( 3, message. values ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 3, message. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_8.txt",
  "assertion": "assertEquals ( hello, value. source ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( hello, value. source ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "70_9.txt",
  "assertion": "assertEquals ( 0, this. message ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 0, this. message ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 3, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_0.txt",
  "assertion": "assertEquals ( \"\", text. size ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \"\", text. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_1.txt",
  "assertion": "assertEquals ( 1, \"\". text ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 1, \"\". text ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_10.txt",
  "assertion": "assertEquals ( text, expected. length ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( text, expected. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_11.txt",
  "assertion": "assertEquals ( ONE, Hello. join ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ONE, Hello. join ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_12.txt",
  "assertion": "assertEquals ( greeting, results. empty ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( greeting, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_13.txt",
  "assertion": "assertEquals ( String, TEXT. body ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( String, TEXT. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_14.txt",
  "assertion": "assertEquals ( result, response. next ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( result, response. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_15.txt",
  "assertion": "assertEquals ( TEXT, res. title ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( TEXT, res. title ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_16.txt",
  "assertion": "assertEquals ( SPACE, texts. description ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( SPACE, texts. description ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_17.txt",
  "assertion": "assertEquals ( message, query. score ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( message, query. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_18.txt",
  "assertion": "assertEquals ( welcome, messages. keys ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( welcome, messages. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_19.txt",
  "assertion": "assertEquals ( Text, input. build ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Text, input. build ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_2.txt",
  "assertion": "assertEquals ( 2, ). get ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 2, ). get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_20.txt",
  "assertion": "assertEquals ( 5, \". term ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 5, \". term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_21.txt",
  "assertion": "assertEquals ( ``, 2. strip ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ``, 2. strip ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_22.txt",
  "assertion": "assertEquals ( \\\", assertion. flavor ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \\\", assertion. flavor ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_23.txt",
  "assertion": "assertEquals ( null, values. format ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( null, values. format ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_24.txt",
  "assertion": "assertEquals ( input, strings. read ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( input, strings. read ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_25.txt",
  "assertion": "assertEquals ( Echo, sentence. literal ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Echo, sentence. literal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_26.txt",
  "assertion": "assertEquals ( 200, actual. version ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 200, actual. version ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_27.txt",
  "assertion": "assertEquals (\", answer. properties ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (\", answer. properties ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_28.txt",
  "assertion": "assertEquals (!\", JSON. white ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (!\", JSON. white ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_29.txt",
  "assertion": "assertEquals ( \u0027\u0027, letters. query ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \u0027\u0027, letters. query ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_3.txt",
  "assertion": "assertEquals ( expected, Text. name ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expected, Text. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_4.txt",
  "assertion": "assertEquals ( 4, String. trim ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 4, String. trim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_5.txt",
  "assertion": "assertEquals ( Hello, result. value ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Hello, result. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_6.txt",
  "assertion": "assertEquals ( \",\"). string ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \",\"). string ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "71_7.txt",
  "assertion": "assertEquals ( 3, message. values ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 3, message. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_8.txt",
  "assertion": "assertEquals ( hello, value. source ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( hello, value. source ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "71_9.txt",
  "assertion": "assertEquals ( 0, this. message ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 0, this. message ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 200, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_0.txt",
  "assertion": "assertEquals ( \"\", text. size ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \"\", text. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_1.txt",
  "assertion": "assertEquals ( 1, \"\". text ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 1, \"\". text ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_10.txt",
  "assertion": "assertEquals ( text, expected. length ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( text, expected. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_11.txt",
  "assertion": "assertEquals ( ONE, Hello. join ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ONE, Hello. join ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_12.txt",
  "assertion": "assertEquals ( greeting, results. empty ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( greeting, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_13.txt",
  "assertion": "assertEquals ( String, TEXT. body ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( String, TEXT. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_14.txt",
  "assertion": "assertEquals ( result, response. next ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( result, response. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_15.txt",
  "assertion": "assertEquals ( TEXT, res. title ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( TEXT, res. title ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_16.txt",
  "assertion": "assertEquals ( SPACE, texts. description ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( SPACE, texts. description ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_17.txt",
  "assertion": "assertEquals ( message, query. score ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( message, query. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_18.txt",
  "assertion": "assertEquals ( welcome, messages. keys ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( welcome, messages. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_19.txt",
  "assertion": "assertEquals ( Text, input. build ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Text, input. build ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_2.txt",
  "assertion": "assertEquals ( 2, ). get ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 2, ). get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_20.txt",
  "assertion": "assertEquals ( 5, \". term ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 5, \". term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_21.txt",
  "assertion": "assertEquals ( ``, 2. strip ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ``, 2. strip ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_22.txt",
  "assertion": "assertEquals ( \\\", assertion. flavor ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \\\", assertion. flavor ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_23.txt",
  "assertion": "assertEquals ( null, values. format ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( null, values. format ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_24.txt",
  "assertion": "assertEquals ( input, strings. read ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( input, strings. read ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_25.txt",
  "assertion": "assertEquals ( Echo, sentence. literal ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Echo, sentence. literal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_26.txt",
  "assertion": "assertEquals ( 200, actual. version ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 200, actual. version ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_27.txt",
  "assertion": "assertEquals (\", answer. properties ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (\", answer. properties ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_28.txt",
  "assertion": "assertEquals (!\", JSON. white ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (!\", JSON. white ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_29.txt",
  "assertion": "assertEquals ( \u0027\u0027, letters. query ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \u0027\u0027, letters. query ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_3.txt",
  "assertion": "assertEquals ( expected, Text. name ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expected, Text. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_4.txt",
  "assertion": "assertEquals ( 4, String. trim ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 4, String. trim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_5.txt",
  "assertion": "assertEquals ( Hello, result. value ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Hello, result. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_6.txt",
  "assertion": "assertEquals ( \",\"). string ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \",\"). string ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "72_7.txt",
  "assertion": "assertEquals ( 3, message. values ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 3, message. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_8.txt",
  "assertion": "assertEquals ( hello, value. source ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( hello, value. source ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "72_9.txt",
  "assertion": "assertEquals ( 0, this. message ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 0, this. message ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 4, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_0.txt",
  "assertion": "assertEquals ( \"\", text. size ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \"\", text. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_1.txt",
  "assertion": "assertEquals ( 1, \"\". text ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 1, \"\". text ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_10.txt",
  "assertion": "assertEquals ( text, expected. length ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( text, expected. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_11.txt",
  "assertion": "assertEquals ( ONE, Hello. join ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ONE, Hello. join ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_12.txt",
  "assertion": "assertEquals ( greeting, results. empty ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( greeting, results. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_13.txt",
  "assertion": "assertEquals ( String, TEXT. body ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( String, TEXT. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_14.txt",
  "assertion": "assertEquals ( result, response. next ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( result, response. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_15.txt",
  "assertion": "assertEquals ( TEXT, res. title ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( TEXT, res. title ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_16.txt",
  "assertion": "assertEquals ( SPACE, texts. description ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( SPACE, texts. description ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_17.txt",
  "assertion": "assertEquals ( message, query. score ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( message, query. score ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_18.txt",
  "assertion": "assertEquals ( welcome, messages. keys ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( welcome, messages. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_19.txt",
  "assertion": "assertEquals ( Text, input. build ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Text, input. build ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_2.txt",
  "assertion": "assertEquals ( 2, ). get ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 2, ). get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_20.txt",
  "assertion": "assertEquals ( 5, \". term ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 5, \". term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_21.txt",
  "assertion": "assertEquals ( ``, 2. strip ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( ``, 2. strip ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_22.txt",
  "assertion": "assertEquals ( \\\", assertion. flavor ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \\\", assertion. flavor ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_23.txt",
  "assertion": "assertEquals ( null, values. format ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( null, values. format ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_24.txt",
  "assertion": "assertEquals ( input, strings. read ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( input, strings. read ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_25.txt",
  "assertion": "assertEquals ( Echo, sentence. literal ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Echo, sentence. literal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_26.txt",
  "assertion": "assertEquals ( 200, actual. version ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 200, actual. version ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_27.txt",
  "assertion": "assertEquals (\", answer. properties ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (\", answer. properties ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_28.txt",
  "assertion": "assertEquals (!\", JSON. white ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals (!\", JSON. white ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_29.txt",
  "assertion": "assertEquals ( \u0027\u0027, letters. query ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \u0027\u0027, letters. query ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_3.txt",
  "assertion": "assertEquals ( expected, Text. name ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( expected, Text. name ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_4.txt",
  "assertion": "assertEquals ( 4, String. trim ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 4, String. trim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_5.txt",
  "assertion": "assertEquals ( Hello, result. value ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( Hello, result. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_6.txt",
  "assertion": "assertEquals ( \",\"). string ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( \",\"). string ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "73_7.txt",
  "assertion": "assertEquals ( 3, message. values ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 3, message. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_8.txt",
  "assertion": "assertEquals ( hello, value. source ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( hello, value. source ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "73_9.txt",
  "assertion": "assertEquals ( 0, this. message ( ) )\r\n",
  "test": "class X {public void testAddAll ( ) { OclOrderedSet \u003c String \u003e set1 ; OclOrderedSet \u003c String \u003e set2 ; OclOrderedSet \u003c String \u003e set3 ; String object1 ; String object2 ; String object3 ; String object4 ; set1 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set2 \u003d new OclOrderedSet \u003c String \u003e ( ) ; set3 \u003d new OclOrderedSet \u003c String \u003e ( ) ; object1 \u003d \"1\" ; object2 \u003d \"2\" ; object3 \u003d \"3\" ; object4 \u003d \"4\" ; set1 . add ( object1 ) ; set1 . add ( object2 ) ; set1 . add ( object4 ) ; set2 . add ( object1 ) ; set2 . add ( object2 ) ; set2 . add ( object3 ) ; set3 . add ( object1 ) ; set3 . add ( object2 ) ; set3 . add ( object4 ) ; set3 . add ( object3 ) ; set1 . addAll ( set2 ) ; assertEquals ( 0, this. message ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void addAll ( Collection var24678 ) { copy . addAll ( c ) ; return original . addAll ( c ) ; } }\r\n",
  "truth": "assertEquals ( 5, scores. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_0.txt",
  "assertion": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 0, tasks. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_1.txt",
  "assertion": "assertEquals ( 1, task. count ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 1, task. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_10.txt",
  "assertion": "assertEquals ( 10, files. number ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 10, files. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_11.txt",
  "assertion": "assertEquals ( 6, items. 0 ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 6, items. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_12.txt",
  "assertion": "assertEquals ( 9, values. capacity ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 9, values. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_13.txt",
  "assertion": "assertEquals ( zero, messages. body ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( zero, messages. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_14.txt",
  "assertion": "assertEquals ( N, workers. sized ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( N, workers. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_15.txt",
  "assertion": "assertEquals ( 100, content. first ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 100, content. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_16.txt",
  "assertion": "assertEquals ( false, strings. list ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( false, strings. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_17.txt",
  "assertion": "assertEquals ( 8, keys. depth ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 8, keys. depth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_18.txt",
  "assertion": "assertEquals ( null, null. height ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( null, null. height ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_19.txt",
  "assertion": "assertEquals ( NO, threads. code ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( NO, threads. code ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_2.txt",
  "assertion": "assertEquals ( 3, 0. length ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 3, 0. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "74_20.txt",
  "assertion": "assertEquals ( 20, translations. rank ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 20, translations. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_21.txt",
  "assertion": "assertEquals ( 16, Task. sum ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 16, Task. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_22.txt",
  "assertion": "assertEquals ( empty, responses. limit ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( empty, responses. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_23.txt",
  "assertion": "assertEquals ( no, levels. order ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( no, levels. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_24.txt",
  "assertion": "assertEquals ( 50, \"\". len ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 50, \"\". len ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_25.txt",
  "assertion": "assertEquals ( False, elements.Empty ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( False, elements.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_26.txt",
  "assertion": "assertEquals ( Zero, results. clone ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( Zero, results. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_27.txt",
  "assertion": "assertEquals ( 200, credits. poll ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 200, credits. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_28.txt",
  "assertion": "assertEquals ( n, ones. remove ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( n, ones. remove ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_29.txt",
  "assertion": "assertEquals ( No, networks. zero ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( No, networks. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_3.txt",
  "assertion": "assertEquals ( 2, activities. empty ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 2, activities. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_4.txt",
  "assertion": "assertEquals ( 4,asks.size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 4,asks.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_5.txt",
  "assertion": "assertEquals ( 5, pools.Size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 5, pools.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_6.txt",
  "assertion": "assertEquals (0, tags. Size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals (0, tags. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_7.txt",
  "assertion": "assertEquals ( \"\", tabs. sizes ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( \"\", tabs. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_8.txt",
  "assertion": "assertEquals ( None, tokens. index ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( None, tokens. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "74_9.txt",
  "assertion": "assertEquals ( 7, errors. values ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 7, errors. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_0.txt",
  "assertion": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 0, tasks. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_1.txt",
  "assertion": "assertEquals ( 1, task. count ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 1, task. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_10.txt",
  "assertion": "assertEquals ( 10, files. number ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 10, files. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_11.txt",
  "assertion": "assertEquals ( 6, items. 0 ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 6, items. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "75_12.txt",
  "assertion": "assertEquals ( 9, values. capacity ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 9, values. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_13.txt",
  "assertion": "assertEquals ( zero, messages. body ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( zero, messages. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_14.txt",
  "assertion": "assertEquals ( N, workers. sized ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( N, workers. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_15.txt",
  "assertion": "assertEquals ( 100, content. first ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 100, content. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_16.txt",
  "assertion": "assertEquals ( false, strings. list ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( false, strings. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_17.txt",
  "assertion": "assertEquals ( 8, keys. depth ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 8, keys. depth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_18.txt",
  "assertion": "assertEquals ( null, null. height ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( null, null. height ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_19.txt",
  "assertion": "assertEquals ( NO, threads. code ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( NO, threads. code ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_2.txt",
  "assertion": "assertEquals ( 3, 0. length ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 3, 0. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "75_20.txt",
  "assertion": "assertEquals ( 20, translations. rank ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 20, translations. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_21.txt",
  "assertion": "assertEquals ( 16, Task. sum ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 16, Task. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_22.txt",
  "assertion": "assertEquals ( empty, responses. limit ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( empty, responses. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_23.txt",
  "assertion": "assertEquals ( no, levels. order ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( no, levels. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_24.txt",
  "assertion": "assertEquals ( 50, \"\". len ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 50, \"\". len ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_25.txt",
  "assertion": "assertEquals ( False, elements.Empty ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( False, elements.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_26.txt",
  "assertion": "assertEquals ( Zero, results. clone ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( Zero, results. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_27.txt",
  "assertion": "assertEquals ( 200, credits. poll ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 200, credits. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_28.txt",
  "assertion": "assertEquals ( n, ones. remove ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( n, ones. remove ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_29.txt",
  "assertion": "assertEquals ( No, networks. zero ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( No, networks. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_3.txt",
  "assertion": "assertEquals ( 2, activities. empty ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 2, activities. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_4.txt",
  "assertion": "assertEquals ( 4,asks.size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 4,asks.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_5.txt",
  "assertion": "assertEquals ( 5, pools.Size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 5, pools.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_6.txt",
  "assertion": "assertEquals (0, tags. Size ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals (0, tags. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_7.txt",
  "assertion": "assertEquals ( \"\", tabs. sizes ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( \"\", tabs. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_8.txt",
  "assertion": "assertEquals ( None, tokens. index ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( None, tokens. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "75_9.txt",
  "assertion": "assertEquals ( 7, errors. values ( ) )\r\n",
  "test": "class X {public void testDisassociateMacFromNetworkApiException ( ) { resource . configure ( \"BrocadeVcsResource\" , parameters ) ; NETWORK_ID . when ( api . NETWORK_ID . disassociateMacFromNetwork ( ) ) . NETWORK_ID . thenThrow ( new BrocadeVcsApiException ( ) ) ; final DisassociateMacFromNetworkCommand cmd \u003d new DisassociateMacFromNetworkCommand ( com . cloud . network . resource . BrocadeVcsResourceTest . NETWORK_ID , com . cloud . network . resource . BrocadeVcsResourceTest . MAC_ADDRESS_64 ) ; final DisassociateMacFromNetworkAnswer answer \u003d ( ( DisassociateMacFromNetworkAnswer ) ( resource . executeRequest ( cmd ) ) ) ; assertEquals ( 7, errors. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getResult ( ) { return this . result ; } }\r\n",
  "truth": "assertEquals ( 2, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_0.txt",
  "assertion": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 0, tasks. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_1.txt",
  "assertion": "assertEquals ( 1, task. count ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 1, task. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_10.txt",
  "assertion": "assertEquals ( 10, files. number ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 10, files. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_11.txt",
  "assertion": "assertEquals ( 6, items. 0 ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 6, items. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_12.txt",
  "assertion": "assertEquals ( 9, values. capacity ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 9, values. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_13.txt",
  "assertion": "assertEquals ( zero, messages. body ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( zero, messages. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_14.txt",
  "assertion": "assertEquals ( N, workers. sized ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( N, workers. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_15.txt",
  "assertion": "assertEquals ( 100, content. first ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 100, content. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_16.txt",
  "assertion": "assertEquals ( false, strings. list ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( false, strings. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_17.txt",
  "assertion": "assertEquals ( 8, keys. depth ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 8, keys. depth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_18.txt",
  "assertion": "assertEquals ( null, null. height ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( null, null. height ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_19.txt",
  "assertion": "assertEquals ( NO, threads. code ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( NO, threads. code ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_2.txt",
  "assertion": "assertEquals ( 3, 0. length ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 3, 0. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "76_20.txt",
  "assertion": "assertEquals ( 20, translations. rank ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 20, translations. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_21.txt",
  "assertion": "assertEquals ( 16, Task. sum ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 16, Task. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_22.txt",
  "assertion": "assertEquals ( empty, responses. limit ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( empty, responses. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_23.txt",
  "assertion": "assertEquals ( no, levels. order ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( no, levels. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_24.txt",
  "assertion": "assertEquals ( 50, \"\". len ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 50, \"\". len ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_25.txt",
  "assertion": "assertEquals ( False, elements.Empty ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( False, elements.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_26.txt",
  "assertion": "assertEquals ( Zero, results. clone ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( Zero, results. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_27.txt",
  "assertion": "assertEquals ( 200, credits. poll ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 200, credits. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_28.txt",
  "assertion": "assertEquals ( n, ones. remove ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( n, ones. remove ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_29.txt",
  "assertion": "assertEquals ( No, networks. zero ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( No, networks. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_3.txt",
  "assertion": "assertEquals ( 2, activities. empty ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 2, activities. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_4.txt",
  "assertion": "assertEquals ( 4,asks.size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 4,asks.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_5.txt",
  "assertion": "assertEquals ( 5, pools.Size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 5, pools.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_6.txt",
  "assertion": "assertEquals (0, tags. Size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (0, tags. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_7.txt",
  "assertion": "assertEquals ( \"\", tabs. sizes ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( \"\", tabs. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_8.txt",
  "assertion": "assertEquals ( None, tokens. index ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( None, tokens. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "76_9.txt",
  "assertion": "assertEquals ( 7, errors. values ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 7, errors. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 5, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_0.txt",
  "assertion": "assertEquals ( 0, tasks. size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 0, tasks. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_1.txt",
  "assertion": "assertEquals ( 1, task. count ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 1, task. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_10.txt",
  "assertion": "assertEquals ( 10, files. number ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 10, files. number ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_11.txt",
  "assertion": "assertEquals ( 6, items. 0 ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 6, items. 0 ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "77_12.txt",
  "assertion": "assertEquals ( 9, values. capacity ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 9, values. capacity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_13.txt",
  "assertion": "assertEquals ( zero, messages. body ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( zero, messages. body ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_14.txt",
  "assertion": "assertEquals ( N, workers. sized ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( N, workers. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_15.txt",
  "assertion": "assertEquals ( 100, content. first ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 100, content. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_16.txt",
  "assertion": "assertEquals ( false, strings. list ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( false, strings. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_17.txt",
  "assertion": "assertEquals ( 8, keys. depth ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 8, keys. depth ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_18.txt",
  "assertion": "assertEquals ( null, null. height ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( null, null. height ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_19.txt",
  "assertion": "assertEquals ( NO, threads. code ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( NO, threads. code ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_2.txt",
  "assertion": "assertEquals ( 3, 0. length ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 3, 0. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "77_20.txt",
  "assertion": "assertEquals ( 20, translations. rank ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 20, translations. rank ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_21.txt",
  "assertion": "assertEquals ( 16, Task. sum ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 16, Task. sum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_22.txt",
  "assertion": "assertEquals ( empty, responses. limit ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( empty, responses. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_23.txt",
  "assertion": "assertEquals ( no, levels. order ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( no, levels. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_24.txt",
  "assertion": "assertEquals ( 50, \"\". len ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 50, \"\". len ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_25.txt",
  "assertion": "assertEquals ( False, elements.Empty ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( False, elements.Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_26.txt",
  "assertion": "assertEquals ( Zero, results. clone ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( Zero, results. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_27.txt",
  "assertion": "assertEquals ( 200, credits. poll ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 200, credits. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_28.txt",
  "assertion": "assertEquals ( n, ones. remove ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( n, ones. remove ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_29.txt",
  "assertion": "assertEquals ( No, networks. zero ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( No, networks. zero ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_3.txt",
  "assertion": "assertEquals ( 2, activities. empty ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 2, activities. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_4.txt",
  "assertion": "assertEquals ( 4,asks.size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 4,asks.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_5.txt",
  "assertion": "assertEquals ( 5, pools.Size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 5, pools.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_6.txt",
  "assertion": "assertEquals (0, tags. Size ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (0, tags. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_7.txt",
  "assertion": "assertEquals ( \"\", tabs. sizes ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( \"\", tabs. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_8.txt",
  "assertion": "assertEquals ( None, tokens. index ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( None, tokens. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "77_9.txt",
  "assertion": "assertEquals ( 7, errors. values ( ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 7, errors. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( 1, tasks. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "78_0.txt",
  "assertion": "assertTrue ( editAdded [ 0 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( editAdded [ 0 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_1.txt",
  "assertion": "assertTrue ( editingAdd [ 1 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( editingAdd [ 1 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_10.txt",
  "assertion": "assertTrue ( checkSet [ 6 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( checkSet [ 6 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_11.txt",
  "assertion": "assertTrue ( updateJoined [ 9 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( updateJoined [ 9 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_12.txt",
  "assertion": "assertTrue ( editsEnabled [ 4 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( editsEnabled [ 4 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_13.txt",
  "assertion": "assertTrue ( createChanged [ 8 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( createChanged [ 8 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_14.txt",
  "assertion": "assertTrue ( cutCompared [ : ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( cutCompared [ : ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_15.txt",
  "assertion": "assertTrue ( assignDone [ \"\" ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( assignDone [ \"\" ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_16.txt",
  "assertion": "assertTrue ( cpPosted [ first ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( cpPosted [ first ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_17.txt",
  "assertion": "assertTrue ( scriptAtt [ start ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( scriptAtt [ start ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_18.txt",
  "assertion": "assertTrue (!Updated [ k ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue (!Updated [ k ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_19.txt",
  "assertion": "assertTrue ( removeHidden [ j ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( removeHidden [ j ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_2.txt",
  "assertion": "assertTrue ( editor added [0 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( editor added [0 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_20.txt",
  "assertion": "assertTrue ( acceptAdditional [ 20 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( acceptAdditional [ 20 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_21.txt",
  "assertion": "assertTrue ( adjustSupported [ 11 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( adjustSupported [ 11 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_22.txt",
  "assertion": "assertTrue ( statored [ zero ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( statored [ zero ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_23.txt",
  "assertion": "assertTrue ( fixPos [ 15 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( fixPos [ 15 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_24.txt",
  "assertion": "assertTrue ( EDITWas [ false ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( EDITWas [ false ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_25.txt",
  "assertion": "assertTrue ( toggleRegistered [ script ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( toggleRegistered [ script ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_26.txt",
  "assertion": "assertTrue ( readEdited [ 42 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( readEdited [ 42 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_27.txt",
  "assertion": "assertTrue ( $Used [ mode ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( $Used [ mode ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_28.txt",
  "assertion": "assertTrue ( filterWritten [ offset ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( filterWritten [ offset ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_29.txt",
  "assertion": "assertTrue ( pollBased [ 16 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( pollBased [ 16 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_3.txt",
  "assertion": "assertTrue ( writeAdding [ 2 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( writeAdding [ 2 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_4.txt",
  "assertion": "assertTrue ( add Added [ 7 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( add Added [ 7 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "78_5.txt",
  "assertion": "assertTrue ( selectadded [ 5 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( selectadded [ 5 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_6.txt",
  "assertion": "assertTrue ( execAdds [ i ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( execAdds [ i ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_7.txt",
  "assertion": "assertTrue ( deleteRemoved [ 50 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( deleteRemoved [ 50 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_8.txt",
  "assertion": "assertTrue ( testCreated [ 3 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( testCreated [ 3 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "78_9.txt",
  "assertion": "assertTrue ( EditList [ 10 ] )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertTrue ( EditList [ 10 ] ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertTrue ( editAdded [ 0 ] )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_0.txt",
  "assertion": "assertFalse ( validAssert )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( validAssert ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_1.txt",
  "assertion": "assertFalse (Valid AssERT )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse (Valid AssERT ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_10.txt",
  "assertion": "assertFalse ( validationAlTrue )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( validationAlTrue ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_11.txt",
  "assertion": "assertFalse ( invalidIser )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( invalidIser ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_12.txt",
  "assertion": "assertFalse ( correctDefT )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( correctDefT ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_13.txt",
  "assertion": "assertFalse ( validatedPresust )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( validatedPresust ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_14.txt",
  "assertion": "assertFalse ( valCalrypt )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( valCalrypt ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_15.txt",
  "assertion": "assertFalse ( certTrueign )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( certTrueign ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_16.txt",
  "assertion": "assertFalse ( saneIsset )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( saneIsset ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_17.txt",
  "assertion": "assertFalse ( valueValidit )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( valueValidit ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_18.txt",
  "assertion": "assertFalse ( getTrustxt )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( getTrustxt ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_19.txt",
  "assertion": "assertFalse ( activeAttidate )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( activeAttidate ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_2.txt",
  "assertion": "assertFalse ( Validassassert )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( Validassassert ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_20.txt",
  "assertion": "assertFalse ( 0All true )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( 0All true ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_21.txt",
  "assertion": "assertFalse ( authenticJuster )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( authenticJuster ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_22.txt",
  "assertion": "assertFalse ( newSt )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( newSt ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_23.txt",
  "assertion": "assertFalse ( cleanAccTrust )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( cleanAccTrust ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_24.txt",
  "assertion": "assertFalse ( fixTestuer )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( fixTestuer ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_25.txt",
  "assertion": "assertFalse (validPos_ )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse (validPos_ ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_26.txt",
  "assertion": "assertFalse ( validityResite )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( validityResite ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_27.txt",
  "assertion": "assertFalse ( okertig )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( okertig ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_28.txt",
  "assertion": "assertFalse ( safe reassure )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( safe reassure ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_29.txt",
  "assertion": "assertFalse ( (T ( )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( (T ( ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_3.txt",
  "assertion": "assertFalse ( validate assist )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( validate assist ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_4.txt",
  "assertion": "assertFalse ( goodASSett )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( goodASSett ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_5.txt",
  "assertion": "assertFalse ( legalAsect )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( legalAsect ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_6.txt",
  "assertion": "assertFalse ( isConsest )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( isConsest ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_7.txt",
  "assertion": "assertFalse ( trueGuCert )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( trueGuCert ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "79_8.txt",
  "assertion": "assertFalse ( check ASSume )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( check ASSume ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "79_9.txt",
  "assertion": "assertFalse ( badP assert )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertFalse ( badP assert ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertFalse ( validAssert )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "7_0.txt",
  "assertion": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, timer. getWaitTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_1.txt",
  "assertion": "assertEquals ( 1, 0. Get wait time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, 0. Get wait time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "7_10.txt",
  "assertion": "assertEquals ( 20, os. minQueueTim ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 20, os. minQueueTim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_11.txt",
  "assertion": "assertEquals ( 200, 2. gettingHolder ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 200, 2. gettingHolder ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "7_12.txt",
  "assertion": "assertEquals ( 8, timeout. gSleepMemory ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, timeout. gSleepMemory ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_13.txt",
  "assertion": "assertEquals ( i, 1. availableAcceptNow ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( i, 1. availableAcceptNow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "7_14.txt",
  "assertion": "assertEquals ( time, system. totalUtCount ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( time, system. totalUtCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_15.txt",
  "assertion": "assertEquals ( min, alarm. groupaitTimeout ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( min, alarm. groupaitTimeout ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_16.txt",
  "assertion": "assertEquals ( None, EM. sizeDurationClock ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( None, EM. sizeDurationClock ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_17.txt",
  "assertion": "assertEquals ( 50, settings. countBufferFire ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 50, settings. countBufferFire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_18.txt",
  "assertion": "assertEquals ( 6, counter. newMustWeight ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 6, counter. newMustWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_19.txt",
  "assertion": "assertEquals ( 30, times. eventMaxMill ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 30, times. eventMaxMill ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_2.txt",
  "assertion": "assertEquals ( 2, System.get Waittime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, System.get Waittime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "7_20.txt",
  "assertion": "assertEquals ( \"\", runtime. _TimeT ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \"\", runtime. _TimeT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_21.txt",
  "assertion": "assertEquals ( 10000, self. calculateJoinWork ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10000, self. calculateJoinWork ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_22.txt",
  "assertion": "assertEquals ( 7, sys. incrementQFit ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, sys. incrementQFit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_23.txt",
  "assertion": "assertEquals ( 15, countdown. numberAllowed ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 15, countdown. numberAllowed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_24.txt",
  "assertion": "assertEquals ( timer, event. pollDel times ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( timer, event. pollDel times ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "7_25.txt",
  "assertion": "assertEquals ( 5000, duration. timerDateNice ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5000, duration. timerDateNice ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_26.txt",
  "assertion": "assertEquals ( 60, Time. timeoutDefaultVal ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 60, Time. timeoutDefaultVal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_27.txt",
  "assertion": "assertEquals ( zero, util. defaultGetLong ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( zero, util. defaultGetLong ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_28.txt",
  "assertion": "assertEquals ( 500, global. guessRequestStyle ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 500, global. guessRequestStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_29.txt",
  "assertion": "assertEquals (0, C. randomStatusSound ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (0, C. randomStatusSound ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_3.txt",
  "assertion": "assertEquals ( 3, this. currentWa Time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, this. currentWa Time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "7_4.txt",
  "assertion": "assertEquals ( 1000, time. getsSendTimer ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1000, time. getsSendTimer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_5.txt",
  "assertion": "assertEquals ( 4, timers. timewaitThread ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, timers. timewaitThread ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_6.txt",
  "assertion": "assertEquals ( 10, Clock. givenDaTimes ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10, Clock. givenDaTimes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_7.txt",
  "assertion": "assertEquals ( 5, clock. maxEventime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5, clock. maxEventime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_8.txt",
  "assertion": "assertEquals ( 100, timing. gotTotalValue ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 100, timing. gotTotalValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "7_9.txt",
  "assertion": "assertEquals ( 2000, timed. globalListenSize ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2000, timed. globalListenSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 5, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "80_0.txt",
  "assertion": "assertEquals ( expected, expected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expected, expected ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_1.txt",
  "assertion": "assertEquals ( ), listed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( ), listed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_10.txt",
  "assertion": "assertEquals ( existing, needed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( existing, needed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_11.txt",
  "assertion": "assertEquals ( given, existing )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( given, existing ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_12.txt",
  "assertion": "assertEquals (expected, passed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (expected, passed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "expected",
  "parse_context": "finished",
  "correct answer": "false",
  "result": ""
}
,
{
  "file": "80_13.txt",
  "assertion": "assertEquals ( observed, desired )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( observed, desired ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_14.txt",
  "assertion": "assertEquals ( expecting, required )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( expecting, required ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_15.txt",
  "assertion": "assertEquals ( desired, written )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( desired, written ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_16.txt",
  "assertion": "assertEquals ( header, allowed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( header, allowed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_17.txt",
  "assertion": "assertEquals ( ordered, ordered )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( ordered, ordered ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_18.txt",
  "assertion": "assertEquals ( list, recommended )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( list, recommended ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_19.txt",
  "assertion": "assertEquals ( assumed, contained )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( assumed, contained ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_2.txt",
  "assertion": "assertEquals ( listed, actual )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( listed, actual ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_20.txt",
  "assertion": "assertEquals ( supposed, failed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( supposed, failed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_21.txt",
  "assertion": "assertEquals ( failed, assumed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( failed, assumed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_22.txt",
  "assertion": "assertEquals ( }, values )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( }, values ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_23.txt",
  "assertion": "assertEquals ( 0, got )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( 0, got ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_24.txt",
  "assertion": "assertEquals (ed, provided )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (ed, provided ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_25.txt",
  "assertion": "assertEquals ( found, returned )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( found, returned ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_26.txt",
  "assertion": "assertEquals ( passed, attributed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( passed, attributed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_27.txt",
  "assertion": "assertEquals (,),pected )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (,),pected ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_28.txt",
  "assertion": "assertEquals ( acceptable, supplied )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( acceptable, supplied ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_29.txt",
  "assertion": "assertEquals ( declared, formed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( declared, formed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_3.txt",
  "assertion": "assertEquals ( required, ) )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( required, ) ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_4.txt",
  "assertion": "assertEquals ( actual, found )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( actual, found ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_5.txt",
  "assertion": "assertEquals (), calculated )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (), calculated ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "80_6.txt",
  "assertion": "assertEquals ( needed, missing )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( needed, missing ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_7.txt",
  "assertion": "assertEquals (pected, list )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals (pected, list ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_8.txt",
  "assertion": "assertEquals ( allowed, given )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( allowed, given ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "80_9.txt",
  "assertion": "assertEquals ( missing, observed )\r\n",
  "test": "class X {public void test10 ( ) { String code \u003d \"a\u003csp\u003e\u003d\u003csp\u003e!(2\u003csp\u003e|\u003csp\u003e2\u003csp\u003exor\u003csp\u003e2\u003csp\u003e*\u003csp\u003e2)\" ; String expected \u003d \"2\u003csp\u003e2\u003csp\u003eMUL\u003csp\u003e2\u003csp\u003eXOR\u003csp\u003e2\u003csp\u003eOR\u003csp\u003eNOT\u003csp\u003e0\u003csp\u003eMSTORE\" ; SerpentParser parser \u003d ParserUtils . getParser ( SerpentLexer . class , SerpentParser . class , code ) ; ParseTree tree \u003d parser . parse ( ) ; String result \u003d new SerpentToAssemblyCompiler ( ) . visit ( tree ) ; result \u003d result . replaceAll ( \"\\\\s+\" , \"\u003csp\u003e\" ) ; result \u003d result . trim ( ) ; assertEquals ( missing, observed ) ; } }\r\n",
  "focal method": "class Y{ public void parse ( ) { RLPList paramsList \u003d ( ( RLPList ) ( RLP . decode2 ( encoded ) . RLP . get ( 0 ) ) ) ; blockHashes \u003d new ArrayList ( ) ; for ( int i \u003d 1 ; i \u003c ( paramsList . size ( ) ) ; ++ i ) { RLPItem rlpData \u003d ( ( RLPItem ) ( paramsList . get ( i ) ) ) ; blockHashes . add ( rlpData . getRLPData ( ) ) ; } parsed \u003d true ; } }\r\n",
  "truth": "assertEquals ( expected, listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_0.txt",
  "assertion": "assertNotNull ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_1.txt",
  "assertion": "assertNotNull ( expected )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( expected ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_10.txt",
  "assertion": "assertNotNull ( calculated )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( calculated ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_11.txt",
  "assertion": "assertNotNull ( )) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( )) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_12.txt",
  "assertion": "assertNotNull ( list )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( list ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_13.txt",
  "assertion": "assertNotNull ( needed )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( needed ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_14.txt",
  "assertion": "assertNotNull ( recommended )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( recommended ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_15.txt",
  "assertion": "assertNotNull ( result )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "find type in test": "result",
  "parse context": "finished",
  "correct answer": "false",
  "result": "Good assertion"
}
,
{
  "file": "81_16.txt",
  "assertion": "assertNotNull (+) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull (+) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_17.txt",
  "assertion": "assertNotNull ()\u003d )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ()\u003d ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_18.txt",
  "assertion": "assertNotNull ( acknowledged )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( acknowledged ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_19.txt",
  "assertion": "assertNotNull ( admitted )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( admitted ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_2.txt",
  "assertion": "assertNotNull ( listed )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( listed ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_20.txt",
  "assertion": "assertNotNull ( header )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( header ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_21.txt",
  "assertion": "assertNotNull ( missing )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( missing ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_22.txt",
  "assertion": "assertNotNull ( } )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( } ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_23.txt",
  "assertion": "assertNotNull ( *) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( *) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_24.txt",
  "assertion": "assertNotNull ( input )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( input ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_25.txt",
  "assertion": "assertNotNull ( failed )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( failed ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_26.txt",
  "assertion": "assertNotNull ( succeeded )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( succeeded ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_27.txt",
  "assertion": "assertNotNull (*) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull (*) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_28.txt",
  "assertion": "assertNotNull ( provided )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( provided ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_29.txt",
  "assertion": "assertNotNull ( desired )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( desired ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_3.txt",
  "assertion": "assertNotNull ()) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ()) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_4.txt",
  "assertion": "assertNotNull () )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull () ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "81_5.txt",
  "assertion": "assertNotNull ( true )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( true ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_6.txt",
  "assertion": "assertNotNull ( required )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( required ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_7.txt",
  "assertion": "assertNotNull ( contained )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( contained ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_8.txt",
  "assertion": "assertNotNull ( passed )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( passed ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "81_9.txt",
  "assertion": "assertNotNull ( observed )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertNotNull ( observed ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertNotNull ( listed )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "82_0.txt",
  "assertion": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( bloomFilter2. contains ( hash ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_1.txt",
  "assertion": "assertTrue ( Bloom filter1. matches ( filter ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( Bloom filter1. matches ( filter ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_10.txt",
  "assertion": "assertTrue ( dryfChain. retain ( \"\" ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( dryfChain. retain ( \"\" ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_11.txt",
  "assertion": "assertTrue ( trueHashCache. includes ( id ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( trueHashCache. includes ( id ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_12.txt",
  "assertion": "assertTrue ( 0RCompare. holds ( sum ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( 0RCompare. holds ( sum ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_13.txt",
  "assertion": "assertTrue ( blobFlinder. add ( num ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( blobFlinder. add ( num ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_14.txt",
  "assertion": "assertTrue ( bcMatchfilter. validate ( signature ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( bcMatchfilter. validate ( signature ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_15.txt",
  "assertion": "assertTrue ( wildValidB. remove ( 2 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( wildValidB. remove ( 2 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_16.txt",
  "assertion": "assertTrue ( 2FacFactory. covers ( i ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( 2FacFactory. covers ( i ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_17.txt",
  "assertion": "assertTrue ( combField ). test ( h ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( combField ). test ( h ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_18.txt",
  "assertion": "assertTrue ( blackTerm5. dominates ( true ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( blackTerm5. dominates ( true ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_19.txt",
  "assertion": "assertTrue ( lumBloomMatch. containing ( update ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( lumBloomMatch. containing ( update ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_2.txt",
  "assertion": "assertTrue (BloomfilterFilter. Contains ( 1 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue (BloomfilterFilter. Contains ( 1 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_20.txt",
  "assertion": "assertTrue ( lamFunctionout. supports ( value ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( lamFunctionout. supports ( value ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_21.txt",
  "assertion": "assertTrue ( blM_. exists ( 128 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( blM_. exists ( 128 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_22.txt",
  "assertion": "assertTrue ( gasUtServer. permits ( seed ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( gasUtServer. permits ( seed ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_23.txt",
  "assertion": "assertTrue ( 4PropImage. incorporates ( block ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( 4PropImage. incorporates ( block ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_24.txt",
  "assertion": "assertTrue ( probeHandler. accept ( header ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( probeHandler. accept ( header ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_25.txt",
  "assertion": "assertTrue ( amContentDelete. match ( input ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( amContentDelete. match ( input ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_26.txt",
  "assertion": "assertTrue ( $Listenerto. filters ( burn ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( $Listenerto. filters ( burn ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_27.txt",
  "assertion": "assertTrue ( 3FsDB. removes ( 3 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( 3FsDB. removes ( 3 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_28.txt",
  "assertion": "assertTrue ( binaryParser256. applies ( node ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( binaryParser256. applies ( node ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_29.txt",
  "assertion": "assertTrue ( blu filterssecond. contained ( 31 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( blu filterssecond. contained ( 31 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_3.txt",
  "assertion": "assertTrue ( filterFil4. equals ( hashing ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( filterFil4. equals ( hashing ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_4.txt",
  "assertion": "assertTrue (! Filter3. accepts ( 0 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue (! Filter3. accepts ( 0 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "82_5.txt",
  "assertion": "assertTrue ( bitFSecond. filter ( null ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( bitFSecond. filter ( null ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_6.txt",
  "assertion": "assertTrue ( (ExtTest. contain ( Hash ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( (ExtTest. contain ( Hash ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_7.txt",
  "assertion": "assertTrue ( binFF 2.ains ( digest ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( binFF 2.ains ( digest ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "82_8.txt",
  "assertion": "assertTrue ( hashCondition0. satisfies ( salt ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( hashCondition0. satisfies ( salt ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "82_9.txt",
  "assertion": "assertTrue ( 1BitTwo. implies (hash ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertTrue ( 1BitTwo. implies (hash ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertTrue ( bloomFilter2. contains ( hash ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_0.txt",
  "assertion": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bid1. equals ( bid2 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_1.txt",
  "assertion": "assertFalse ( bidding2. eq ( bidding1 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bidding2. eq ( bidding1 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_10.txt",
  "assertion": "assertFalse ( sid this. conflicts ( bb ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( sid this. conflicts ( bb ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_11.txt",
  "assertion": "assertFalse ( midTwo.equal ( midB ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( midTwo.equal ( midB ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_12.txt",
  "assertion": "assertFalse ( ( ). contains ( bit12 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( ( ). contains ( bit12 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_13.txt",
  "assertion": "assertFalse ( bondName. identical ( auctiontwo ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bondName. identical ( auctiontwo ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_14.txt",
  "assertion": "assertFalse ( bitb. EQ ( bias8 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bitb. EQ ( bias8 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_15.txt",
  "assertion": "assertFalse ( $one. Equ ( aid10 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( $one. Equ ( aid10 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_16.txt",
  "assertion": "assertFalse ( term11.equ ( bondi ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( term11.equ ( bondi ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_17.txt",
  "assertion": "assertFalse ( auctionX. implies ( dabID ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( auctionX. implies ( dabID ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_18.txt",
  "assertion": "assertFalse ( biasONE. EQU ( vote 1 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( biasONE. EQU ( vote 1 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_19.txt",
  "assertion": "assertFalse ( adI. equ ( term11 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( adI. equ ( term11 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_2.txt",
  "assertion": "assertFalse ( bids3. equal ( bids3 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bids3. equal ( bids3 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_20.txt",
  "assertion": "assertFalse ( bin6. compares ( bud6 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bin6. compares ( bud6 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_21.txt",
  "assertion": "assertFalse ( husband8. equivalents ( billOther ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( husband8. equivalents ( billOther ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_22.txt",
  "assertion": "assertFalse ( my one. is ( my22 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( my one. is ( my22 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_23.txt",
  "assertion": "assertFalse ( boTo. same ( answerTo ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( boTo. same ( answerTo ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_24.txt",
  "assertion": "assertFalse ( voteON. contradicts ( pad ) ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( voteON. contradicts ( pad ) ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_25.txt",
  "assertion": "assertFalse ( biThis. likes ( bail second ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( biThis. likes ( bail second ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_26.txt",
  "assertion": "assertFalse ( IDB. unequal ( buyid ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( IDB. unequal ( buyid ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_27.txt",
  "assertion": "assertFalse ( bleValue. evaluates ( binOne ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bleValue. evaluates ( binOne ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_28.txt",
  "assertion": "assertFalse ( soc7. accepts ( bleII ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( soc7. accepts ( bleII ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_29.txt",
  "assertion": "assertFalse ( aid10.qual ( adite ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( aid10.qual ( adite ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_3.txt",
  "assertion": "assertFalse ( Bid4. Equal ( Bid4 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( Bid4. Equal ( Bid4 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_4.txt",
  "assertion": "assertFalse ( id 1.als ( idTwo ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( id 1.als ( idTwo ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_5.txt",
  "assertion": "assertFalse ( tidOne. matches ( sid 2 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( tidOne. matches ( sid 2 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_6.txt",
  "assertion": "assertFalse ( b 2. \u003d\u003d ( tid0 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( b 2. \u003d\u003d ( tid0 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "83_7.txt",
  "assertion": "assertFalse ( bidder0. equivalent (bid5 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( bidder0. equivalent (bid5 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_8.txt",
  "assertion": "assertFalse (bid5. equality ( lidSecond ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse (bid5. equality ( lidSecond ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "83_9.txt",
  "assertion": "assertFalse ( lid01. compare ( bidder02 ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertFalse ( lid01. compare ( bidder02 ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertFalse ( bid1. equals ( bid2 ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_0.txt",
  "assertion": "assertEquals ( \"\", this. getFileCount ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( \"\", this. getFileCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_1.txt",
  "assertion": "assertEquals ( 1, System.getRuleSet ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 1, System.getRuleSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_10.txt",
  "assertion": "assertEquals ( \", File. addTaskRule ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( \", File. addTaskRule ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "84_11.txt",
  "assertion": "assertEquals ( rule, Test. groupSourceFileContent ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( rule, Test. groupSourceFileContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_12.txt",
  "assertion": "assertEquals ( 8, Boolean. calculate FileId ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 8, Boolean. calculate FileId ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "84_13.txt",
  "assertion": "assertEquals ( Rule, Default. removeLineRuntime ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( Rule, Default. removeLineRuntime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_14.txt",
  "assertion": "assertEquals ( Default, test. baseClassType ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( Default, test. baseClassType ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_15.txt",
  "assertion": "assertEquals ( TRUE, Task. currentMessageCondition ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( TRUE, Task. currentMessageCondition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_16.txt",
  "assertion": "assertEquals ( 9, Pattern. extractURange ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 9, Pattern. extractURange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_17.txt",
  "assertion": "assertEquals ( NAME, Empty. exportEffectiveMatch ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( NAME, Empty. exportEffectiveMatch ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_18.txt",
  "assertion": "assertEquals ( ALL, Config. generateNodeRun ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( ALL, Config. generateNodeRun ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_19.txt",
  "assertion": "assertEquals ( 5, Build. trimCheckCall ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 5, Build. trimCheckCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_2.txt",
  "assertion": "assertEquals ( 2, Project. Getfile count ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 2, Project. Getfile count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "84_20.txt",
  "assertion": "assertEquals ( ONE, Statement. findSimpleNum ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( ONE, Statement. findSimpleNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_21.txt",
  "assertion": "assertEquals ( Null, Report. sourceDefaultThrow ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( Null, Report. sourceDefaultThrow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_22.txt",
  "assertion": "assertEquals ( empty, file. fileVarity ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( empty, file. fileVarity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_23.txt",
  "assertion": "assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "84_24.txt",
  "assertion": "assertEquals ( expect, Review. gStringWeight ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( expect, Review. gStringWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_25.txt",
  "assertion": "assertEquals ( [, Analysis. uResourceSum ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( [, Analysis. uResourceSum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "84_26.txt",
  "assertion": "assertEquals ( NEW, Setting. compileValueAt ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( NEW, Setting. compileValueAt ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_27.txt",
  "assertion": "assertEquals ( undefined, Optional. resolveTokenEmpty ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( undefined, Optional. resolveTokenEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_28.txt",
  "assertion": "assertEquals ( Empty, Block. buildMemberCounter ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( Empty, Block. buildMemberCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_29.txt",
  "assertion": "assertEquals ( FALSE, report. isPathContainer ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( FALSE, report. isPathContainer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_3.txt",
  "assertion": "assertEquals ( 0, Rule. toFilescount ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 0, Rule. toFilescount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_4.txt",
  "assertion": "assertEquals ( 3, rule. getsTestName ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 3, rule. getsTestName ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_5.txt",
  "assertion": "assertEquals ( expected, project. newRulesNumber ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( expected, project. newRulesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_6.txt",
  "assertion": "assertEquals ( 4, \"\". ruleModulePath ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( 4, \"\". ruleModulePath ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_7.txt",
  "assertion": "assertEquals ( null, null. asEmailSize ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( null, null. asEmailSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_8.txt",
  "assertion": "assertEquals ( None, Runtime. unValidClass ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( None, Runtime. unValidClass ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "84_9.txt",
  "assertion": "assertEquals ( true, task. create file Count ( ) )\r\n",
  "test": "class X {public void recursiveDependencyDownloadDisabled ( ) { peer . setDownloadTxDependencies ( false ) ; connect ( ) ; Transaction tx \u003d FakeTxBuilder . createFakeTx ( address ) ; final Transaction [ ] result \u003d new Transaction [ 1 ] ; wallet . addCoinsReceivedEventListener ( new WalletCoinsReceivedEventListener ( ) { @ org . bitcoinj . core . Override public void onCoinsReceived ( Wallet wallet , Transaction tx , Coin prevBalance , Coin newBalance ) { result [ 0 ] \u003d tx ; } } ) ; inbound ( writeTarget , tx ) ; pingAndWait ( writeTarget ) ; assertEquals ( true, task. create file Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void pingAndWait ( InboundMessageQueuer var24678 ) { final long nonce \u003d ( ( long ) ( ( Math . random ( ) ) * ( Long . MAX_VALUE ) ) ) ; inboundPongAndWait ( p , nonce ) ; outboundPingAndWait ( p , nonce ) ; } }\r\n",
  "truth": "assertEquals ( 1, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "85_0.txt",
  "assertion": "assertEquals ( \"\", this. getFileCount ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( \"\", this. getFileCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_1.txt",
  "assertion": "assertEquals ( 1, System.getRuleSet ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 1, System.getRuleSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_10.txt",
  "assertion": "assertEquals ( \", File. addTaskRule ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( \", File. addTaskRule ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "85_11.txt",
  "assertion": "assertEquals ( rule, Test. groupSourceFileContent ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( rule, Test. groupSourceFileContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_12.txt",
  "assertion": "assertEquals ( 8, Boolean. calculate FileId ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 8, Boolean. calculate FileId ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "85_13.txt",
  "assertion": "assertEquals ( Rule, Default. removeLineRuntime ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Rule, Default. removeLineRuntime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_14.txt",
  "assertion": "assertEquals ( Default, test. baseClassType ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Default, test. baseClassType ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_15.txt",
  "assertion": "assertEquals ( TRUE, Task. currentMessageCondition ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( TRUE, Task. currentMessageCondition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_16.txt",
  "assertion": "assertEquals ( 9, Pattern. extractURange ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 9, Pattern. extractURange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_17.txt",
  "assertion": "assertEquals ( NAME, Empty. exportEffectiveMatch ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( NAME, Empty. exportEffectiveMatch ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_18.txt",
  "assertion": "assertEquals ( ALL, Config. generateNodeRun ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( ALL, Config. generateNodeRun ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_19.txt",
  "assertion": "assertEquals ( 5, Build. trimCheckCall ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 5, Build. trimCheckCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_2.txt",
  "assertion": "assertEquals ( 2, Project. Getfile count ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 2, Project. Getfile count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "85_20.txt",
  "assertion": "assertEquals ( ONE, Statement. findSimpleNum ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( ONE, Statement. findSimpleNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_21.txt",
  "assertion": "assertEquals ( Null, Report. sourceDefaultThrow ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Null, Report. sourceDefaultThrow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_22.txt",
  "assertion": "assertEquals ( empty, file. fileVarity ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( empty, file. fileVarity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_23.txt",
  "assertion": "assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "85_24.txt",
  "assertion": "assertEquals ( expect, Review. gStringWeight ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( expect, Review. gStringWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_25.txt",
  "assertion": "assertEquals ( [, Analysis. uResourceSum ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( [, Analysis. uResourceSum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "85_26.txt",
  "assertion": "assertEquals ( NEW, Setting. compileValueAt ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( NEW, Setting. compileValueAt ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_27.txt",
  "assertion": "assertEquals ( undefined, Optional. resolveTokenEmpty ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( undefined, Optional. resolveTokenEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_28.txt",
  "assertion": "assertEquals ( Empty, Block. buildMemberCounter ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Empty, Block. buildMemberCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_29.txt",
  "assertion": "assertEquals ( FALSE, report. isPathContainer ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( FALSE, report. isPathContainer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_3.txt",
  "assertion": "assertEquals ( 0, Rule. toFilescount ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 0, Rule. toFilescount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_4.txt",
  "assertion": "assertEquals ( 3, rule. getsTestName ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 3, rule. getsTestName ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_5.txt",
  "assertion": "assertEquals ( expected, project. newRulesNumber ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( expected, project. newRulesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_6.txt",
  "assertion": "assertEquals ( 4, \"\". ruleModulePath ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 4, \"\". ruleModulePath ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_7.txt",
  "assertion": "assertEquals ( null, null. asEmailSize ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( null, null. asEmailSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_8.txt",
  "assertion": "assertEquals ( None, Runtime. unValidClass ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( None, Runtime. unValidClass ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "85_9.txt",
  "assertion": "assertEquals ( true, task. create file Count ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( true, task. create file Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 5, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "86_0.txt",
  "assertion": "assertEquals ( \"\", this. getFileCount ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( \"\", this. getFileCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_1.txt",
  "assertion": "assertEquals ( 1, System.getRuleSet ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 1, System.getRuleSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_10.txt",
  "assertion": "assertEquals ( \", File. addTaskRule ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( \", File. addTaskRule ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "86_11.txt",
  "assertion": "assertEquals ( rule, Test. groupSourceFileContent ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( rule, Test. groupSourceFileContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_12.txt",
  "assertion": "assertEquals ( 8, Boolean. calculate FileId ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 8, Boolean. calculate FileId ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "86_13.txt",
  "assertion": "assertEquals ( Rule, Default. removeLineRuntime ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Rule, Default. removeLineRuntime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_14.txt",
  "assertion": "assertEquals ( Default, test. baseClassType ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Default, test. baseClassType ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_15.txt",
  "assertion": "assertEquals ( TRUE, Task. currentMessageCondition ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( TRUE, Task. currentMessageCondition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_16.txt",
  "assertion": "assertEquals ( 9, Pattern. extractURange ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 9, Pattern. extractURange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_17.txt",
  "assertion": "assertEquals ( NAME, Empty. exportEffectiveMatch ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( NAME, Empty. exportEffectiveMatch ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_18.txt",
  "assertion": "assertEquals ( ALL, Config. generateNodeRun ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( ALL, Config. generateNodeRun ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_19.txt",
  "assertion": "assertEquals ( 5, Build. trimCheckCall ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 5, Build. trimCheckCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_2.txt",
  "assertion": "assertEquals ( 2, Project. Getfile count ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 2, Project. Getfile count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "86_20.txt",
  "assertion": "assertEquals ( ONE, Statement. findSimpleNum ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( ONE, Statement. findSimpleNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_21.txt",
  "assertion": "assertEquals ( Null, Report. sourceDefaultThrow ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Null, Report. sourceDefaultThrow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_22.txt",
  "assertion": "assertEquals ( empty, file. fileVarity ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( empty, file. fileVarity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_23.txt",
  "assertion": "assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "86_24.txt",
  "assertion": "assertEquals ( expect, Review. gStringWeight ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( expect, Review. gStringWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_25.txt",
  "assertion": "assertEquals ( [, Analysis. uResourceSum ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( [, Analysis. uResourceSum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "86_26.txt",
  "assertion": "assertEquals ( NEW, Setting. compileValueAt ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( NEW, Setting. compileValueAt ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_27.txt",
  "assertion": "assertEquals ( undefined, Optional. resolveTokenEmpty ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( undefined, Optional. resolveTokenEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_28.txt",
  "assertion": "assertEquals ( Empty, Block. buildMemberCounter ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( Empty, Block. buildMemberCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_29.txt",
  "assertion": "assertEquals ( FALSE, report. isPathContainer ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( FALSE, report. isPathContainer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_3.txt",
  "assertion": "assertEquals ( 0, Rule. toFilescount ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 0, Rule. toFilescount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_4.txt",
  "assertion": "assertEquals ( 3, rule. getsTestName ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 3, rule. getsTestName ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_5.txt",
  "assertion": "assertEquals ( expected, project. newRulesNumber ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( expected, project. newRulesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_6.txt",
  "assertion": "assertEquals ( 4, \"\". ruleModulePath ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( 4, \"\". ruleModulePath ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_7.txt",
  "assertion": "assertEquals ( null, null. asEmailSize ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( null, null. asEmailSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_8.txt",
  "assertion": "assertEquals ( None, Runtime. unValidClass ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( None, Runtime. unValidClass ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "86_9.txt",
  "assertion": "assertEquals ( true, task. create file Count ( ) )\r\n",
  "test": "class X {public void formNullTest ( ) { CE \u003c String \u003e form \u003d nullDrug . substanceAdministrationHelper ( ) . nullDrug . getAdministrationUnitCode ( ) ; assertEquals ( true, task. create file Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void substanceAdministrationHelper ( Drug var24678 ) { EntryRelationship entryRelationship \u003d mpeModel . getEntryRelationship ( drug ) ; return entryRelationship . getClinicalStatementIfSubstanceAdministration ( ) ; } }\r\n",
  "truth": "assertEquals ( 0, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_0.txt",
  "assertion": "assertEquals ( \"\", this. getFileCount ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( \"\", this. getFileCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_1.txt",
  "assertion": "assertEquals ( 1, System.getRuleSet ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 1, System.getRuleSet ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_10.txt",
  "assertion": "assertEquals ( \", File. addTaskRule ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( \", File. addTaskRule ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_11.txt",
  "assertion": "assertEquals ( rule, Test. groupSourceFileContent ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( rule, Test. groupSourceFileContent ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_12.txt",
  "assertion": "assertEquals ( 8, Boolean. calculate FileId ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 8, Boolean. calculate FileId ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_13.txt",
  "assertion": "assertEquals ( Rule, Default. removeLineRuntime ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( Rule, Default. removeLineRuntime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_14.txt",
  "assertion": "assertEquals ( Default, test. baseClassType ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( Default, test. baseClassType ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_15.txt",
  "assertion": "assertEquals ( TRUE, Task. currentMessageCondition ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( TRUE, Task. currentMessageCondition ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_16.txt",
  "assertion": "assertEquals ( 9, Pattern. extractURange ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 9, Pattern. extractURange ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_17.txt",
  "assertion": "assertEquals ( NAME, Empty. exportEffectiveMatch ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( NAME, Empty. exportEffectiveMatch ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_18.txt",
  "assertion": "assertEquals ( ALL, Config. generateNodeRun ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( ALL, Config. generateNodeRun ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_19.txt",
  "assertion": "assertEquals ( 5, Build. trimCheckCall ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 5, Build. trimCheckCall ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_2.txt",
  "assertion": "assertEquals ( 2, Project. Getfile count ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 2, Project. Getfile count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_20.txt",
  "assertion": "assertEquals ( ONE, Statement. findSimpleNum ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( ONE, Statement. findSimpleNum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_21.txt",
  "assertion": "assertEquals ( Null, Report. sourceDefaultThrow ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( Null, Report. sourceDefaultThrow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_22.txt",
  "assertion": "assertEquals ( empty, file. fileVarity ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( empty, file. fileVarity ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_23.txt",
  "assertion": "assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( \u0027\u0027, Assignment. gettingSourceount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_24.txt",
  "assertion": "assertEquals ( expect, Review. gStringWeight ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( expect, Review. gStringWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_25.txt",
  "assertion": "assertEquals ( [, Analysis. uResourceSum ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( [, Analysis. uResourceSum ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "87_26.txt",
  "assertion": "assertEquals ( NEW, Setting. compileValueAt ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( NEW, Setting. compileValueAt ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_27.txt",
  "assertion": "assertEquals ( undefined, Optional. resolveTokenEmpty ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( undefined, Optional. resolveTokenEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_28.txt",
  "assertion": "assertEquals ( Empty, Block. buildMemberCounter ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( Empty, Block. buildMemberCounter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_29.txt",
  "assertion": "assertEquals ( FALSE, report. isPathContainer ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( FALSE, report. isPathContainer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_3.txt",
  "assertion": "assertEquals ( 0, Rule. toFilescount ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 0, Rule. toFilescount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_4.txt",
  "assertion": "assertEquals ( 3, rule. getsTestName ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 3, rule. getsTestName ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_5.txt",
  "assertion": "assertEquals ( expected, project. newRulesNumber ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( expected, project. newRulesNumber ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_6.txt",
  "assertion": "assertEquals ( 4, \"\". ruleModulePath ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 4, \"\". ruleModulePath ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_7.txt",
  "assertion": "assertEquals ( null, null. asEmailSize ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( null, null. asEmailSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_8.txt",
  "assertion": "assertEquals ( None, Runtime. unValidClass ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( None, Runtime. unValidClass ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "87_9.txt",
  "assertion": "assertEquals ( true, task. create file Count ( ) )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( true, task. create file Count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( 200, cmd. getFileCount ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_0.txt",
  "assertion": "assertEquals ( expected, result )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( expected, result ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_1.txt",
  "assertion": "assertEquals ( result, expected )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( result, expected ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_10.txt",
  "assertion": "assertEquals ( found, returned )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( found, returned ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_11.txt",
  "assertion": "assertEquals ( formatted, formatted )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( formatted, formatted ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_12.txt",
  "assertion": "assertEquals ( unexpected, received )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( unexpected, received ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_13.txt",
  "assertion": "assertEquals ( received, found )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( received, found ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_14.txt",
  "assertion": "assertEquals ( allowed, resulted )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( allowed, resulted ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_15.txt",
  "assertion": "assertEquals ( message, value )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( message, value ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_16.txt",
  "assertion": "assertEquals ( data, expect )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( data, expect ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_17.txt",
  "assertion": "assertEquals ( expectation, formed )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( expectation, formed ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_18.txt",
  "assertion": "assertEquals ( parsed,result )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( parsed,result ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_19.txt",
  "assertion": "assertEquals ( input, data )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( input, data ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_2.txt",
  "assertion": "assertEquals ( expecting, Result )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( expecting, Result ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_20.txt",
  "assertion": "assertEquals ( passed, allowed )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( passed, allowed ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_21.txt",
  "assertion": "assertEquals ( text, report )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( text, report ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_22.txt",
  "assertion": "assertEquals ( intended, parsed )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( intended, parsed ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_23.txt",
  "assertion": "assertEquals ( value, json )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( value, json ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_24.txt",
  "assertion": "assertEquals ( 0, unexpected )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( 0, unexpected ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_25.txt",
  "assertion": "assertEquals ( Result, passed )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( Result, passed ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_26.txt",
  "assertion": "assertEquals ( \"\", valid )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( \"\", valid ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_27.txt",
  "assertion": "assertEquals ( resulting, _ )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( resulting, _ ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_28.txt",
  "assertion": "assertEquals ( answer, length )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( answer, length ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_29.txt",
  "assertion": "assertEquals ( new, response )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( new, response ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "88_3.txt",
  "assertion": "assertEquals (pected, expecting )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals (pected, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_4.txt",
  "assertion": "assertEquals ( expect, actual )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( expect, actual ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_5.txt",
  "assertion": "assertEquals ( actual, resulting )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( actual, resulting ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_6.txt",
  "assertion": "assertEquals (expected, answer )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals (expected, answer ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_7.txt",
  "assertion": "assertEquals ( ret, message )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( ret, message ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_8.txt",
  "assertion": "assertEquals ( returned, ret )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( returned, ret ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "88_9.txt",
  "assertion": "assertEquals ( read, results )\r\n",
  "test": "class X {public void testEditPlainTiff ( ) { final LayerInfo layer \u003d getCatalog ( ) . TASMANIA_DEM . getLayerByName ( TASMANIA_DEM . getLayerId ( ) ) ; tester . startPage ( new FormTestPage ( new ComponentBuilder ( ) { public Component buildComponent ( String id ) { return new WCSEOLayerConfig ( id , new Model ( layer ) ) ; } } ) ) ; Component panel \u003d tester . getLastRenderedPage ( ) . get ( \"form:panel\" ) ; assertEquals ( read, results ) ; } }\r\n",
  "focal method": "class Y{ public void isVisible ( ) { return ( ( configurationModel ) \u003d\u003d null ) || ( ( configurationModel . getObject ( ) . getId ( ) ) !\u003d null ) ; } }\r\n",
  "truth": "assertEquals ( expected, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_0.txt",
  "assertion": "assertEquals ( expected, result )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expected, result ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_1.txt",
  "assertion": "assertEquals ( result, expected )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( result, expected ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_10.txt",
  "assertion": "assertEquals ( found, returned )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( found, returned ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_11.txt",
  "assertion": "assertEquals ( formatted, formatted )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( formatted, formatted ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_12.txt",
  "assertion": "assertEquals ( unexpected, received )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( unexpected, received ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_13.txt",
  "assertion": "assertEquals ( received, found )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( received, found ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_14.txt",
  "assertion": "assertEquals ( allowed, resulted )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( allowed, resulted ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_15.txt",
  "assertion": "assertEquals ( message, value )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( message, value ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_16.txt",
  "assertion": "assertEquals ( data, expect )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( data, expect ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_17.txt",
  "assertion": "assertEquals ( expectation, formed )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expectation, formed ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_18.txt",
  "assertion": "assertEquals ( parsed,result )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( parsed,result ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_19.txt",
  "assertion": "assertEquals ( input, data )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( input, data ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_2.txt",
  "assertion": "assertEquals ( expecting, Result )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expecting, Result ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_20.txt",
  "assertion": "assertEquals ( passed, allowed )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( passed, allowed ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_21.txt",
  "assertion": "assertEquals ( text, report )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( text, report ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_22.txt",
  "assertion": "assertEquals ( intended, parsed )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( intended, parsed ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_23.txt",
  "assertion": "assertEquals ( value, json )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( value, json ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_24.txt",
  "assertion": "assertEquals ( 0, unexpected )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 0, unexpected ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_25.txt",
  "assertion": "assertEquals ( Result, passed )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( Result, passed ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_26.txt",
  "assertion": "assertEquals ( \"\", valid )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( \"\", valid ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_27.txt",
  "assertion": "assertEquals ( resulting, _ )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( resulting, _ ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_28.txt",
  "assertion": "assertEquals ( answer, length )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( answer, length ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_29.txt",
  "assertion": "assertEquals ( new, response )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( new, response ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "89_3.txt",
  "assertion": "assertEquals (pected, expecting )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals (pected, expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_4.txt",
  "assertion": "assertEquals ( expect, actual )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expect, actual ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_5.txt",
  "assertion": "assertEquals ( actual, resulting )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( actual, resulting ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_6.txt",
  "assertion": "assertEquals (expected, answer )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals (expected, answer ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_7.txt",
  "assertion": "assertEquals ( ret, message )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( ret, message ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_8.txt",
  "assertion": "assertEquals ( returned, ret )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( returned, ret ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "89_9.txt",
  "assertion": "assertEquals ( read, results )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( read, results ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( result, result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "8_0.txt",
  "assertion": "assertEquals ( 0, timer. getWaitTime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, timer. getWaitTime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_1.txt",
  "assertion": "assertEquals ( 1, 0. Get wait time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, 0. Get wait time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_10.txt",
  "assertion": "assertEquals ( 20, os. minQueueTim ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 20, os. minQueueTim ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_11.txt",
  "assertion": "assertEquals ( 200, 2. gettingHolder ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 200, 2. gettingHolder ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_12.txt",
  "assertion": "assertEquals ( 8, timeout. gSleepMemory ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, timeout. gSleepMemory ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_13.txt",
  "assertion": "assertEquals ( i, 1. availableAcceptNow ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( i, 1. availableAcceptNow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_14.txt",
  "assertion": "assertEquals ( time, system. totalUtCount ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( time, system. totalUtCount ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_15.txt",
  "assertion": "assertEquals ( min, alarm. groupaitTimeout ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( min, alarm. groupaitTimeout ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_16.txt",
  "assertion": "assertEquals ( None, EM. sizeDurationClock ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( None, EM. sizeDurationClock ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_17.txt",
  "assertion": "assertEquals ( 50, settings. countBufferFire ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 50, settings. countBufferFire ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_18.txt",
  "assertion": "assertEquals ( 6, counter. newMustWeight ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 6, counter. newMustWeight ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_19.txt",
  "assertion": "assertEquals ( 30, times. eventMaxMill ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 30, times. eventMaxMill ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_2.txt",
  "assertion": "assertEquals ( 2, System.get Waittime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, System.get Waittime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_20.txt",
  "assertion": "assertEquals ( \"\", runtime. _TimeT ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( \"\", runtime. _TimeT ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_21.txt",
  "assertion": "assertEquals ( 10000, self. calculateJoinWork ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10000, self. calculateJoinWork ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_22.txt",
  "assertion": "assertEquals ( 7, sys. incrementQFit ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, sys. incrementQFit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_23.txt",
  "assertion": "assertEquals ( 15, countdown. numberAllowed ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 15, countdown. numberAllowed ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_24.txt",
  "assertion": "assertEquals ( timer, event. pollDel times ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( timer, event. pollDel times ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_25.txt",
  "assertion": "assertEquals ( 5000, duration. timerDateNice ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5000, duration. timerDateNice ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_26.txt",
  "assertion": "assertEquals ( 60, Time. timeoutDefaultVal ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 60, Time. timeoutDefaultVal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_27.txt",
  "assertion": "assertEquals ( zero, util. defaultGetLong ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( zero, util. defaultGetLong ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_28.txt",
  "assertion": "assertEquals ( 500, global. guessRequestStyle ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 500, global. guessRequestStyle ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_29.txt",
  "assertion": "assertEquals (0, C. randomStatusSound ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals (0, C. randomStatusSound ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_3.txt",
  "assertion": "assertEquals ( 3, this. currentWa Time ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, this. currentWa Time ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "8_4.txt",
  "assertion": "assertEquals ( 1000, time. getsSendTimer ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1000, time. getsSendTimer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_5.txt",
  "assertion": "assertEquals ( 4, timers. timewaitThread ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, timers. timewaitThread ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_6.txt",
  "assertion": "assertEquals ( 10, Clock. givenDaTimes ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 10, Clock. givenDaTimes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_7.txt",
  "assertion": "assertEquals ( 5, clock. maxEventime ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 5, clock. maxEventime ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_8.txt",
  "assertion": "assertEquals ( 100, timing. gotTotalValue ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 100, timing. gotTotalValue ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "8_9.txt",
  "assertion": "assertEquals ( 2000, timed. globalListenSize ( ) )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2000, timed. globalListenSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( 2, timer. getWaitTime ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "90_0.txt",
  "assertion": "assertNull ( result )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( result ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_1.txt",
  "assertion": "assertNull ( expected )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( expected ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_10.txt",
  "assertion": "assertNull ( actual )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( actual ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_11.txt",
  "assertion": "assertNull ( Result )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( Result ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_12.txt",
  "assertion": "assertNull ( unexpected )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( unexpected ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_13.txt",
  "assertion": "assertNull ( value )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( value ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_14.txt",
  "assertion": "assertNull (result )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull (result ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_15.txt",
  "assertion": "assertNull ( resulted )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( resulted ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_16.txt",
  "assertion": "assertNull ( results )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( results ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_17.txt",
  "assertion": "assertNull ( formatted )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( formatted ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_18.txt",
  "assertion": "assertNull ( received )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( received ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_19.txt",
  "assertion": "assertNull ( allowed )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( allowed ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_2.txt",
  "assertion": "assertNull ( expecting )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( expecting ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_20.txt",
  "assertion": "assertNull (expected )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull (expected ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_21.txt",
  "assertion": "assertNull ( expectation )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( expectation ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_22.txt",
  "assertion": "assertNull ( read )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( read ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_23.txt",
  "assertion": "assertNull ( length )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( length ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_24.txt",
  "assertion": "assertNull (Result )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull (Result ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_25.txt",
  "assertion": "assertNull ( content )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( content ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_26.txt",
  "assertion": "assertNull ( input )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( input ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_27.txt",
  "assertion": "assertNull ( thrown )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( thrown ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_28.txt",
  "assertion": "assertNull ( data )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( data ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_29.txt",
  "assertion": "assertNull ( parsed )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( parsed ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_3.txt",
  "assertion": "assertNull ( answer )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( answer ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_4.txt",
  "assertion": "assertNull ( ret )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( ret ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_5.txt",
  "assertion": "assertNull ( found )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( found ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_6.txt",
  "assertion": "assertNull ( returned )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( returned ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_7.txt",
  "assertion": "assertNull ( expect )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( expect ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_8.txt",
  "assertion": "assertNull ( message )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( message ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "90_9.txt",
  "assertion": "assertNull ( resulting )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( resulting ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( result )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "91_0.txt",
  "assertion": "assertNotNull ( reminder2. reminder reminder )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( reminder2. reminder reminder ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_1.txt",
  "assertion": "assertNotNull ( reminders. [ (2 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( reminders. [ (2 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_10.txt",
  "assertion": "assertNotNull ( minder ]2inder )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( minder ]2inder ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_11.txt",
  "assertion": "assertNotNull ( reminding } \u003d\u003d 1 reminders )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( reminding } \u003d\u003d 1 reminders ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_12.txt",
  "assertion": "assertNotNull ( getTwo Rem secondSecond )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( getTwo Rem secondSecond ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_13.txt",
  "assertion": "assertNotNull ( memo3D 4Day )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( memo3D 4Day ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_14.txt",
  "assertion": "assertNotNull ( rem ] \u003e ]set )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( rem ] \u003e ]set ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_15.txt",
  "assertion": "assertNotNull ( r_ remindersSign second )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( r_ remindersSign second ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_16.txt",
  "assertion": "assertNotNull ( remembered ;s [DAY )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( remembered ;s [DAY ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_17.txt",
  "assertion": "assertNotNull ( annRetS message today )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( annRetS message today ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_18.txt",
  "assertion": "assertNotNull ( 2rem findSS )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( 2rem findSS ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_19.txt",
  "assertion": "assertNotNull ( 40Rem Rem 0 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( 40Rem Rem 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_2.txt",
  "assertion": "assertNotNull ( remind,, reminders 2 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( remind,, reminders 2 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_20.txt",
  "assertion": "assertNotNull ( keeping \u003d\u003d :SetSet )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( keeping \u003d\u003d :SetSet ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_21.txt",
  "assertion": "assertNotNull ( keepIn__,Today )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( keepIn__,Today ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_22.txt",
  "assertion": "assertNotNull ( markersient { remarks day )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( markersient { remarks day ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_23.txt",
  "assertion": "assertNotNull ( resAl valuesEMBERD )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( resAl valuesEMBERD ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_24.txt",
  "assertion": "assertNotNull ( diamondinders dismissedMessage 4 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( diamondinders dismissedMessage 4 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_25.txt",
  "assertion": "assertNotNull ( notices02030 }secondary )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( notices02030 }secondary ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_26.txt",
  "assertion": "assertNotNull ( ) [ remove\u003cs\u003eday )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( ) [ remove\u003cs\u003eday ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_27.txt",
  "assertion": "assertNotNull ( refNot!\u003d add 12 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( refNot!\u003d add 12 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_28.txt",
  "assertion": "assertNotNull ( REMPersonarks { null )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( REMPersonarks { null ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_29.txt",
  "assertion": "assertNotNull ( Tjs extractSandList )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( Tjs extractSandList ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_3.txt",
  "assertion": "assertNotNull ( ret1indersSecond ] )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( ret1indersSecond ] ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_4.txt",
  "assertion": "assertNotNull ( RemSecondinder remind ( )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( RemSecondinder remind ( ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_5.txt",
  "assertion": "assertNotNull ( remarks ) }inder ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( remarks ) }inder ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_6.txt",
  "assertion": "assertNotNull ( reminded4 ) 21 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( reminded4 ) 21 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_7.txt",
  "assertion": "assertNotNull ( [Rem (inders 1 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( [Rem (inders 1 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_8.txt",
  "assertion": "assertNotNull ( {To addRem12 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( {To addRem12 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "91_9.txt",
  "assertion": "assertNotNull ( ( 2 get 0 } )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNotNull ( ( 2 get 0 } ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNotNull ( mondayMorningReminders )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_0.txt",
  "assertion": "assertTrue ( out. isEmpty ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( out. isEmpty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_1.txt",
  "assertion": "assertTrue ( Out. anyList ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Out. anyList ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_10.txt",
  "assertion": "assertTrue ( err.!Set ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( err.!Set ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_11.txt",
  "assertion": "assertTrue ( 2. valueEnabled ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( 2. valueEnabled ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_12.txt",
  "assertion": "assertTrue ( check. keyView ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( check. keyView ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_13.txt",
  "assertion": "assertTrue ( true. booleanSize ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( true. booleanSize ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_14.txt",
  "assertion": "assertTrue ( Err. nonAny ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Err. nonAny ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_15.txt",
  "assertion": "assertTrue ( os. modItems ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( os. modItems ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_16.txt",
  "assertion": "assertTrue ( false. already Empty ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( false. already Empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_17.txt",
  "assertion": "assertTrue ( Boolean. newString ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Boolean. newString ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_18.txt",
  "assertion": "assertTrue ( Array. elementOnly ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Array. elementOnly ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_19.txt",
  "assertion": "assertTrue ( list. hashClear ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( list. hashClear ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_2.txt",
  "assertion": "assertTrue ( outs. contains empty ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( outs. contains empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_20.txt",
  "assertion": "assertTrue ( ext. raContainer ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( ext. raContainer ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_21.txt",
  "assertion": "assertTrue ( Exception. getObject ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Exception. getObject ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_22.txt",
  "assertion": "assertTrue ( script. wasEntry ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( script. wasEntry ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_23.txt",
  "assertion": "assertTrue ( Check. areNull ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Check. areNull ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_24.txt",
  "assertion": "assertTrue ( outside. unIndex ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( outside. unIndex ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_25.txt",
  "assertion": "assertTrue ( exit. isnElement ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( exit. isnElement ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_26.txt",
  "assertion": "assertTrue ( test. itemKey ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( test. itemKey ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_27.txt",
  "assertion": "assertTrue ( eligible. invalidItem ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( eligible. invalidItem ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_28.txt",
  "assertion": "assertTrue ( 3. valuesLast ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( 3. valuesLast ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_29.txt",
  "assertion": "assertTrue ( checkout. initialSearch ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( checkout. initialSearch ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_3.txt",
  "assertion": "assertTrue (out. toNext ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue (out. toNext ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_4.txt",
  "assertion": "assertTrue (Out. hasArray ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue (Out. hasArray ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_5.txt",
  "assertion": "assertTrue ( this. entryempty ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( this. entryempty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_6.txt",
  "assertion": "assertTrue ( System. emptyFull ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( System. emptyFull ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_7.txt",
  "assertion": "assertTrue ( OUT. sizeAll ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( OUT. sizeAll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "92_8.txt",
  "assertion": "assertTrue ( 0. addValid ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( 0. addValid ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "92_9.txt",
  "assertion": "assertTrue ( in. norFirst ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( in. norFirst ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( out. isEmpty ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "93_0.txt",
  "assertion": "assertEquals ( actualListItem, actualListItem )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( actualListItem, actualListItem ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_1.txt",
  "assertion": "assertEquals ( expectedItem item, expectedItem item )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expectedItem item, expectedItem item ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_10.txt",
  "assertion": "assertEquals ( existingSetMember, resultSetAdapter )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( existingSetMember, resultSetAdapter ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_11.txt",
  "assertion": "assertEquals ( 0TreeContainer, currentViewList )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 0TreeContainer, currentViewList ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_12.txt",
  "assertion": "assertEquals ( trueDataElement, \"ArrayContainer )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( trueDataElement, \"ArrayContainer ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_13.txt",
  "assertion": "assertEquals ( correctArrayModel, expectingTypeMember )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( correctArrayModel, expectingTypeMember ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_14.txt",
  "assertion": "assertEquals ( itemValueComponent, properGroup\" )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( itemValueComponent, properGroup\" ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_15.txt",
  "assertion": "assertEquals ( \"ParentList, effectiveMemberer )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( \"ParentList, effectiveMemberer ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_16.txt",
  "assertion": "assertEquals ( currentSingleValue, correctParentModel )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( currentSingleValue, correctParentModel ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_17.txt",
  "assertion": "assertEquals ( requiredStyleProperty, actuallyObjectElement )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( requiredStyleProperty, actuallyObjectElement ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_18.txt",
  "assertion": "assertEquals ( updatedObject1, valStyleProperty )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( updatedObject1, valStyleProperty ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_19.txt",
  "assertion": "assertEquals ( (MemberView, newSingleComponent )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( (MemberView, newSingleComponent ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_2.txt",
  "assertion": "assertEquals ( fakeLItems, realLItems )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( fakeLItems, realLItems ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_20.txt",
  "assertion": "assertEquals ( proper ListObject, ActualMapIndex )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( proper ListObject, ActualMapIndex ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_21.txt",
  "assertion": "assertEquals ( definedLineNode, initial ListSet )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( definedLineNode, initial ListSet ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_22.txt",
  "assertion": "assertEquals ( 1TableColumn, eventistData )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 1TableColumn, eventistData ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_23.txt",
  "assertion": "assertEquals ( expistSpec, expectTableInfo )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expistSpec, expectTableInfo ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_24.txt",
  "assertion": "assertEquals ( effectiveMapSet, operationLineView )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( effectiveMapSet, operationLineView ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_25.txt",
  "assertion": "assertEquals ( unexpectedRestTop, validRestType )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( unexpectedRestTop, validRestType ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_26.txt",
  "assertion": "assertEquals ( eventClassIndex, truePropertyObject )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( eventClassIndex, truePropertyObject ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_27.txt",
  "assertion": "assertEquals ( retLeftData, unexpectedWatchContents )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( retLeftData, unexpectedWatchContents ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_28.txt",
  "assertion": "assertEquals ( newLISTManager, (ClassParser )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( newLISTManager, (ClassParser ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_29.txt",
  "assertion": "assertEquals ( operationPropertyEx, responseComponent1 )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( operationPropertyEx, responseComponent1 ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_3.txt",
  "assertion": "assertEquals ( expect list Item,actuallist Item )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expect list Item,actuallist Item ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_4.txt",
  "assertion": "assertEquals ( expectinglistitem, fake listitem )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expectinglistitem, fake listitem ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_5.txt",
  "assertion": "assertEquals ( originalTypeI, originalStringI )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( originalTypeI, originalStringI ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_6.txt",
  "assertion": "assertEquals ( realGroupIt, itemValue ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( realGroupIt, itemValue ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "93_7.txt",
  "assertion": "assertEquals (actualMenuAdapter, receivedDataIt )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals (actualMenuAdapter, receivedDataIt ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_8.txt",
  "assertion": "assertEquals ( resultStringItemImage, existingMenuItemImage )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( resultStringItemImage, existingMenuItemImage ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "93_9.txt",
  "assertion": "assertEquals ( receivedViewer, updatedTreeValue )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( receivedViewer, updatedTreeValue ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( expectedListItem, actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_0.txt",
  "assertion": "assertNull ( actualListItem )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( actualListItem ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "true",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_1.txt",
  "assertion": "assertNull ( expectedItem item )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( expectedItem item ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "94_10.txt",
  "assertion": "assertNull ( eventDataMember )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( eventDataMember ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_11.txt",
  "assertion": "assertNull ( updatedStyleContainer )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( updatedStyleContainer ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_12.txt",
  "assertion": "assertNull (actualLanguageManager )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull (actualLanguageManager ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_13.txt",
  "assertion": "assertNull ( trueSetParser )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( trueSetParser ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_14.txt",
  "assertion": "assertNull ( initialArrayProperty )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( initialArrayProperty ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_15.txt",
  "assertion": "assertNull ( resultListenerModel )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( resultListenerModel ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_16.txt",
  "assertion": "assertNull ( effectiveistError )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( effectiveistError ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_17.txt",
  "assertion": "assertNull ( properStringProvider )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( properStringProvider ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_18.txt",
  "assertion": "assertNull ( correctValueListener )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( correctValueListener ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_19.txt",
  "assertion": "assertNull ( itemViewAlias )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( itemViewAlias ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_2.txt",
  "assertion": "assertNull ( real listItems )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( real listItems ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "94_20.txt",
  "assertion": "assertNull ( validGroupValue )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( validGroupValue ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_21.txt",
  "assertion": "assertNull ( targetMapElement )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( targetMapElement ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_22.txt",
  "assertion": "assertNull (ualFileEM )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull (ualFileEM ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_23.txt",
  "assertion": "assertNull ( nullObjectComponent )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( nullObjectComponent ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_24.txt",
  "assertion": "assertNull ( valueTableFile )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( valueTableFile ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_25.txt",
  "assertion": "assertNull ( finalClassEditor )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( finalClassEditor ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_26.txt",
  "assertion": "assertNull ( operationLeftMessage )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( operationLeftMessage ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_27.txt",
  "assertion": "assertNull ( retQueueParameter )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( retQueueParameter ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_28.txt",
  "assertion": "assertNull ( physicalLineIndex )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( physicalLineIndex ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_29.txt",
  "assertion": "assertNull ( \" ListBuilder )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( \" ListBuilder ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "94_3.txt",
  "assertion": "assertNull ( actuallylist Item )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( actuallylist Item ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "94_4.txt",
  "assertion": "assertNull ( fakeLibraryitem )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( fakeLibraryitem ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_5.txt",
  "assertion": "assertNull ( originalMenuI )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( originalMenuI ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_6.txt",
  "assertion": "assertNull ( receivedLAdapter )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( receivedLAdapter ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_7.txt",
  "assertion": "assertNull ( existingTreeItemImage )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( existingTreeItemImage ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_8.txt",
  "assertion": "assertNull ( currentWatcher )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( currentWatcher ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "94_9.txt",
  "assertion": "assertNull ( valParentIt )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertNull ( valParentIt ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertNull ( actualListItem )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "95_0.txt",
  "assertion": "assertTrue ( query. evaluate ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( query. evaluate ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_1.txt",
  "assertion": "assertTrue ( this.evaluate ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( this.evaluate ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_10.txt",
  "assertion": "assertTrue ( check. calculate ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( check. calculate ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_11.txt",
  "assertion": "assertTrue ( ). count ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( ). count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_12.txt",
  "assertion": "assertTrue ( empty. analyze ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( empty. analyze ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_13.txt",
  "assertion": "assertTrue ( result. validate ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( result. validate ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_14.txt",
  "assertion": "assertTrue ( queries. test ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( queries. test ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_15.txt",
  "assertion": "assertTrue ( search. get ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( search. get ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_16.txt",
  "assertion": "assertTrue ( value. apply ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( value. apply ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_17.txt",
  "assertion": "assertTrue ( test. assess ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( test. assess ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_18.txt",
  "assertion": "assertTrue (!. negate ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue (!. negate ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_19.txt",
  "assertion": "assertTrue ( expr. decide ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( expr. decide ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_2.txt",
  "assertion": "assertTrue ( false. eval ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( false. eval ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_20.txt",
  "assertion": "assertTrue ( filter. accept ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( filter. accept ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_21.txt",
  "assertion": "assertTrue ( statement. outcome ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( statement. outcome ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_22.txt",
  "assertion": "assertTrue ( get. interpret ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( get. interpret ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_23.txt",
  "assertion": "assertTrue ( Boolean. determine ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Boolean. determine ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_24.txt",
  "assertion": "assertTrue ( condition. result ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( condition. result ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_25.txt",
  "assertion": "assertTrue ( boolean. run ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( boolean. run ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_26.txt",
  "assertion": "assertTrue ( random. retrieve ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( random. retrieve ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_27.txt",
  "assertion": "assertTrue ( read. equal ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( read. equal ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_28.txt",
  "assertion": "assertTrue ( expected. value ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( expected. value ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_29.txt",
  "assertion": "assertTrue ( is. exec ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( is. exec ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_3.txt",
  "assertion": "assertTrue ( q. evaluates ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( q. evaluates ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_4.txt",
  "assertion": "assertTrue ( Query. evaluation ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Query. evaluation ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_5.txt",
  "assertion": "assertTrue ( true. execute ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( true. execute ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_6.txt",
  "assertion": "assertTrue ( 0. evaluated ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( 0. evaluated ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "95_7.txt",
  "assertion": "assertTrue ( Q. evaluating ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( Q. evaluating ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_8.txt",
  "assertion": "assertTrue ( \"\". find ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( \"\". find ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "95_9.txt",
  "assertion": "assertTrue ( null. evaluations ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertTrue ( null. evaluations ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertTrue ( query. evaluate ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "finished",
  "parse context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_0.txt",
  "assertion": "assertEquals ( 2, objects. size ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 2, objects. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "true",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_1.txt",
  "assertion": "assertEquals ( 1, object.size ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 1, object.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_10.txt",
  "assertion": "assertEquals ( OR, 0. index ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( OR, 0. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "96_11.txt",
  "assertion": "assertEquals ( NO, items. first ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( NO, items. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_12.txt",
  "assertion": "assertEquals (2, strings. sized ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals (2, strings. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_13.txt",
  "assertion": "assertEquals ( 7, 2. sort ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 7, 2. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "96_14.txt",
  "assertion": "assertEquals ( 6, classes. filter ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 6, classes. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_15.txt",
  "assertion": "assertEquals ( N, keys. sizeof ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( N, keys. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_16.txt",
  "assertion": "assertEquals (1, bots. max ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals (1, bots. max ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_17.txt",
  "assertion": "assertEquals ( 10, obj. limit ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 10, obj. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_18.txt",
  "assertion": "assertEquals ( TWO, models. keys ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( TWO, models. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_19.txt",
  "assertion": "assertEquals ( ONE, values. order ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( ONE, values. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_2.txt",
  "assertion": "assertEquals ( 0, Objects. empty ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 0, Objects. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_20.txt",
  "assertion": "assertEquals ( Two, Collections. list ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( Two, Collections. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_21.txt",
  "assertion": "assertEquals ( 9, organizations. poll ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 9, organizations. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_22.txt",
  "assertion": "assertEquals ( one, groups. iterator ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( one, groups. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_23.txt",
  "assertion": "assertEquals ( 11, elements. next ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 11, elements. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_24.txt",
  "assertion": "assertEquals ( EQ, activities. stream ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( EQ, activities. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_25.txt",
  "assertion": "assertEquals ( IN, 1. sizing ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( IN, 1. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "96_26.txt",
  "assertion": "assertEquals ( 20, list. term ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 20, list. term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_27.txt",
  "assertion": "assertEquals ( false, results. peek ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( false, results. peek ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_28.txt",
  "assertion": "assertEquals ( Collections, threads.SIZE ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( Collections, threads.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_29.txt",
  "assertion": "assertEquals ( 16, entries. grow ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 16, entries. grow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_3.txt",
  "assertion": "assertEquals ( 3,objects.Size ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 3,objects.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_4.txt",
  "assertion": "assertEquals ( 4, languages. length ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 4, languages. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_5.txt",
  "assertion": "assertEquals ( two, messages. Size ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( two, messages. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_6.txt",
  "assertion": "assertEquals ( 5, null. sizes ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 5, null. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_7.txt",
  "assertion": "assertEquals ( expected, collections. count ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( expected, collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_8.txt",
  "assertion": "assertEquals ( null, types. clone ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( null, types. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "96_9.txt",
  "assertion": "assertEquals ( 8, versions. values ( ) )\r\n",
  "test": "class X {public void droppedTable ( ) { Table t \u003d newTable ( \"default\" , \"dt\" , false ) ; addDeltaFile ( t , null , 1L , 22L , 22 ) ; addDeltaFile ( t , null , 23L , 24L , 2 ) ; addBaseFile ( t , null , 25L , 25 ) ; burnThroughTransactions ( \"default\" , \"dt\" , 25 ) ; CompactionRequest rqst \u003d new CompactionRequest ( \"default\" , \"dt\" , org . apache . hadoop . hive . metastore . api . CompactionType . MINOR ) ; txnHandler . compact ( rqst ) ; CompactionInfo ci \u003d txnHandler . findNextToCompact ( \"fred\" ) ; ci . runAs \u003d System . getProperty ( \"user.name\" ) ; txnHandler . updateCompactorState ( ci , openTxn ( ) ) ; txnHandler . markCompacted ( ci ) ; ms . dropTable ( \"default\" , \"dt\" ) ; startCleaner ( ) ; ShowCompactResponse rsp \u003d txnHandler . showCompact ( new ShowCompactRequest ( ) ) ; assertEquals ( 8, versions. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getCompactsSize ( ) { return ( this . compacts ) \u003d\u003d null ? 0 : compacts . size ( ) ; } }\r\n",
  "truth": "assertEquals ( 2, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_0.txt",
  "assertion": "assertEquals ( 2, objects. size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 2, objects. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_1.txt",
  "assertion": "assertEquals ( 1, object.size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 1, object.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_10.txt",
  "assertion": "assertEquals ( OR, 0. index ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( OR, 0. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_11.txt",
  "assertion": "assertEquals ( NO, items. first ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( NO, items. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_12.txt",
  "assertion": "assertEquals (2, strings. sized ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals (2, strings. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_13.txt",
  "assertion": "assertEquals ( 7, 2. sort ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 7, 2. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_14.txt",
  "assertion": "assertEquals ( 6, classes. filter ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 6, classes. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_15.txt",
  "assertion": "assertEquals ( N, keys. sizeof ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( N, keys. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_16.txt",
  "assertion": "assertEquals (1, bots. max ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals (1, bots. max ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_17.txt",
  "assertion": "assertEquals ( 10, obj. limit ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 10, obj. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_18.txt",
  "assertion": "assertEquals ( TWO, models. keys ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( TWO, models. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_19.txt",
  "assertion": "assertEquals ( ONE, values. order ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( ONE, values. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_2.txt",
  "assertion": "assertEquals ( 0, Objects. empty ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 0, Objects. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_20.txt",
  "assertion": "assertEquals ( Two, Collections. list ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( Two, Collections. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_21.txt",
  "assertion": "assertEquals ( 9, organizations. poll ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 9, organizations. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_22.txt",
  "assertion": "assertEquals ( one, groups. iterator ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( one, groups. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_23.txt",
  "assertion": "assertEquals ( 11, elements. next ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 11, elements. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_24.txt",
  "assertion": "assertEquals ( EQ, activities. stream ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( EQ, activities. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_25.txt",
  "assertion": "assertEquals ( IN, 1. sizing ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( IN, 1. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "97_26.txt",
  "assertion": "assertEquals ( 20, list. term ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 20, list. term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_27.txt",
  "assertion": "assertEquals ( false, results. peek ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( false, results. peek ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_28.txt",
  "assertion": "assertEquals ( Collections, threads.SIZE ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( Collections, threads.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_29.txt",
  "assertion": "assertEquals ( 16, entries. grow ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 16, entries. grow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_3.txt",
  "assertion": "assertEquals ( 3,objects.Size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 3,objects.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_4.txt",
  "assertion": "assertEquals ( 4, languages. length ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 4, languages. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_5.txt",
  "assertion": "assertEquals ( two, messages. Size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( two, messages. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_6.txt",
  "assertion": "assertEquals ( 5, null. sizes ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 5, null. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_7.txt",
  "assertion": "assertEquals ( expected, collections. count ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( expected, collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_8.txt",
  "assertion": "assertEquals ( null, types. clone ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( null, types. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "97_9.txt",
  "assertion": "assertEquals ( 8, versions. values ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 8, versions. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 0, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_0.txt",
  "assertion": "assertEquals ( 2, objects. size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 2, objects. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_1.txt",
  "assertion": "assertEquals ( 1, object.size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 1, object.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_10.txt",
  "assertion": "assertEquals ( OR, 0. index ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( OR, 0. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_11.txt",
  "assertion": "assertEquals ( NO, items. first ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( NO, items. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_12.txt",
  "assertion": "assertEquals (2, strings. sized ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals (2, strings. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_13.txt",
  "assertion": "assertEquals ( 7, 2. sort ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 7, 2. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_14.txt",
  "assertion": "assertEquals ( 6, classes. filter ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 6, classes. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_15.txt",
  "assertion": "assertEquals ( N, keys. sizeof ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( N, keys. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_16.txt",
  "assertion": "assertEquals (1, bots. max ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals (1, bots. max ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_17.txt",
  "assertion": "assertEquals ( 10, obj. limit ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 10, obj. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_18.txt",
  "assertion": "assertEquals ( TWO, models. keys ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( TWO, models. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_19.txt",
  "assertion": "assertEquals ( ONE, values. order ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( ONE, values. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_2.txt",
  "assertion": "assertEquals ( 0, Objects. empty ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 0, Objects. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_20.txt",
  "assertion": "assertEquals ( Two, Collections. list ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( Two, Collections. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_21.txt",
  "assertion": "assertEquals ( 9, organizations. poll ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 9, organizations. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_22.txt",
  "assertion": "assertEquals ( one, groups. iterator ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( one, groups. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_23.txt",
  "assertion": "assertEquals ( 11, elements. next ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 11, elements. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_24.txt",
  "assertion": "assertEquals ( EQ, activities. stream ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( EQ, activities. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_25.txt",
  "assertion": "assertEquals ( IN, 1. sizing ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( IN, 1. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "98_26.txt",
  "assertion": "assertEquals ( 20, list. term ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 20, list. term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_27.txt",
  "assertion": "assertEquals ( false, results. peek ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( false, results. peek ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_28.txt",
  "assertion": "assertEquals ( Collections, threads.SIZE ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( Collections, threads.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_29.txt",
  "assertion": "assertEquals ( 16, entries. grow ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 16, entries. grow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_3.txt",
  "assertion": "assertEquals ( 3,objects.Size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 3,objects.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_4.txt",
  "assertion": "assertEquals ( 4, languages. length ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 4, languages. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_5.txt",
  "assertion": "assertEquals ( two, messages. Size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( two, messages. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_6.txt",
  "assertion": "assertEquals ( 5, null. sizes ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 5, null. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_7.txt",
  "assertion": "assertEquals ( expected, collections. count ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( expected, collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_8.txt",
  "assertion": "assertEquals ( null, types. clone ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( null, types. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "98_9.txt",
  "assertion": "assertEquals ( 8, versions. values ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 8, versions. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 5, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_0.txt",
  "assertion": "assertEquals ( 2, objects. size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 2, objects. size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_1.txt",
  "assertion": "assertEquals ( 1, object.size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 1, object.size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_10.txt",
  "assertion": "assertEquals ( OR, 0. index ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( OR, 0. index ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_11.txt",
  "assertion": "assertEquals ( NO, items. first ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( NO, items. first ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_12.txt",
  "assertion": "assertEquals (2, strings. sized ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals (2, strings. sized ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_13.txt",
  "assertion": "assertEquals ( 7, 2. sort ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 7, 2. sort ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_14.txt",
  "assertion": "assertEquals ( 6, classes. filter ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 6, classes. filter ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_15.txt",
  "assertion": "assertEquals ( N, keys. sizeof ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( N, keys. sizeof ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_16.txt",
  "assertion": "assertEquals (1, bots. max ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals (1, bots. max ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_17.txt",
  "assertion": "assertEquals ( 10, obj. limit ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 10, obj. limit ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_18.txt",
  "assertion": "assertEquals ( TWO, models. keys ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( TWO, models. keys ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_19.txt",
  "assertion": "assertEquals ( ONE, values. order ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( ONE, values. order ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_2.txt",
  "assertion": "assertEquals ( 0, Objects. empty ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 0, Objects. empty ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_20.txt",
  "assertion": "assertEquals ( Two, Collections. list ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( Two, Collections. list ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_21.txt",
  "assertion": "assertEquals ( 9, organizations. poll ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 9, organizations. poll ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_22.txt",
  "assertion": "assertEquals ( one, groups. iterator ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( one, groups. iterator ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_23.txt",
  "assertion": "assertEquals ( 11, elements. next ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 11, elements. next ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_24.txt",
  "assertion": "assertEquals ( EQ, activities. stream ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( EQ, activities. stream ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_25.txt",
  "assertion": "assertEquals ( IN, 1. sizing ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( IN, 1. sizing ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "stop parsing": "arg is null. It might be caused by assertion parse error."
}
,
{
  "file": "99_26.txt",
  "assertion": "assertEquals ( 20, list. term ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 20, list. term ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_27.txt",
  "assertion": "assertEquals ( false, results. peek ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( false, results. peek ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_28.txt",
  "assertion": "assertEquals ( Collections, threads.SIZE ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( Collections, threads.SIZE ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_29.txt",
  "assertion": "assertEquals ( 16, entries. grow ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 16, entries. grow ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_3.txt",
  "assertion": "assertEquals ( 3,objects.Size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 3,objects.Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_4.txt",
  "assertion": "assertEquals ( 4, languages. length ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 4, languages. length ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_5.txt",
  "assertion": "assertEquals ( two, messages. Size ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( two, messages. Size ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_6.txt",
  "assertion": "assertEquals ( 5, null. sizes ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 5, null. sizes ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_7.txt",
  "assertion": "assertEquals ( expected, collections. count ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( expected, collections. count ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_8.txt",
  "assertion": "assertEquals ( null, types. clone ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( null, types. clone ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "99_9.txt",
  "assertion": "assertEquals ( 8, versions. values ( ) )\r\n",
  "test": "class X {public void shardRollUpAndNodesSomeDontExist ( ) { Node node \u003d QueryBuilder . create ( ) . QueryBuilder . and ( ) . QueryBuilder . eq ( \"key4\" , \"val2\" ) . QueryBuilder . eq ( \"key2\" , \"val2\" ) . QueryBuilder . end ( ) . QueryBuilder . build ( ) ; CalculateShardsVisitor visitor \u003d runShardsVisitor ( node ) ; assertEquals ( 8, versions. values ( ) ) ; } }\r\n",
  "focal method": "class Y{ public void getShards ( ) { return finalShards ; } }\r\n",
  "truth": "assertEquals ( 200, objects. size ( ) )\r\n",
  "trivial_check": "finished",
  "parse focal method": "true",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "unsolved argument or method call exists"
}
,
{
  "file": "9_0.txt",
  "assertion": "assertEquals ( date, date )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( date, date ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "stop parsing": "arg1 \u003d\u003d arg2",
  "trivial_check": "finished",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_1.txt",
  "assertion": "assertEquals ( avg, dat )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( avg, dat ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_10.txt",
  "assertion": "assertEquals ( agg, now )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( agg, now ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_11.txt",
  "assertion": "assertEquals ( 7, data )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 7, data ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_12.txt",
  "assertion": "assertEquals ( today, 2 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( today, 2 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_13.txt",
  "assertion": "assertEquals ( now, 42 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( now, 42 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_14.txt",
  "assertion": "assertEquals ( 3, average )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 3, average ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_15.txt",
  "assertion": "assertEquals ( expected, time )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( expected, time ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_16.txt",
  "assertion": "assertEquals ( start, rate )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( start, rate ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_17.txt",
  "assertion": "assertEquals ( min, value )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( min, value ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_18.txt",
  "assertion": "assertEquals ( time, 8 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( time, 8 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_19.txt",
  "assertion": "assertEquals ( base, Date )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( base, Date ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_2.txt",
  "assertion": "assertEquals ( 0, avg )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 0, avg ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_20.txt",
  "assertion": "assertEquals ( update, d )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( update, d ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_21.txt",
  "assertion": "assertEquals ( 8, start )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 8, start ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_22.txt",
  "assertion": "assertEquals ( Date, age )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( Date, age ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_23.txt",
  "assertion": "assertEquals ( 4, 2018 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 4, 2018 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_24.txt",
  "assertion": "assertEquals ( bc, end )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( bc, end ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_25.txt",
  "assertion": "assertEquals ( data, m )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( data, m ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_26.txt",
  "assertion": "assertEquals ( aggregate, result )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( aggregate, result ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_27.txt",
  "assertion": "assertEquals ( year, 3 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( year, 3 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_28.txt",
  "assertion": "assertEquals ( current, mean )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( current, mean ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_29.txt",
  "assertion": "assertEquals ( 42, 2015 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 42, 2015 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_3.txt",
  "assertion": "assertEquals ( dat, 0 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( dat, 0 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_4.txt",
  "assertion": "assertEquals ( 1, g )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 1, g ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_5.txt",
  "assertion": "assertEquals ( average, today )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( average, today ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_6.txt",
  "assertion": "assertEquals ( index, 1 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( index, 1 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_7.txt",
  "assertion": "assertEquals ( 2, index )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( 2, index ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_8.txt",
  "assertion": "assertEquals ( g, 7 )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( g, 7 ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
{
  "file": "9_9.txt",
  "assertion": "assertEquals ( mean, update )\r\n",
  "test": "class X {public void getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { TopicWatchRepository dao \u003d this . newDao ( ) ; Topic topic \u003d new Topic ( ) ; topic . setId ( 13 ) ; List \u003c User \u003e users \u003d dao . getUsersWaitingNotification ( topic ) ; assertEquals ( mean, update ) ; } }\r\n",
  "focal method": "class Y{ public void getUsersWaitingNotification ( Topic var24678 ) { List \u003c User \u003e users \u003d session . createQuery ( ( \"select\u003csp\u003eu\u003csp\u003efrom\u003csp\u003eTopicWatch\u003csp\u003etw\u003csp\u003e\" + ( \"\u003csp\u003einner\u003csp\u003ejoin\u003csp\u003etw.user\u003csp\u003eu\u003csp\u003ewhere\u003csp\u003etw.topic\u003csp\u003e\u003d\u003csp\u003e:topic\u003csp\u003e\" + \"\u003csp\u003eand\u003csp\u003e(tw.read\u003csp\u003e\u003d\u003csp\u003etrue\u003csp\u003eor\u003csp\u003eu.notifyAlways\u003csp\u003e\u003d\u003csp\u003etrue)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) \u003e 0 ) { this . markAllAsUnread ( topic ) ; } return users ; } }\r\n",
  "truth": "assertEquals ( date, avg )\r\n",
  "trivial_check": "finished",
  "parse focal method": "false",
  "parse_context": "finished",
  "correct answer": "false",
  "result": "cannot solve all the type info"
}
,
